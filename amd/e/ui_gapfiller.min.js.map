{"version":3,"file":"ui_gapfiller.min.js","sources":["../src/ui_gapfiller.js"],"sourcesContent":["/**\n * This file is part of Moodle - http:moodle.org/\n *\n * Moodle is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Moodle is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more util.details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Moodle.  If not, see <http:www.gnu.org/licenses/>.\n */\n\n/**\n * Implementation of the gapfiller_ui user interface plugin. For overall details\n * of the UI plugin architecture, see userinterfacewrapper.js.\n *\n * This plugin replaces the usual textarea answer box with a div\n * consisting of pre-formatted text supplied by the question author in either the\n * \"globalextra\" field or the testcode field of the first test case, according\n * to the ui parameter ui_source (default: globalextra).  HTML\n * entry or textarea elements are then inserted at\n * specified points. It is intended primarily for use with coding questions\n * where the answerbox presents the students with code that has smallish bits\n * missing.\n *\n * The locations within the globalextra text at which the input elements are\n * to be inserted are denoted by \"tags\" of the form\n *\n *     {[ size ]}\n *\n * for an HTML input element\n *\n * or\n *\n *     {[ rows, columns ]}\n *\n * for a textarea element\n *\n * where size, rows and column are integer literals. These respectively\n * inject an HTML input element or a textarea element of the\n * specified size.\n *\n * The serialisation of the answer box contents, i.e. the text that\n * copied back into the textarea for submissions\n * as the answer, is simply a list of all the field values (strings), in order.\n *\n * As a special case of the serialisation, if the value list is empty, the\n * serialisation itself is the empty string.\n *\n * The delimiters for the input element insertion tags are by default '{[' and\n * ']}', but can be changed by an optional ui parameter gap_filler_delimiters,\n * which must be a 2-element array of strings. For example:\n *\n *     {\"gap_filler_delimiters\": [\"{{\", \"}}\"]}\n *\n * Note that the double-brace delimiters in that example are the same as those\n * used by Twig, so using them instead of the default would prevent you from\n * ever adding Twig expansion (e.g. for randomisation) to the question.\n *\n * @module qtype_coderunner/ui_gapfiller\n * @copyright  Richard Lobb, 2019, The University of Canterbury\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\ndefine(['jquery'], function($) {\n\n    /**\n     * Constructor for UI. Source html comes from data-globalextra by default,\n     * else from whatever source is specified by the uiParams parameter.\n     * @param {string} textareaId The ID of the html textarea.\n     * @param {int} width The width in pixels of the textarea.\n     * @param {int} height The height in pixels of the textarea.\n     * @param {object} uiParams The UI parameter object.\n     */\n    function GapfillerUi(textareaId, width, height, uiParams) {\n        var html;\n        this.textArea = $(document.getElementById(textareaId));\n        this.readOnly = this.textArea.prop('readonly');\n        this.uiParams = uiParams;\n        this.fail = false;\n        this.htmlDiv = null;\n        this.source = uiParams.ui_source || 'globalextra';\n        if (this.source !== 'globalextra' && this.source !== 'test0') {\n            alert('Invalid source for HTML in ui_gapfiller');\n            this.source = 'globalextra';\n        }\n        if (this.source == 'globalextra') {\n            html = this.textArea.attr('data-globalextra');\n        } else {\n            html = this.textArea.attr('data-test0');\n        }\n        this.html = html.replace('<', '&lt;');\n        this.reload();\n    }\n\n    GapfillerUi.prototype.failed = function() {\n        return this.fail; // Currently always true. See reload function.\n    };\n\n    /**\n     * Copy the serialised version of the HTML UI area to the TextArea.\n     */\n    GapfillerUi.prototype.sync = function() {\n        var\n            serialisation = [],  // A list of field values.\n            empty = true;\n\n        this.getFields().each(function() {\n            var name, value;\n            name = $(this).attr('name');\n            if (name !== 'cr_gapfiller_field') {\n                alert('Unexpected UI element found in answer box');\n            } else {\n                value = $(this).val();\n                serialisation.push(value);\n                if (value !== \"\") {\n                    empty = false;\n                }\n            }\n        });\n        if (empty) {\n            this.textArea.val('');\n        } else {\n            this.textArea.val(JSON.stringify(serialisation));\n        }\n    };\n\n    GapfillerUi.prototype.getElement = function() {\n        return this.htmlDiv;\n    };\n\n    GapfillerUi.prototype.getFields = function() {\n        return $(this.htmlDiv).find('.coderunner-ui-element');\n    };\n\n    /**\n     * Set the value of the jQuery field to the given value.\n     * If the field is a radio button or a checkbox,\n     * the checked attribute is set. Otherwise the field's\n     * val() function is called to set the value.\n     * @param {object} field The JQuery field elemetn whose value is to be set.\n     * @param {string} value The value to be used.\n     */\n    GapfillerUi.prototype.setField = function(field, value) {\n        if (field.attr('type') === 'checkbox' || field.attr('type') === 'radio') {\n            field.prop('checked', field.val() === value);\n        } else {\n            field.val(value);\n        }\n    };\n\n    /**\n     * Process the supplied HTML, HTML-escaping existing HTML\n     * and inserting the input and textarea elements\n     * at the marked locations.\n     */\n    GapfillerUi.prototype.markedUpHtml = function() {\n\n        /**\n         * Prefix any regular expression special chars in s with a backslash.\n         * @param {string} s The string whose special values are to be escaped.\n         * @return {string} The escaped string.\n         */\n        function reEscape(s) {\n            var c, specials = '{[(*+\\\\', result='';\n            for (var i = 0; i < s.length; i++) {\n                c = s[i];\n                for (var j = 0; j < specials.length; j++) {\n                    if (c === specials[j]) {\n                        c = '\\\\' + c;\n                    }\n                }\n                result += c;\n            }\n            return result;\n        }\n\n        var sepLeft = reEscape('{['),\n            sepRight = reEscape(']}'),\n            splitter = new RegExp(sepLeft + ' *((?:\\\\d+)|(?:\\\\d+, *\\\\d+)) *' + sepRight),\n            bits = this.html.split(splitter),\n            result = '<pre>' + bits[0],\n            i;\n\n        for (i = 1; i < bits.length; i += 2) {\n            result += this.markUp(bits[i]);\n            if (i + 1 < bits.length) {\n                result += bits[i + 1];\n            }\n        }\n\n        result = result + '</pre>';\n        return result;\n    };\n\n\n    /**\n     * Return the HTML element to insert given the tag contents, which\n     * should be either a single integer (size of input element) or\n     * two integers separated by a comma (rows and cols of textarea).\n     * @param {string} tagContents The text between the delimiters of a gap specifier.\n     * @return {string} The HTML for an input or textarea element build\n     * according to the given tagContents.\n     */\n    GapfillerUi.prototype.markUp = function(tagContents) {\n        var numbers, result='';\n\n        /**\n         * The function to handle an 'input' tag.\n         * @param {int} size The size of the input element to return.\n         * @return {string} The html for a text area to the given specs.\n         */\n        function input(size) {\n            return '<input name=\"cr_gapfiller_field\" class=\"coderunner-ui-element\" size=\"' + size + '\">';\n        }\n\n        /**\n         * The function to handle a 'textarea' tag.\n         * @param {int} rows The number of rows of text required.\n         * @param {int} cols The number of columns of text required.\n         * @return The HTML for a textarea to the given specs.\n         */\n        function textarea(rows, cols) {\n            return '<textarea name=\"cr_gapfiller_field\" class =\"coderunner-ui-element\" ' +\n                'rows=\"' + rows + '\" ' + 'cols=\"' + cols + '\" style=\"width:auto;\"></textarea>';\n        }\n\n        numbers = tagContents.split(',');\n        if (numbers.length == 1) {\n            result = input(parseInt(numbers[0]));\n        } else {\n            result = textarea(parseInt(numbers[0]), parseInt(numbers[1]));\n        }\n\n        return result;\n    };\n\n    /**\n     * Reload the HTML fields from the given serialisation.\n     * Unlike other plugins, we don't actually fail the load if, for example\n     * the number of fields doesn't match the number of values in the\n     * serialisation. We simply set any excess fields for which data\n     * in unavailable to '???' or discard extra values. This ensures\n     * that at least the unfilled content is presented to the question author\n     * when the number of fields is altered during editing.\n     */\n    GapfillerUi.prototype.reload = function() {\n        var\n            content = $(this.textArea).val(), // JSON-encoded HTML element settings.\n            value,\n            values,\n            i,\n            fields,\n            outerDiv = \"<div style='height:fit-content' class='qtype-coderunner-html-outer-div'>\";\n\n        this.htmlDiv = $(outerDiv + this.markedUpHtml() + \"</div>\");\n        if (content) {\n            try {\n                values = JSON.parse(content);\n                fields = this.getFields();\n                for (i = 0; i < fields.length; i++) {\n                    value = i < values.length ? values[i] : '???';\n                    this.setField($(fields[i]), value);\n                }\n            } catch(e) {\n                /**\n                 * Just ignore errors\n                 */\n            }\n        }\n    };\n\n    GapfillerUi.prototype.resize = function() {}; // Nothing to see here. Move along please.\n\n    GapfillerUi.prototype.hasFocus = function() {\n        var  focused = false;\n        this.getFields().each(function() {\n            if (this === document.activeElement) {\n                focused = true;\n            }\n        });\n        return focused;\n    };\n\n    /**\n     * Destroy the GapFiller UI and serialise the result into the original text area.\n     */\n    GapfillerUi.prototype.destroy = function() {\n        this.sync();\n        $(this.htmlDiv).remove();\n        this.htmlDiv = null;\n    };\n\n    return {\n        Constructor: GapfillerUi\n    };\n});\n"],"names":["define","$","GapfillerUi","textareaId","width","height","uiParams","html","textArea","document","getElementById","readOnly","this","prop","fail","htmlDiv","source","ui_source","alert","attr","replace","reload","prototype","failed","sync","serialisation","empty","getFields","each","value","val","push","JSON","stringify","getElement","find","setField","field","markedUpHtml","reEscape","s","c","result","i","length","j","sepLeft","sepRight","splitter","RegExp","bits","split","markUp","tagContents","numbers","rows","cols","parseInt","values","fields","content","parse","e","resize","hasFocus","focused","activeElement","destroy","remove","Constructor"],"mappings":"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"}