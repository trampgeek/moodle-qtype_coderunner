{"version":3,"file":"outputdisplayarea.min.js","sources":["../src/outputdisplayarea.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more util.details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n/**\n * A module used for running code using the Coderunner webservice (CRWS) and displaying output. Originally\n * developed for use in the Scratchpad UI. It has three modes of operation:\n * - 'text': Just display the output as text, html escaped.\n * - 'json': The recommended way to display programs that use stdin or output images (or both).\n *      - Accepts JSON in the CRWS response output with fields:\n *          - \"returncode\": Error/return code from running program.\n *          - \"stdout\": Stdout text from running program.\n *          - \"stderr\": Error text from running program.\n *          - \"files\": An object containing filenames mapped to base64 encoded images.\n *                     These will be displayed below any stdout text.\n *      - When input from stdin is required the returncode 42 should be returned, raise this\n *        any time the program asks for input. An (html) input will be added after the last stdout received.\n *        When enter is pressed, runCode is called with value of the input added to the stdin string.\n *        This repeats until returncode is no longer 42.\n * - 'html': Display program output as raw html inside the output area.\n *      - This can be used to show images and insert other HTML tags (and beyond).\n *      - Giving an <input> tag the class 'coderunner-run-input' will add an event that\n *        on pressing enter will call the runCode method again with the value of that input field added to stdin.\n *        This method of receiving stdin is harder to use but more flexible than JSON, enter at your own risk.\n *\n * @module qtype_coderunner/outputdisplayarea\n * @copyright  James Napier, 2023, The University of Canterbury\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport ajax from \"core/ajax\";\nimport { get_string } from \"core/str\";\n\nconst INPUT_INTERRUPT = 42;\nconst INPUT_CLASS = \"coderunner-run-input\";\nconst DEFAULT_DISPLAY_COLOUR = \"#eff\";\nconst ERROR_DISPLAY_COLOUR = \"#faa\";\nconst JSON_DISPLAY_PROPS = [\"returncode\", \"stdout\", \"stderr\", \"files\"];\n\n/**\n * Error codes returned by the CodeRunner sandbox web service\n */\nconst UNKNOWN_SERVER_ERROR = 7;\nconst SERVER_OVERLOAD   = 9;\n\n/**\n * RESULT status values from a direct call to a Jobe server\n */\nconst RESULT_RUNTIME_ERROR      = 12;\nconst RESULT_SUCCESS            = 15;\nconst RESULT_SERVER_OVERLOAD    = 21;\n\n\n/**\n * Retrieve a language string from qtype_coderunner.\n * @param {string} stringName of language string to retrieve.\n * @returns {string} a language string from qtype_coderunner.\n */\nconst getLangString = async (stringName) => {\n    const string = await get_string(stringName, \"qtype_coderunner\");\n    return string;\n};\n\n/**\n * Get the specified language string using. If callback is provided then pass\n * the language string into that function, otherwise plug it into the given node.\n * @param {Object} settings The settings\n * @param {string} settings.stringName The language string name to retrieve.\n * @param {Function} settings.callback Callback function, with langString as arg.\n * @param {Element} settings.node text area into which the error message should be plugged.\n * @example\n * // Set a div element's text to be a language string\n * setLangString({stringName: 'nooutput', node: div})\n * @example\n * // Set a div element's text to be a language string with *** on either side\n * setLangString setLangString({stringName: 'error_timeout', callback: (langString) => {\n *      div.innerText += `*** ${langString} ***\\n`;\n * }});\n */\nconst setLangString = async ({ stringName, callback, node }) => {\n    const langString = await getLangString(stringName);\n    if (callback instanceof Function) {\n        callback(langString);\n    } else {\n        node.innerText = langString;\n    }\n};\n\nconst diagnoseWebserviceResponse = (response) => {\n    // Table of error conditions.\n    // Each row is response.error, response.result, langstring\n    // response.result is ignored if response.error is non-zero.\n    // Any condition not in the table is deemed an \"Unknown runtime error\".\n    const ERROR_RESPONSES = [\n        [1, 0, \"error_access_denied\"], // Sandbox AUTH_ERROR\n        [2, 0, \"error_unknown_language\"], // Sandbox WRONG_LANG_ID\n        [3, 0, \"error_access_denied\"], // Sandbox ACCESS_DENIED\n        [4, 0, \"error_submission_limit_reached\"], // Sandbox SUBMISSION_LIMIT_EXCEEDED\n        [5, 0, \"error_sandbox_server_overload\"], // Sandbox SERVER_OVERLOAD\n        [0, 11, \"\"], // RESULT_COMPILATION_ERROR\n        [0, 12, \"\"], // RESULT_RUNTIME_ERROR\n        [0, 13, \"error_timeout\"], // RESULT TIME_LIMIT\n        [0, RESULT_SUCCESS, \"\"], // RESULT_SUCCESS\n        [0, 17, \"error_memory_limit\"], // RESULT_MEMORY_LIMIT\n        [0, 21, \"error_sandbox_server_overload\"], // RESULT_SERVER_OVERLOAD\n        [0, 30, \"error_excessive_output\"], // RESULT OUTPUT_LIMIT\n    ];\n    for (let i = 0; i < ERROR_RESPONSES.length; i++) {\n        let row = ERROR_RESPONSES[i];\n        if (row[0] == response.error && (response.error != 0 || response.result == row[1])) {\n            return row[2];\n        }\n    }\n    return \"error_unknown_runtime\"; // We're dead, Fred.\n};\n\n/**\n * Concatenates the cmpinfo, stdout and stderr fields of the sandbox\n * response, truncating both stdout and stderr to a given maximum length\n * if necessary (in which case '... (truncated)' is appended.\n * @param {object} response Sandbox response object\n */\nconst combinedOutput = (response) => {\n    return response.cmpinfo + response.output + response.stderr;\n};\n\n/**\n * Check whether obj has the properties in props, returns missing properties.\n * @param {object} obj to check properties of\n * @param {array} props to check for.\n * @returns {array} of missing properties.\n */\nconst missingProperties = (obj, props) => {\n    return props.filter((prop) => !obj.hasOwnProperty(prop));\n};\n\n/**\n * Insert a base64 encoded string into HTML image.\n * @param {string} base64 encoded string.\n * @param {string} type of encoded image file.\n * @returns {HTMLImageElement} image tag containing encoded image from string.\n */\nconst getImage = (base64, type = \"png\") => {\n    const image = document.createElement(\"img\");\n    image.src = `data:image/${type};base64,${base64}`;\n    return image;\n};\n\n/**\n * Constructor for OutputDisplayArea object. For use with the output_displayarea template.\n * @param {string} displayAreaId The id of the display area div, this should match the 'id'\n * from the template.\n * @param {string} outputMode The mode being used for output, must be text, html or json.\n * @param {string} lang The language to run code with.\n * @param {string} sandboxParams The sandbox params to run code with.\n */\nclass OutputDisplayArea {\n    constructor(displayAreaId, outputMode, lang, sandboxParams) {\n        this.displayAreaId = displayAreaId;\n        this.lang = lang;\n        this.mode = outputMode;\n        this.sandboxParams = sandboxParams;\n\n        this.textDisplay = document.getElementById(displayAreaId + \"-text\");\n        this.imageDisplay = document.getElementById(displayAreaId + \"-images\");\n\n        this.prevRunSettings = null;\n    }\n\n    /**\n     * Clear the display of any images and text.\n     */\n    clearDisplay() {\n        this.textDisplay.innerHTML = \"\";\n        this.imageDisplay.innerHTML = \"\";\n        this.textDisplay.style.backgroundColor = DEFAULT_DISPLAY_COLOUR;\n        this.imageDisplay.style.backgroundColor = DEFAULT_DISPLAY_COLOUR;\n    }\n\n    /**\n     * Display text from a CRWS response to the display (escaped).\n     * @param {object} response Coderunner webservice response JSON.\n     */\n    displayText(response) {\n        this.textDisplay.innerText = combinedOutput(response);\n    }\n\n    /**\n     * Display HTML from a CRWS response to the display (un-escaped).\n     * Find the first HTML input element with the input class and\n     * add event listeners to handle reading stdin.\n     * @param {object} response Coderunner webservice response JSON,\n     * with output field containing HTML.\n     */\n    displayHtml(response) {\n        this.textDisplay.innerHTML = combinedOutput(response);\n        const inputEl = this.textDisplay.querySelector(\".\" + INPUT_CLASS);\n        if (inputEl) {\n            this.addInputEvents(inputEl);\n        }\n    }\n\n    /**\n     * Display JSON from a CRWS response to the display.\n     * Assumes response.output will be a JSON with the fields:\n     *      - \"returncode\": Error/return code from running program.\n     *      - \"stdout\": Stdout text from running program.\n     *      - \"stderr\": Error text from running program.\n     *      - \"files\": An object containing filenames mapped to base64 encoded images.\n     *                 These will be displayed below any stdout text.\n     * NOTE: See file header/readme for more info.\n     * @param {object} response Coderunner webservice response JSON,\n     * with output field containing JSON string.\n     */\n    displayJson(response) {\n        const result = this.validateJson(response.output);\n        if (result === null) {\n            return;\n        } // Invalid JSON response received from wrapper.\n\n        let text = result.stdout;\n\n        if (result.returncode !== INPUT_INTERRUPT) {\n            text += result.stderr;\n        }\n        if (result.returncode == 13) {\n            // Timeout\n            setLangString({\n                stringName: \"error_timeout\",\n                callback: (langString) => {\n                    this.textDisplay.innerText += `*** ${langString} ***\\n`;\n                },\n            });\n        }\n\n        const numImages = this.displayImages(result.files);\n        if (text.trim() === \"\" && result.returncode !== INPUT_INTERRUPT) {\n            if (numImages == 0) {\n                this.displayNoOutput(null);\n            }\n        } else {\n            this.textDisplay.innerText = text;\n        }\n        if (result.returncode === INPUT_INTERRUPT) {\n            this.addInput();\n        }\n    }\n\n    /**\n     * Display an error message, with red background.\n     * Typically, these would be caused by the wrapper.\n     * But they can also happen when the webservice responds with an error.\n     * @param {string} error_msg to be displayed.\n     */\n    displayError(error_msg) {\n        this.textDisplay.style.backgroundColor = ERROR_DISPLAY_COLOUR;\n        this.textDisplay.innerText = error_msg;\n    }\n\n    /**\n     * Validate JSON to display, make sure it is valid json and has required fields.\n     * Return null if malformed JSON or or required fields are missing.\n     * @param {string} jsonString string of JSON to be displayed.\n     * @returns {object | null} JSON as object, or null if invalid.\n     */\n    validateJson(jsonString) {\n        let result = null;\n        try {\n            result = JSON.parse(jsonString);\n        } catch (e) {\n            setLangString({\n                stringName: \"outputdisplayarea_invalid_json\",\n                callback: (langString) => {\n                    this.displayError(`${langString}\\n` + `${jsonString}\\n` + `${e.message} \\n`);\n                },\n            });\n            return null;\n        }\n        const missing = missingProperties(result, JSON_DISPLAY_PROPS);\n        if (missing.length > 0) {\n            setLangString({\n                stringName: \"outputdisplayarea_missing_json_fields\",\n                callback: (langString) => {\n                    this.displayError(`${langString}\\n` + `${missing.join()}`);\n                },\n            });\n            return null;\n        }\n        return result;\n    }\n\n    /**\n     * Display no output message if no output to display or response is null.\n     * @param {object} response Coderunner webservice response JSON, set to null to force\n     * display of no output message.\n     */\n    displayNoOutput(response) {\n        const isNoOutput = response ? combinedOutput(response).length === 0 : true;\n        if (isNoOutput || response === null) {\n            const span = document.createElement(\"span\");\n            span.style.color = \"red\";\n            setLangString({ stringName: \"nooutput\", node: span });\n            this.clearDisplay();\n            this.textDisplay.append(span);\n        }\n        return isNoOutput;\n    }\n    /**\n     * Display response using the current display mode.\n     * @param {object} response Coderunner webservice response JSON.\n     */\n    display(response) {\n        const error = diagnoseWebserviceResponse(response);\n        if (error !== \"\") {\n            setLangString({\n                stringName: error,\n                callback: (langString) => {\n                    this.textDisplay.innerText = `*** ${langString} ***\\n`;\n                },\n            });\n            return;\n        }\n        if (this.displayNoOutput(response)) {\n            return;\n        }\n\n        if (this.mode === \"json\") {\n            this.displayJson(response);\n        } else if (this.mode === \"html\") {\n            this.displayHtml(response);\n        } else if (this.mode === \"text\") {\n            this.displayText(response);\n        } else {\n            setLangString({\n                stringName: \"outputdisplayarea_invalid_mode\",\n                callback: (langString) => {\n                    this.displayError(langString + \" \" + this.mode);\n                },\n            });\n        }\n    }\n\n    /**\n     * Run code using the Coderunner webservice and then display the output\n     * using the selected mode. This function uses AJAX to asynchronously run and\n     * display code.\n     * @param {string} code to be run.\n     * @param {string} stdin to be fed into the program.\n     * @param {boolean} shouldClearDisplay will reset the display before displaying.\n     * Use false when doing stdin runs.\n     */\n    runCode(code, stdin, shouldClearDisplay = false) {\n        this.prevRunSettings = [code, stdin];\n        if (shouldClearDisplay) {\n            this.clearDisplay();\n        }\n        ajax.call([\n            {\n                methodname: \"qtype_coderunner_run_in_sandbox\",\n                args: {\n                    contextid: M.cfg.contextid, // Moodle context ID\n                    sourcecode: code,\n                    language: this.lang,\n                    stdin: stdin,\n                    params: JSON.stringify(this.sandboxParams), // Sandbox params\n                },\n                done: (responseJson) => {\n                    const response = JSON.parse(responseJson);\n                    this.display(response);\n                },\n                fail: (error) => {\n                    this.displayError(error.message);\n                },\n            },\n        ]);\n    }\n\n    /**\n     * Run code by connecting directly with AJAX to one of the given Jobe\n     * servers, selected randomly.\n     * @param {string} code to be run.\n     * @param {string} stdin to be fed into the program.\n     * @param {list} jobeServers a non-empty list of jobe servers\n     * @param {list} apiKeys a possibly empty list of API keys for the jobe-servers\n     * @param {boolean} shouldClearDisplay will reset the display before displaying.\n     * Use false when doing stdin runs.\n     */\n    runCodeDirect(code, stdin, jobeServers, apiKeys, shouldClearDisplay = false) {\n        this.prevRunSettings = [code, stdin];\n        if (shouldClearDisplay) {\n            this.clearDisplay();\n        }\n        const lang = this.lang.toLowerCase();\n        const runspec = {\n            \"run_spec\": {\n                'language_id': lang,\n                'sourcecode': code,\n                'sourcefilename': lang === 'java' ? this.getJavaFilename(code) : `__tester__.${lang}`,\n                'input': stdin\n            }\n        };\n        const xhr = new XMLHttpRequest();\n        const t = this;\n        xhr.onreadystatechange = function() {\n            if (xhr.readyState == XMLHttpRequest.DONE) {\n                if (xhr.status === 200 || xhr.status === 203) {\n                    const sandboxResponse = t.convertToSandboxFormat(xhr.responseText);\n                    t.display(sandboxResponse);\n                } else {\n                    setLangString({\n                        stringName: 'scratchpad_ui_request_failed',\n                        callback: (langString) => {\n                            t.displayError(langString +  ` ${xhr.status}: ${xhr.statusText}. ${xhr.responseText}`);\n                        }\n                    });\n                }\n            }\n        };\n\n        xhr.onerror = function() {\n            setLangString({\n                stringName: 'scratchpad_ui_error',\n                callback: (langString) => {\n                    t.displayError(langString);\n                }\n            });\n        };\n\n        const index = Math.floor(Math.random() * jobeServers.length);\n        const jobeServer = jobeServers[index].toLowerCase();\n\n        if (!jobeServer.startsWith('http://') && !jobeServer.startsWith('https://')) {\n            setLangString({\n                stringName: 'scratchpad_ui_no_protocol',\n                callback: (langString) => {\n                    t.displayError(langString);\n                }\n            });\n        } else if (apiKeys && jobeServers.length != apiKeys.length) {\n            setLangString({\n                stringName: 'scratchpad_ui_bad_api_keys',\n                callback: (langString) => {\n                    t.displayError(langString);\n                }\n            });\n        } else {\n            xhr.open('POST', `${jobeServer}/jobe/index.php/restapi/runs`, true);\n            xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');\n            xhr.setRequestHeader('Accept', 'application/json');\n            if (apiKeys) {\n                xhr.setRequestHeader('X-API-KEY', apiKeys[index]);\n            }\n            xhr.send(JSON.stringify(runspec));\n        }\n    }\n\n    /**\n     * Try to come up with the right filename for a Java program by using regular\n     * expressions to find the main class. This is by no means guaranteed to work in all cases\n     * but it handles the most common ways of writing a Java program.\n     * @param {string} code The java sourcecode\n     * @return The main class name with '.java' appended.\n     */\n    getJavaFilename(code) {\n        // eslint-disable-next-line max-len\n        let pattern = /(^|\\W)public\\s+class\\s+(\\w+)[^{]*\\{.*?((public\\s([a-z]*\\s)*static)|(static\\s([a-z]*\\s)*public))\\s([a-z]*\\s)*void\\s+main\\s*\\(\\s*String/ms;\n        const matches = code.match(pattern);\n        if (!matches) {\n            return 'NO_PUBLIC_CLASS_FOUND.java';\n        } else {\n            return matches[2] + '.java';\n        }\n    }\n\n    /**\n     * Convert the response from a direct AJAX request to a web server to roughly match the\n     * object returned from a webservice request to the CodeRunner run-in-sandbox service.\n     * @param {string} responseText The JSON-encoded response from Jobe\n     */\n    convertToSandboxFormat(responseText) {\n        let response = '';\n        try {\n            response = JSON.parse(responseText);\n        } catch (e) {\n            return {\n                'error': UNKNOWN_SERVER_ERROR,\n                'stderr': `HTTP response was ${JSON.stringify(responseText)}`\n            };\n        }\n        if (response.outcome === RESULT_SERVER_OVERLOAD) {\n            return {\n                'error': SERVER_OVERLOAD\n            };\n        } else {\n            const stderr = response.stderr.trim();\n            return {\n                'error': 0,\n                'stderr': stderr,\n                'result': stderr ? RESULT_RUNTIME_ERROR : response.outcome,\n                'signal': 0,\n                'cmpinfo': response.cmpinfo,\n                'output': response.stdout\n            };\n        }\n    }\n\n\n    /**\n     * Add an input field with event listeners to support running again\n     * with new stdin entered by user.\n     */\n    addInput() {\n        const inputId = `${this.displayAreaId}-input-field`;\n        this.textDisplay.innerHTML += `<input type=\"text\" id=\"${inputId}\" class=\"${INPUT_CLASS}\">`;\n        const inputEl = document.getElementById(inputId);\n        setLangString({\n            stringName: \"enter_to_submit\",\n            callback: (langString) => {\n                inputEl.placeholder += langString;\n            },\n        });\n\n        this.addInputEvents(inputEl);\n    }\n\n    /**\n     * Add event listeners to inputEl overriding enter key to:\n     *  - Prevent form-submit.\n     *  - Call runCode again, adding value in inputEl to stdin.\n     * @param {HTMLInputElement} inputEl to add event listeners to.\n     */\n    addInputEvents(inputEl) {\n        inputEl.focus();\n\n        inputEl.addEventListener(\"keydown\", (e) => {\n            if (e.key === \"Enter\") {\n                e.preventDefault(); // Do NOT form submit.\n            }\n        });\n        inputEl.addEventListener(\"keyup\", (e) => {\n            if (e.key === \"Enter\") {\n                const line = inputEl.value;\n                inputEl.remove();\n                this.textDisplay.innterHTML += line; // Perhaps this should be sanitized.\n                this.prevRunSettings[1] += line + \"\\n\";\n                this.runCode(...this.prevRunSettings, false);\n            }\n        });\n    }\n\n    /**\n     * Take the files from a JSON response and display them.\n     * @param {object} files from response, in filename: filecontents pairs.\n     * @returns {number} number of images displayed.\n     */\n    displayImages(files) {\n        let numImages = 0;\n        for (const [fname, fcontents] of Object.entries(files)) {\n            const fileType = fname.split(\".\")[1];\n            if (fileType) {\n                const image = getImage(fcontents, fileType);\n                this.imageDisplay.append(image);\n                numImages += 1;\n            } else {\n                setLangString({\n                    stringName: \"outputdisplayarea_missing_image_extension\",\n                    callback: (langString) => {\n                        this.imageDisplay(`${langString} ` + fname);\n                    },\n                });\n            }\n        }\n        return numImages;\n    }\n}\n\nexport { OutputDisplayArea };\n"],"names":["JSON_DISPLAY_PROPS","setLangString","async","stringName","callback","node","langString","getLangString","Function","innerText","combinedOutput","response","cmpinfo","output","stderr","getImage","base64","type","image","document","createElement","src","constructor","displayAreaId","outputMode","lang","sandboxParams","mode","textDisplay","getElementById","imageDisplay","prevRunSettings","clearDisplay","innerHTML","style","backgroundColor","displayText","displayHtml","inputEl","this","querySelector","addInputEvents","displayJson","result","validateJson","text","stdout","returncode","numImages","displayImages","files","trim","displayNoOutput","addInput","displayError","error_msg","jsonString","JSON","parse","e","message","missing","obj","props","filter","prop","hasOwnProperty","missingProperties","length","join","isNoOutput","span","color","append","display","error","ERROR_RESPONSES","i","row","diagnoseWebserviceResponse","runCode","code","stdin","shouldClearDisplay","call","methodname","args","contextid","M","cfg","sourcecode","language","params","stringify","done","responseJson","fail","runCodeDirect","jobeServers","apiKeys","toLowerCase","runspec","getJavaFilename","xhr","XMLHttpRequest","t","onreadystatechange","readyState","DONE","status","sandboxResponse","convertToSandboxFormat","responseText","statusText","onerror","index","Math","floor","random","jobeServer","startsWith","open","setRequestHeader","send","matches","match","outcome","inputId","placeholder","focus","addEventListener","key","preventDefault","line","value","remove","innterHTML","fname","fcontents","Object","entries","fileType","split"],"mappings":"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"}