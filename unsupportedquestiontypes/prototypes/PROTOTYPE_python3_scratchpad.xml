<?xml version="1.0" encoding="UTF-8"?>
<quiz>
<!-- question: 32442  -->
  <question type="coderunner">
    <name>
      <text>PROTOTYPE_python3_scratchpad</text>
    </name>
    <questiontext format="html">
      <text><![CDATA[<p><span style="font-size: 0.9375rem;">Prototype for a COSC131 Python3 question that is checked by either pylint or ruff before being executed. Other local style checks are also implemented.</span></p>
<p>This version uses the Scratchpad UI to include a test panel that the student can use to run tests.</p>
<p>It can take the following template parameters.</p>
<ul>
<li>
<p><strong>abortonerror</strong>: true to abort testing when a runtime error occurs. Default: true</p>
</li>
<li>
<p><strong>allowglobals</strong>: set this to true to allow global variables (i.e. to allow lowercase globals, not just "constants"). Default: false.</p>
</li>
<li>
<p><strong>allownestedfunctions</strong>: set this to true to allow functions to be declared with a non-global scope. Default: false.</p>
</li>
<li>
<p><strong>banglobalcode</strong>: If true, no global assignment (except global constants), for, while or if constructs are allowed. Default: true.</p>
</li>
<li>
<p><strong>banfunctionredefinitions:</strong> If true, names given to custom functions cannot be subsequently used as variables. Default: true.</p>
</li>
<li>
<p><strong>checktemplateparams</strong>: set this false to bypass the usual check for validity of template params (e.g. when doing randomisation, although prefixing the extra template params with '_' is preferred).</p>
</li>
<li><strong style="font-size: 0.9375rem;">dpi</strong><span style="font-size: 0.9375rem;">. The dots-per-inch value to use for any matplotlib images. Default value: 65</span></li>
</ul>
<ul>
<li>
<p><strong>echostandardinput</strong>. If false, the standard builtin Python <em>input</em> function will be used. Otherwise, it will be replaced with a version that echoes the prompt to standard output to mimic the behaviour observed when standard input comes from the keyboard. Default: True</p>
</li>
<li>
<p><strong>extra: </strong>should be a string, one of "", "pretest" or "posttest". If set and not empty, the TEST.extra field is inserted into the program before or after TEST.testcode for the values "pretest" and "posttest" respectively. Default: ""</p>
</li>
<li>
<p><strong>floattolerance</strong>: a floating point number which, if defined and non-None, changes the test for correct output as follows. The <em>expected</em> and <em>got</em> outputs are both right-stripped then broken into lines. If the number of lines don't match, the answer is deemed wrong. Then (after compressing white space to a single character if <em>strictwhitespace</em> is false) the <em>got</em> and <em>expected</em> outputs are compared line for line. Each line is split by a regular expression pattern that matches any floating point number or integer and the two lines are compared token by token. If both tokens are numbers they must be equal to within  <em>floattolerance</em>. The actual test is abs(float(f1) - float(f2) &lt;= floattolerance * 1.0001. The factor of 1.0001 is to allow for floating point error in the case where two decimal numbers that appear to satisfy the criterion, such as 0.65 and 6.5e-01 with a float tolerance of 0.01, actually don't quite due to floating point error in the computation. If <em>floattolerance</em> is 0.0 the effect is to treat ints as floats, e.g.  1 and 1.0 will be deemed equal. Default: None</p>
</li>
<li>
<p><strong>globalextra</strong>: should be a string, one of "", "pretest" or "posttest". If set and not empty, the QUESTION.globalextra field is inserted into the program before or after TEST.testcode for the values "pretest" and "posttest" respectively. If TEST.extra and QUESTION.globalextra are both being inserted before the test or both are being inserted after the test, the globalextra precedes the TEST.extra. Default: ""</p>
</li>
<li>
<p><strong>imagewidth</strong>: if this is given it sets the width in pixels of any matplotlib images inserted into the result table. Height is automatically scaled to match. Otherwise the image is inserted unscaled. Ignored unless <em>usesmatplotlib</em> is true. Default: None.</p>
</li>
<li>
<p><strong>imports</strong>: this is a list of python import strings. Each string is either just a python module name or a full python import string. If just <em>name</em> is given, the import statement is simply "import name", otherwise the import string is used as given. For example:</p>
<pre>{ "imports": ["math", "from blah import thing as twaddle"] }</pre>
<p>Imports go at the very start of the generated program. This mechanism can be used to import test support functions, too, and is preferred over the use of a <tt>_prefix.py</tt> file.</p>
</li>
<li>
<p><strong>isfunction</strong>: unless this is explicitly set to false, or the student's code already begins with a docstring, a dummy module docstring will be inserted at the start of the program<strong>.</strong>  Also, if <em>isfunction</em> is true, the supplied code will be run stand-alone to check if it generates any output and an error message will be generated if it does. Thus, if your question is of the "write a program" variety, you should set this to false. Otherwise omit it. Default: true.</p>
</li>
<li>
<p><strong>localprechecks</strong>: if true, run the local prechecks for things like global code, required/proscribed functions and constructs, unexpected output. If local prechecks give any errors, the precheckers (ruff, pylint, mypy) will not be run. Default: true.</p>
</li>
<li>
<p><strong>maxfunctionlength</strong>: this is the maximum number of statements that a function body can contain. Statements within statements are counted. Blank lines and comments aren't statements.  This is a more-reliable alternative to the pylint <em>max-statements</em> parameter, which behaves strangely at times. </p>
</li>
<li>
<p><strong>maxnumconstants</strong>: the maximum number of constants (i.e. uppercase globals) allowed. An integer, defaulting to 4.</p>
</li>
<li>
<p><strong>maxreturndepth: </strong>the maximum depth of nesting allowed for any return statements. Default: None (meaning "no limit").</p>
</li>
<li>
<p><strong>maxprechecks</strong>: the maximum number of prechecks allowd for this question. Default: None (meaning "no limit").</p>
</li>
<li>
<p><strong>maxoutputbytes</strong>: the maximum allowed number of output bytes. Default 10000.</p>
</li>
<li>
<p><strong>maxstringlength: </strong>the maximum allowed length of the output string or error string in the result table. Strings longer than this have their inner content snipped out. An integer defaulting to 2000.</p>
</li>
<li>
<p><strong>norun</strong>: if set to true, the normal execution of the student's code will not take place. Any test code provided will however still be run.</p>
</li>
<li>
<p><strong>nostylechecks</strong>: true to suppress all normal style checking, including the checkers listed in "precheckers". Default: false</p>
</li>
<li>
<p><strong>notest</strong>: if present and set to true, the test code will not be inserted into the code to be executed. Its role is then just as documentation for the student (as it still appears in the result table).</p>
</li>
<li>
<p><strong>parsonsproblemthreshold: </strong>if a wrong answer is submitted and the number of submissions (Checks) is greater than or equal to this value (parsonsproblemthreshold) the student is presented with a link that, if clicked, will expose the author's answer with all indentation removed and the order scrambled.</p>
</li>
<li>
<p><strong>precheckers</strong>: a list of the names of programs to be run when prechecking the correctness of the code. Currently only "ruff", "pylint" and "mypy" are supported. These prechecks do not run if local checks give an error. Default: ["ruff"].</p>
</li>
<li>
<p><strong>prelude</strong>: a possibly multi-line string that is inserted into the file after any imports and other template-generated code but before the student answer (and before the _prefix.py file, if supplied).</p>
</li>
<li>
<p><strong>proscribedbuiltins</strong>: this is a list of the Python built-in functions that cannot be used. Default: ["exec", "eval"].</p>
</li>
<li>
<p><strong>proscribedconstructs</strong>: this is a list of Python constructs (if, while, def, slice, listcomprehension, etc) that<em> must not</em> appear in the student's program.</p>
</li>
<li>
<p><strong>proscribedfunctions</strong>: this is a list of functions (sum, product, etc) that <em>must not</em> appear in the student's program. Default: []</p>
</li>
<li>
<p><strong>proscribedsubstrings</strong>: this is a list of strings that <em>must not</em> appear anywhere in the student's program (even in comments). Default: []</p>
</li>
<li>
<p><strong>pylintoptions</strong>: a list of strings to be <em>added to </em>the default list of options to pylint (relevant only if pylint is specified as one of the precheckers). For example, the Template parameters string in the question authoring form might be set to</p>
<pre>{"isfunction": false, "pylintoptions":["--max-args=3", "--good-names=i,j,k,n,s,c,_,x,y,z"]}</pre>
<p>to suppress the insertion of a dummy module docstring at the start, to set the maximum number of arguments for each function to 3, and to add the variable names <code>x</code>, <code>y</code> and <code>z</code> to the standard list of allowed 1-character names (<code>"--good-names=i,j,k,n,s,c,_"</code>).</p>
</li>
<li>
<p><strong>requiredconstructs</strong>: this is a list of Python constructs (if, while, def, etc) that<strong> must </strong>appear in the student's program. Default: []</p>
</li>
<li>
<p><strong>requiredfunctiondefinitions</strong>: this is a list of the names of the functions that must be defined within the student's program. Default: []</p>
</li>
<li>
<p><strong>requiredfunctioncalls</strong>: this is a list of the names of functions that must be explicitly called within the student's code</p>
</li>
<li>
<p><strong>requiredsubstrings</strong>: this is either a list of strings that <strong>must</strong> appear somewhere in the students code. Or a list of json objects with the keys "string", "pattern" and "errormessage". Only one of "string" or "pattern" should be supplied. "String" corresponds to a string that must appear in the student's code and "pattern" corresponds to a python regular expression that must match somewhere in the student's code. "errormessage" is the feedback that will be given to students when they fail this on precheck.</p>
</li>
<li>
<p><strong>requiretypehints</strong>: if <em>True</em> all functions must have type hints for all parameters and the return type. Default: False (may not still be working, and/or may need mypy as one of the precheckers).</p>
</li>
<li>
<p><strong>restrictedfiles</strong>: this specifies which files the students program is allowed to open. It is dictionary with two optional keys 'onlyallow' and 'disallow'. Each of these should map to a list of files that are allowed to be opened and filenames that are not allowed to be opened. The filenames in the lists can be a regex.<br>Default:</p>
<pre>{"disallow": ["__.*", "prog.*", "pytester.py"]</pre>
</li>
<li>
<p> <strong>restrictedmodules</strong>: A dictionary that specifies what modules are to be restricted. Keys are the names of modules and the values are a dictionary with two keys 'onlyallow' and 'disallow'. Each of these is a list of the names of objects within the module which are allowed or disallowed. The names of objects in these lists can be a regex.  This is a runtime check only, not part of style checker.</p>
<p>Default:</p>
<pre> "restrictedmodules": {
    "builtins": {"onlyallow": []},
    "imp": {"onlyallow": []},
    "importlib": {"onlyallow": []},
    "os": {"disallow": ["system", "_exit", "_.*"]},
    "subprocess": {"onlyallow": []},
    "sys": {"onlyallow": []},
}</pre>
</li>
<li>
<p><strong>resulttablecolumns: </strong>DEFUNCT - don't use. Use resultcolumns instead.</p>
</li>
<li>
<p><strong>resultcolumns</strong>: a list of [header, field] 2-element lists defining the columns to display in the result table. The first element in each pair is the column header, the second is the field of the CodeRunner test result object to display in that column. Note that columns in which all elements are empty are suppressed regardless. Default: <code>[['Test', 'testcode'],
        ['Input', 'stdin'], ['Expected', 'expected'], ['Got', 'got']]</code></p>
</li>
<li>
<p><strong>ruffoptions</strong>: a list of additional options to modify or override the default settings of the ruff linter as defined in <em>pyproject.toml</em> in the prototype. For example<br>    <code>["--extend-select
      E731,F401", "--ruff-max-branches 15", "--line-length=80",
      "--ignore=F234"]</code>.<br>For ruff settings see https://docs.astral.sh/ruff/settings/. Relevant only if ruff is listed as a prechecker.</p>
</li>
<li>
<p><strong>runextra</strong>: if set (to any value) the Extra Template Data is added to the program as test code <em>before</em> the usual testcode. [Deprecated: use the <em>extra</em> parameter instead.]</p>
</li>
<li>
<p><strong>showfeedbackwhenright</strong>:<strong> </strong>If true, when a student provides a valid solution they are presented with an option to see the question author's solution. Default: false</p>
</li>
<li>
<p><strong>strictwhitespace</strong>: by default when checking correctness trailing blank lines and trailing white space on each line are ignored but otherwise white space must match exactly. If this parameter is set to false, white space within a line may vary, i.e., multiple spaces are treated as 1 space. Default: true</p>
</li>
<li>
<p><strong>stripmain</strong>: if set to true, the program is expected to contain a global invocation of the main function, which is a line starting "main()". That line is deleted from the program. If the line is not present a "Missing call to main" exception is raised.</p>
</li>
<li>
<p><strong>stripmainifpresent</strong>: if set to true and the program contains a global invocation of a main function, which is a line starting "main()", that line is deleted from the program. Otherwise nothing happens (cf stripmain).</p>
</li>
<li>
<p><strong>suppresspassiveoutput</strong>: if set to true, any output generated by the student code even without any CodeRunner tests being run is ignored. This can be used, for example, to ignore output from any test code the student has included <em>and/or</em> to ignore the main output from a "write a program question". Only the output generated by CodeRunner tests will be displayed and marked. Default: false.</p>
</li>
<li>
<p><strong>timeout</strong>: number of seconds allowed for each test case. Default: 5 secs. Be careful to ensure that the total time for all test cases can not exceed <strong>totaltimeout</strong>, particularly if <em>abortonerror</em> is false.</p>
</li>
<li>
<p><strong>totaltimeout</strong>: total number of seconds allowed for the whole run. Must not exceed the maximum allowed by Jobe, which is 50 seconds (and which is the default value for this parameter).</p>
</li>
<li>
<p><strong>useanswerfortests</strong>: if true, a run with the sample answer precedes the run with the student answer and the results from the sample answer are used for correctness testing <em>but only if no expected output is supplied</em>. However, because this takes place at runtime, this doesn't work for "Use as example" tests, for which the expected output must be supplied by the question author.</p>
</li>
<li>
<p><strong>usesmatplotlib: </strong>if true, header text is inserted at the start of the program to switch matlab graph output to use the non-interactive 'Agg' backend, which writes images to disk an .PNGs. After each test, the current state of the pyplot figure is saved to a new file. When all tests have been run and graded, the set of image files is inserted row-by-row into the result table with each figure below any text in the cell. For this to work correctly at least the first test must create a figure. The image is not graded - it is provided only for reference, so usually the test code will need to extract and display attributes of the current figure independently. See also the template parameters <em>useanswerfortests</em>, which results in the expected images being inserted into the table too and <em>imagewidth </em>which sets the width (and hence height by uniform scaling) to a desired number of pixels. Note that if <em>usesmatplotlib</em> is selected and pylint is being used, most of the pylint options relating to imports (ordering, reimporting, positioning etc) are disabled. Also, you may need to increase the timeout value for the question.<br><br>If <em>usesmatplotlib </em>is true, <em>pylint</em> checking is disabled.<br><br>Also, if <em>usesmatplotlib</em> is true, a function  <em>print_plot_info(data_type)</em> is made available for use in the test code or post-test extra. This prints various properties of the current plot for grading purposes. <em>data_type</em> should be one of 'points', 'lines' or 'bars'. There are lots of additional parameters to control the output. See the separate section below for details.<br><br>Default (for usesmatplotlib): false. </p>
</li>
<li>
<p><strong>usesnumpy: </strong>if true, the line <em>import numpy as np</em> is inserted at the start of the program, and the usual check for unused imports is turned off. [Defunct: don't use.]</p>
</li>
<li>
<p><strong>warnifpassiveoutput</strong>: if set to true and <em>isfunction</em> is also true, generate a style error if the student's code seems to produce output even without any CodeRunner tests being executed. This is probably the result of the student pasting test code as well as requested function(s) into their answer. Default: true</p>
</li>
</ul>
<p>Also, if a file named '_prefix.py' appears in the working directory (i.e. has been attached to the question), the code in that file is inserted into the executable program after any imports and other template-generated code but before the student answer. However, the use of an explicit import statement is preferred.</p>
<h4>The <em>print_plot_info</em> function</h4>
<p>In addition to the mandatory positional parameter <em>data_type</em>, which must be one of <code>points</code>, <code>lines</code>, or <code>bars</code>, the function can take a range of keyword parameters, as defined by the following Python dictionary of default values:</p>
<pre>DEFAULT_PARAMS = {
    'x_samples': None,        # A list of x-values at which y values should be interpolated.
    'bar_indices': None,      # A list of the 0-origin bar indices to report on. None for all bars.
    'show_xlim': False,       # True to display the x-axis limits
    'show_ylim': False,       # True to display the y-axis limits
    'show_colour': False,     # True to report line/marker/title colour<br>    'show_titlefont': False,  # True to display title font and size (and colour if show_colour is True)
    'show_xticklabels': False,  # True to display x-tick labels
    'show_yticklabels': False,  # True to display y-tick labels
    'show_xticks': False,     # True to display x-tick numeric values
    'show_yticks': False,     # True to display y-tick numeric values
    'show_barx': True,        # True to print the x-coordinates of all bars
    'show_linelabels': None,  # True to show line labels, default is True if there's a legend else False
    'sort_points': False,     # True to sort data by x then y.
    'first_num_points': 5,    # Number of points to print at the start of the point list.
    'last_num_points': 5,     # Number of points to print at the end of the point list.
    'float_precision': (1, 1),  # Num digits to display after decimal point for x and y values resp
    'max_label_length': 60,   # Use multiline display if tick label string length exceeds this
    'lines_to_print': None,   # If non-None, a list of indices of lines to print (0 is first line).
    'line_info_only': False,  # True to suppress all except the line/bar/points info
}
    </pre>]]></text>
    </questiontext>
    <generalfeedback format="html">
      <text></text>
    </generalfeedback>
    <defaultgrade>1</defaultgrade>
    <penalty>0</penalty>
    <hidden>0</hidden>
    <idnumber></idnumber>
    <coderunnertype>python3_scratchpad</coderunnertype>
    <prototypetype>2</prototypetype>
    <allornothing>1</allornothing>
    <penaltyregime>0</penaltyregime>
    <precheck>0</precheck>
    <hidecheck>0</hidecheck>
    <showsource>0</showsource>
    <answerboxlines>60</answerboxlines>
    <answerboxcolumns>100</answerboxcolumns>
    <answerpreload></answerpreload>
    <globalextra></globalextra>
    <useace>1</useace>
    <resultcolumns></resultcolumns>
    <template><![CDATA[import locale
import json
import os
import re
import html
import random

from pytester import PyTester

STANDARD_PYLINT_OPTIONS = ['--disable=trailing-whitespace,superfluous-parens,' + 
                      'too-few-public-methods,consider-using-f-string,useless-return,' + 
                      'unbalanced-tuple-unpacking,too-many-statements,' + 
                      'consider-using-enumerate,simplifiable-if-statement,' + 
                      'consider-iterating-dictionary,trailing-newlines,no-else-return,' + 
                      'consider-using-dict-comprehension,consider-using-generator,' + 
                      'len-as-condition,inconsistent-return-statements,consider-using-join,' + 
                      'singleton-comparison,unused-variable,chained-comparison,no-else-break,' + 
	                  'consider-using-in,useless-object-inheritance,unnecessary-pass,' + 
	                  'reimported,wrong-import-order,wrong-import-position,ungrouped-imports,' + 
                      'consider-using-set-comprehension,no-else-raise,unnecessary-lambda-assignment,' + 
                      'unspecified-encoding,use-dict-literal,consider-using-with,consider-using-min-builtin,' + 
                      'duplicate-string-formatting-argument,consider-using-dict-items,' + 
                      'consider-using-max-builtin,use-a-generator,unidiomatic-typecheck', 
                      '--good-names=i,j,k,n,s,c,_' 
                      ] 


locale.setlocale(locale.LC_ALL, 'C.UTF-8')

KNOWN_PARAMS = {
    'abortonerror': True,
    'allowglobals': False,
    'allownestedfunctions': False,
    'banfunctionredefinitions': True,
    'banglobalcode': True,
    'checktemplateparams': True,
    'dpi': 65,
    'echostandardinput': True,
    'extra': 'None',
    'failhiddenonlyfract': 0,
    'floattolerance': None,
    'forcepylint': False,
    'globalextra': 'None',
    'imagewidth': None,
    'imports': [],
    'isfunction': True,
    'localprechecks': True,
    'maxfunctionlength': 30,
    'maxreturndepth': None,
    'maxprechecks': None,
    'maxnumconstants': 4,
    'maxoutputbytes': 10000,
    'maxstringlength': 2000,
    'norun': False,
    'nostylechecks': False,
    'notest': False,
    'parsonsproblemthreshold': None, # The number of checks before parsons' problem displayed
    'precheckers': ['ruff'],
    'prelude': '',
    'proscribedbuiltins': ['exec', 'eval'],
    'proscribedfunctions': [],
    'proscribedconstructs': ["goto", "while_with_else"],
    'proscribedsubstrings': [],
    'protectedfiles': [],
    'pylintoptions': [],
    'pylintmatplotlib': False,
    'requiredconstructs': [],
    'requiredfunctiondefinitions': [],
    'requiredfunctioncalls': [],
    'requiredsubstrings': [],
    'requiretypehints': False,
    'restrictedfiles': {
        'disallow': ['__.*', 'prog.*', 'pytester.py'],
    },
    'restrictedmodules': {
        'builtins': {
            'onlyallow': []
        },
        'imp': {
            'onlyallow': []  
        },
        'importlib': {
            'onlyallow': []  
        },
        'fileinput': {
            'onlyallow': []  
        },
        'os': {
            'disallow': ['system', '_exit', '_.*', 'open', 'fdopen', 'listdir']
        },
        'subprocess': {
            'onlyallow': []
        },
        'sys': {
            'disallow': ['_.*']
        },
    },
    'resultcolumns': [], # If not specified, use question's resultcolumns value. See below.
    'ruffoptions': [],
    'runextra': False,
    'showfeedbackwhenright': False,
    'stdinfromextra': False,
    'strictwhitespace': True,
    'stripmain': False,
    'stripmainifpresent': False,
    'testisbash': False,
    'timeout': 5,
    'totaltimeout': 50,
    'suppresspassiveoutput': False,
    'useanswerfortests': False,
    'usesmatplotlib': False,
    'usesnumpy': False,
    'usesubprocess': False,
    'warnifpassiveoutput': True,
}

class TestCase:
    def __init__(self, dict_rep):
        """Construct a testcase from a dictionary representation obtained via JSON"""
        self.testcode = dict_rep['testcode']
        self.stdin = dict_rep['stdin']
        self.expected = dict_rep['expected']
        self.extra = dict_rep['extra']
        self.display = dict_rep['display']
        try:
            self.testtype = int(dict_rep['testtype'])
        except:
            self.testtype = 0
        self.hiderestiffail = bool(int(dict_rep['hiderestiffail']))
        self.useasexample = bool(int(dict_rep['useasexample']))
        self.mark = float(dict_rep['mark'])


# ================= CODE TO DO ALL TWIG PARAMETER PROCESSING ===================

def process_template_params():
    """Extract the template params into a global dictionary PARAMS"""
    global PARAMS
    PARAMS = json.loads("""{{ QUESTION.parameters | json_encode | e('py') }}""")
    checktemplateparams = PARAMS.get('checktemplateparams', True)
    if checktemplateparams:
        unknown_params = set(PARAMS.keys()) - set(KNOWN_PARAMS.keys())
        filtered_params = [param for param in unknown_params if not param.startswith('_')]
        if filtered_params:
            print("Unexpected template parameter(s):", list(sorted(filtered_params)))

    for param_name, default in KNOWN_PARAMS.items():
        if param_name in PARAMS:
            param = PARAMS[param_name]
            if type(param) != type(default) and default is not None:
                print("Template parameter {} has wrong type (expected {})".format(param_name, type(default)))
        else:
            PARAMS[param_name] = default;

    if PARAMS['extra'] == 'stdin':
        PARAMS['stdinfromextra'] = True
    if PARAMS['runextra']:
        PARAMS['extra'] = 'pretest'  # Legacy support
    if PARAMS['timeout'] < 2:
        PARAMS['timeout'] = 2  # Allow 1 extra second freeboard 
    PARAMS['pylintoptions'] = STANDARD_PYLINT_OPTIONS + PARAMS['pylintoptions']
    if PARAMS['allowglobals']:
        PARAMS['pylintoptions'].append("--const-rgx='[a-zA-Z_][a-zA-Z0-9_]{2,30}$'")
    if PARAMS['usesmatplotlib']:
        if PARAMS['pylintmatplotlib']:
            PARAMS['pylintoptions'].append("--disable=reimported,wrong-import-position,wrong-import-order,unused-import")
        else:
            PARAMS['precheckers'] = []
    if PARAMS['testisbash']:
        print("testisbash is not implemented for Python")
        
    # We use the template parameter for resultcolumns if non-empty.
    # Otherwise use the value from the question, or an equivalent default if that's empty too.
    q_result_columns = """{{QUESTION.resultcolumns}}""".strip();
    if PARAMS['resultcolumns'] == []:
        if q_result_columns:
            PARAMS['resultcolumns'] = json.loads(q_result_columns);
        else:
            PARAMS['resultcolumns'] = [['Test', 'testcode'], ['Input', 'stdin'], ['Expected', 'expected'], ['Got', 'got']]


def get_test_cases():
    """Return an array of Test objects from the template parameter TESTCASES"""
    test_cases = [TestCase(test) for test in json.loads("""{{ TESTCASES | json_encode | e('py') }}""")]
    return test_cases


def scrambled(answer):
    """Return a randomly reordered version of the given answer"""
    if answer.strip() == '':
        return ''
    docstrings = re.findall(r'""".*?"""', answer) + re.findall(r"'''.*?'''", answer)
    rest = re.sub(r'""".*?"""', '', answer)
    rest2 = re.sub(r"'''.*?'''", '', rest)
    lines = [line.strip() for line in (rest2.splitlines() + docstrings) if line.strip()]
    original = lines[:]
    while len(lines) > 1 and original == lines: # Make sure the order changes!
        random.shuffle(lines)
    return '\n'.join(lines)
    
def get_answer():
    """Return the sample answer"""
    answer_json = """{{QUESTION.answer | e('py')}}""".strip()
    try:
        answer = json.loads(answer_json)['answer_code'][0]
    except:
        answer = answer_json  # Assume this is the original solution
    return answer
    
def process_global_params():
    """Plug into the PARAMS variable all the "global" parameters from
       the question and its answer (as distinct from the template parameters).
    """
    PARAMS['STUDENT_ANSWER'] = """{{ STUDENT_ANSWER | e('py') }}""".rstrip() + '\n'
    PARAMS['SEPARATOR'] = "#<ab@17943918#@>#"
    PARAMS['IS_PRECHECK'] = "{{ IS_PRECHECK }}" == "1"
    PARAMS['QUESTION_PRECHECK'] = {{ QUESTION.precheck }} # Type of precheck: 0 = None, 1 = Empty etc
    PARAMS['ALL_OR_NOTHING'] = "{{ QUESTION.allornothing }}" == "1" # Whether or not all-or-nothing grading is being used
    PARAMS['GLOBAL_EXTRA'] = """{{ QUESTION.globalextra | e('py') }}\n"""
    PARAMS['STEP_INFO'] = json.loads("""{{ QUESTION.stepinfo | json_encode }}""")
    answer = get_answer()
    if answer:
        if PARAMS['STUDENT_ANSWER'].strip() == answer.strip():
            PARAMS['AUTHOR_ANSWER'] = "<p>Your answer is an <i>exact</i> match with the author's solution.</p>"
        else:
            with open("__author_solution.html") as file:
                PARAMS['AUTHOR_ANSWER'] = (file.read().strip() % html.escape(answer))
        with open("__author_solution_scrambled.html") as file:
            PARAMS['AUTHOR_ANSWER_SCRAMBLED'] = (file.read().strip() % html.escape(scrambled(answer))) + "\n"
    else:
        PARAMS['AUTHOR_ANSWER'] = PARAMS['AUTHOR_ANSWER_SCRAMBLED'] = ''


def update_test_cases(test_cases, outcome):
    """Return the updated testcases after replacing all empty expected fields with those from the
       given outcome's test_results which must have a column header 'Got'. Non-empty existing expected
       fields are left unchanged.
       If any errors occur, the return value will be None and the outcome parameter will have had its prologuehtml
       value updated to include an error message.
    """
    try:
        results = outcome['testresults']
        col_num = results[0].index('Got')
        for i in range(len(test_cases)):
            if test_cases[i].expected.strip() == '':
                test_cases[i].expected = results[i + 1][col_num]
    except ValueError:
        outcome['prologuehtml'] = "No 'Got' column in result table from which to get testcase expecteds"
        test_cases = None
    except Exception as e:
        outcome['prologuehtml'] = "Unexpected error ({}) extracting testcase expecteds from sample answer output".format(e)
        test_cases = None
    return test_cases


def get_expecteds_from_answer(params, test_cases):
    """Run all tests using the sample answer rather than the student answer.
       Fill in the expected field of each test case using the sample answer and return
       the updated test case list.
       Return None if the sample answer gave any sort of runtime error
    """
    new_params = {key: value for key, value in params.items()}
    new_params['IS_PRECHECK'] = False
    new_params['nostylechecks'] = True
    new_params['STUDENT_ANSWER'] = get_answer()
    new_params['resultcolumns'] = [['Test', 'testcode'], ['Got', 'got']]  # Ensure we have a Got column.
    new_params['running_sample_answer'] = True
    tester = PyTester(new_params, test_cases)
    outcome = tester.test_code()
    if 'prologuehtml' in outcome:
        outcome['prologuehtml'] = "<h2>ERROR IN QUESTION'S SAMPLE ANSWER. PLEASE REPORT</h2>\n" + outcome['prologuehtml']
        return outcome, None
    else:
        return outcome, update_test_cases(test_cases, outcome)


process_template_params()
test_cases = get_test_cases()
process_global_params()

if PARAMS['useanswerfortests']:
    outcome, test_cases = get_expecteds_from_answer(PARAMS, test_cases)

if test_cases:
    tester = PyTester(PARAMS, test_cases)
    outcome = tester.test_code()
    feedback = ''
    parsons_threshold = float('inf') if PARAMS['parsonsproblemthreshold'] is None else PARAMS['parsonsproblemthreshold']
    if outcome['fraction'] != 1 and not PARAMS['IS_PRECHECK'] and PARAMS['STEP_INFO']['numchecks'] + 1 >= parsons_threshold:
        feedback = PARAMS['AUTHOR_ANSWER_SCRAMBLED']
    elif outcome['fraction'] == 1 and PARAMS['showfeedbackwhenright'] and not (PARAMS['IS_PRECHECK']):
        outcome['prologuehtml'] = '<pre class="ace-highlight-code" style="display:none"></pre>'  # Kick filter into life
        feedback = PARAMS['AUTHOR_ANSWER']
    if feedback:
        if 'epiloguehtml' in outcome:
            if outcome['epiloguehtml'].strip():
                outcome['epiloguehtml'] += '<br>'
        else:
            outcome['epiloguehtml'] = ''
        outcome['epiloguehtml'] += f'<div style="background-color: #f4f4f4">{feedback}</div>'
print(json.dumps(outcome))
]]></template>
    <iscombinatortemplate>1</iscombinatortemplate>
    <allowmultiplestdins>1</allowmultiplestdins>
    <answer></answer>
    <validateonsave>0</validateonsave>
    <testsplitterre><![CDATA[|#<ab@17943918#@>#\n|ms]]></testsplitterre>
    <language>python3</language>
    <acelang></acelang>
    <sandbox>jobesandbox</sandbox>
    <grader>TemplateGrader</grader>
    <cputimelimitsecs>50</cputimelimitsecs>
    <memlimitmb>1500</memlimitmb>
    <sandboxparams></sandboxparams>
    <templateparams></templateparams>
    <hoisttemplateparams>1</hoisttemplateparams>
    <extractcodefromjson>1</extractcodefromjson>
    <templateparamslang>None</templateparamslang>
    <templateparamsevalpertry>0</templateparamsevalpertry>
    <templateparamsevald>{}</templateparamsevald>
    <twigall>0</twigall>
    <uiplugin>scratchpad</uiplugin>
    <uiparameters><![CDATA[{
    "wrapper_src": "prototypeextra",
    "output_display_mode": "json",
    "escape": true
}]]></uiparameters>
    <attachments>0</attachments>
    <attachmentsrequired>0</attachmentsrequired>
    <maxfilesize>10240</maxfilesize>
    <filenamesregex></filenamesregex>
    <filenamesexplain></filenamesexplain>
    <displayfeedback>1</displayfeedback>
    <giveupallowed>0</giveupallowed>
    <prototypeextra><![CDATA[import ast, traceback, sys, io, subprocess, base64, os, ast, traceback, json, re
MAX_OUTPUT_CHARS = 30000
RUN_ERROR_PATTERNS = [
    (r'(.*<fstring>.* \(syntax-error\).*)', []),
    (r'(.*File ".*", line +)(\d+)(, in .*)', [2]),
    (r'(.*: *)(\d+)(, *\d+:.*\(.*line +)(\d+)(\).*)', [2, 4]),
    (r'(.*: *)(\d+)(, *\d+:.*\(.*\).*)', [2]),
    (r'(.*:)(\d+)(:\d+: [A-Z]\d+: .*line )(\d+)(.*)', [2, 4]),
    (r'(.*:)(\d+)(:\d+: [A-Z]\d+: .*)', [2]),
]
SYNTAX_ERROR_PATTERNS = [
    (r'(.*File "<unknown>", line +)(\d+)', [2]),
]

answer_code = """{| ANSWER_CODE |}"""
answer_code_len = len(answer_code.splitlines())
if answer_code_len > 0 and answer_code[-1] != '\n':
    answer_code += '\n'
scratchpad_code = """{| SCRATCHPAD_CODE |}"""
student_code = answer_code + scratchpad_code

uses_matplotlib = 'matplotlib' in student_code

subproc_code = """
import sys
MAX_OUTPUT_CHARS = 30000
__saved_input__ = input

def input(prompt=''):
    try:
        line = __saved_input__()
    except EOFError:
        print(prompt, end = '')
        sys.stderr.flush()
        sys.stdout.flush()
        sys.exit(42)
    print(prompt, end='')
    print(line)
    return line

input.__doc__ = __saved_input__.__doc__

__saved_print__ = print
__output_chars__ = 0

def print(*params, **keyparams):
    global __output_chars__
    for param in params:
        try:
            __output_chars__ += len(str(param))
        except:
            pass
    if __output_chars__ > 2 * MAX_OUTPUT_CHARS:
        __saved_print__("\\\\n*** Excessive output. Job aborted ***", file=sys.stderr)
        sys.exit(1)
    else:
        __saved_print__(*params, **keyparams)

print.__doc__ = __saved_print__.__doc__
"""


if uses_matplotlib:
    subproc_code += """
import os, tempfile, sys
os.environ["MPLCONFIGDIR"] = tempfile.mkdtemp()
import matplotlib as _mpl
_mpl.use("Agg")
"""

subproc_code += student_code

if uses_matplotlib:
    subproc_code += """
figs = _mpl.pyplot.get_fignums()
for i, fig in enumerate(figs):
    _mpl.pyplot.figure(fig)
    filename = f'image{i}.png'
    _mpl.pyplot.savefig(filename, bbox_inches='tight')
"""

def b64encode(filename):
    """Return the contents of the given file in base64"""
    with open(filename, "br") as fin:
        contents = fin.read()
    contents_b64 = base64.b64encode(contents).decode("utf8")
    return contents_b64

def truncated(s):
    return s if len(s) < MAX_OUTPUT_CHARS else s[:MAX_OUTPUT_CHARS] + ' ... (truncated)'

def check_syntax():
    try:
        ast.parse(student_code)
        return ''
    except SyntaxError:
        catcher = io.StringIO()
        traceback.print_exc(limit=0, file=catcher)
        return catcher.getvalue()
    
def fix_errors(stderr, code, error_patterns):
    """Try to fix line numbers of any error messages. Return fixed stderr."""
    try:
        offset = code.index(student_code)
        line_offset = len(code[:offset].splitlines())
    except:
        return stderr

    output_lines = []
    for line in stderr.splitlines():
        for pattern, line_group_nums in error_patterns:
            match = re.match(pattern, line)
            if match:
                line = ''
                for i, group in enumerate(match.groups(), 1):
                    if i in line_group_nums:
                        linenum = int(match.group(i))
                        adjusted = linenum - line_offset
                        str_adjusted = str(adjusted)
                        if answer_code_len > 0 and adjusted > answer_code_len:
                            str_adjusted += f" (line {adjusted - answer_code_len} in scratchpad)"
                        line += str_adjusted
                    else:
                        line += group
                break

        output_lines.append(line)
    return '\n'.join(output_lines)

stdout = ''
stderr = check_syntax()
if stderr == '':  # No syntax errors
    program_code = subproc_code
    with open('prog.py', 'w') as outfile:
        outfile.write(program_code)
    proc = subprocess.Popen([sys.executable, 'prog.py'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    try:
        stdout, stderr = proc.communicate(timeout=3)
        returncode = proc.returncode
    except subprocess.TimeoutExpired:
        proc.kill()
        stdout, stderr = proc.communicate()
        returncode = 13

    stderr = fix_errors(stderr, program_code, RUN_ERROR_PATTERNS)

else:
    stderr = fix_errors(stderr, student_code, SYNTAX_ERROR_PATTERNS)
    returncode = 1 # Syntax errors

# Pick up any .png or .jpg image files.
image_extensions = ['png', 'jpg', 'jpeg']
image_files = [fname for fname in os.listdir() if fname.lower().split('.')[-1] in image_extensions]
files = {fname: b64encode(fname) for fname in image_files}

output = {
    'returncode': returncode,
    'stdout' : truncated(stdout),
    'stderr' : truncated(stderr),
    'files'  : files
}

print(json.dumps(output))
]]></prototypeextra>
    <testcases>
<file name="__author_solution.html" path="/" encoding="base64">PGRpdiBjbGFzcz0iY29kZXJ1bm5lci10ZXN0LXJlc3VsdHMgZ29vZCI+CiAgICA8YSBjbGFzcz0iYnRuIGJ0bi1saW5rIGNvZGVydW5uZXItc29sdXRpb24tbGluayIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6I0NGQyI+U2hvdyBhdXRob3IncyBzb2x1dGlvbjwvYT4KPC9kaXY+CjxkaXYgY2xhc3M9ImNvZGVydW5uZXItYXV0aG9ycy1zb2x1dGlvbiBjb2xsYXBzZSIgZXhwYW5kZWQ9ImZhbHNlIiBzdHlsZT0ibWFyZ2luLWJvdHRvbTo4cHgiPgogICAgPHByZSBjbGFzcz0iY29kZS1oaWdobGlnaHQiPiVzPC9wcmU+CjwvZGl2Pgo8c2NyaXB0PgogICAgd2luZG93LmNvZGVydW5uZXJfc29sdXRpb25fbGlua19jbGlja2VkID0gd2luZG93LmNvZGVydW5uZXJfc29sdXRpb25fbGlua19jbGlja2VkIHx8IGZ1bmN0aW9uKHNyYykgewogICAgICAgIHZhciBxdWVzdGlvbiA9IHNyYy50YXJnZXQuY2xvc2VzdCgnZGl2LnNwZWNpZmljZmVlZGJhY2snKTsKICAgICAgICB2YXIgc29sdXRpb25fZGl2ID0gcXVlc3Rpb24uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY29kZXJ1bm5lci1hdXRob3JzLXNvbHV0aW9uJylbMF07CiAgICAgICAgdmFyIHNvbHV0aW9uX2xpbmsgPSBxdWVzdGlvbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb2RlcnVubmVyLXNvbHV0aW9uLWxpbmsnKVswXTsKICAgICAgICB2YXIgY29kZSA9IHF1ZXN0aW9uLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NvZGUtaGlnaGxpZ2h0JylbMF07CgogICAgICAgIGlmICghY29kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2hhcy1oaWdobGlnaHQnKSkgewogICAgICAgICAgICB2YXIgaGlnaGxpZ2h0ID0gd2luZG93LmFjZS5yZXF1aXJlKCJhY2UvZXh0L3N0YXRpY19oaWdobGlnaHQiKTsKICAgICAgICAgICAgaGlnaGxpZ2h0KGNvZGUsIHsKICAgICAgICAgICAgICAgIG1vZGU6ICJhY2UvbW9kZS9weXRob24iLAogICAgICAgICAgICAgICAgc2hvd0d1dHRlcjogZmFsc2UKICAgICAgICAgICAgfSwgZnVuY3Rpb24oaGlnaGxpZ2h0ZWQpIHsKICAgICAgICAgICAgICAgIGNvZGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYWNlX3N0YXRpY19oaWdobGlnaHQnKVswXS5zdHlsZVsnZm9udC1zaXplJ10gPSAiMTRweCI7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBjb2RlLmNsYXNzTGlzdC5hZGQoJ2hhcy1oaWdobGlnaHQnKTsKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgaWYgKCFzb2x1dGlvbl9kaXYuY2xhc3NMaXN0LmNvbnRhaW5zKCdjb2xsYXBzaW5nJykpIHsKICAgICAgICAgICAgaWYgKHNvbHV0aW9uX2Rpdi5nZXRBdHRyaWJ1dGUoImV4cGFuZGVkIikgPT09ICJ0cnVlIikgewogICAgICAgICAgICAgICAgc29sdXRpb25fbGluay5pbm5lckhUTUwgPSAiU2hvdyBhdXRob3IncyBzb2x1dGlvbiI7CiAgICAgICAgICAgICAgICBzb2x1dGlvbl9kaXYuc3R5bGUuZGlzcGxheSA9ICJub25lIjsKICAgICAgICAgICAgICAgIHNvbHV0aW9uX2Rpdi5zZXRBdHRyaWJ1dGUoImV4cGFuZGVkIiwgImZhbHNlIik7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBzb2x1dGlvbl9saW5rLmlubmVySFRNTCA9ICJIaWRlIGF1dGhvcidzIHNvbHV0aW9uIjsKICAgICAgICAgICAgICAgIHNvbHV0aW9uX2Rpdi5zdHlsZS5kaXNwbGF5ID0gImJsb2NrIjsKICAgICAgICAgICAgICAgIHNvbHV0aW9uX2Rpdi5zZXRBdHRyaWJ1dGUoImV4cGFuZGVkIiwgInRydWUiKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0KICAgIHZhciBjb2RlcnVubmVyX2FsbF9saW5rcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NvZGVydW5uZXItc29sdXRpb24tbGluaycpOwogCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVydW5uZXJfYWxsX2xpbmtzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdmFyIGVsID0gY29kZXJ1bm5lcl9hbGxfbGlua3NbaV07CiAgICAgICAgaWYgKCFlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2hhcy1jbGljay1oYW5kbGVyJykpIHsKICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB3aW5kb3cuY29kZXJ1bm5lcl9zb2x1dGlvbl9saW5rX2NsaWNrZWQpOwogICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdoYXMtY2xpY2staGFuZGxlcicpOwogICAgICAgIH0KICAgIH0gICAgCjwvc2NyaXB0PgoK</file>
<file name="__author_solution_scrambled.html" path="/" encoding="base64">PGRpdiBjbGFzcz0iY29kZXJ1bm5lci10ZXN0LXJlc3VsdHMgYmFkIj4KICAgIDxhIGNsYXNzPSJidG4gYnRuLWxpbmsgY29kZXJ1bm5lci1zY3JhbWJsZWQtc29sdXRpb24tbGluayIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6I0ZDQyI+U2hvdyBzY3JhbWJsZWQgYXV0aG9yJ3Mgc29sdXRpb248L2E+CjwvZGl2Pgo8ZGl2IGNsYXNzPSJjb2RlcnVubmVyLXNjcmFtYmxlZC1hdXRob3JzLXNvbHV0aW9uIGNvbGxhcHNlIiBleHBhbmRlZD0iZmFsc2UiIHN0eWxlPSJtYXJnaW4tYm90dG9tOjhweCI+CiAgICA8cHJlIGNsYXNzPSJjb2RlLWhpZ2hsaWdodCI+JXM8L3ByZT4KPC9kaXY+CjxzY3JpcHQ+CiAgICB3aW5kb3cuY29kZXJ1bm5lcl9zb2x1dGlvbl9saW5rX2NsaWNrZWQgPSB3aW5kb3cuY29kZXJ1bm5lcl9zb2x1dGlvbl9saW5rX2NsaWNrZWQgfHwgZnVuY3Rpb24oc3JjKSB7CiAgICAgICAgdmFyIHF1ZXN0aW9uID0gc3JjLnRhcmdldC5jbG9zZXN0KCdkaXYuc3BlY2lmaWNmZWVkYmFjaycpOwogICAgICAgIHZhciBzb2x1dGlvbl9kaXYgPSBxdWVzdGlvbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb2RlcnVubmVyLXNjcmFtYmxlZC1hdXRob3JzLXNvbHV0aW9uJylbMF07CiAgICAgICAgdmFyIHNvbHV0aW9uX2xpbmsgPSBxdWVzdGlvbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb2RlcnVubmVyLXNjcmFtYmxlZC1zb2x1dGlvbi1saW5rJylbMF07CiAgICAgICAgdmFyIGNvZGUgPSBxdWVzdGlvbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb2RlLWhpZ2hsaWdodCcpWzBdOwoKICAgICAgICBpZiAoIWNvZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdoYXMtaGlnaGxpZ2h0JykpIHsKICAgICAgICAgICAgdmFyIGhpZ2hsaWdodCA9IHdpbmRvdy5hY2UucmVxdWlyZSgiYWNlL2V4dC9zdGF0aWNfaGlnaGxpZ2h0Iik7CiAgICAgICAgICAgIGhpZ2hsaWdodChjb2RlLCB7CiAgICAgICAgICAgICAgICBtb2RlOiAiYWNlL21vZGUvcHl0aG9uIiwKICAgICAgICAgICAgICAgIHNob3dHdXR0ZXI6IGZhbHNlCiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGhpZ2hsaWdodGVkKSB7CiAgICAgICAgICAgICAgICBjb2RlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2FjZV9zdGF0aWNfaGlnaGxpZ2h0JylbMF0uc3R5bGVbJ2ZvbnQtc2l6ZSddID0gIjE0cHgiOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgY29kZS5jbGFzc0xpc3QuYWRkKCdoYXMtaGlnaGxpZ2h0Jyk7CiAgICAgICAgfQogICAgICAgIAogICAgICAgIGlmICghJChzb2x1dGlvbl9kaXYpLmhhc0NsYXNzKCdjb2xsYXBzaW5nJykpIHsKICAgICAgICAgICAgaWYgKCQoc29sdXRpb25fZGl2KS5hdHRyKCJleHBhbmRlZCIpID09PSAidHJ1ZSIpIHsKICAgICAgICAgICAgICAgIHNvbHV0aW9uX2xpbmsuaW5uZXJIVE1MID0gIlNob3cgc2NyYW1ibGVkIGF1dGhvcidzIHNvbHV0aW9uIjsKICAgICAgICAgICAgICAgICQoc29sdXRpb25fZGl2KS5jb2xsYXBzZSgnaGlkZScpOwogICAgICAgICAgICAgICAgJChzb2x1dGlvbl9kaXYpLmF0dHIoImV4cGFuZGVkIiwgImZhbHNlIik7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBzb2x1dGlvbl9saW5rLmlubmVySFRNTCA9ICJIaWRlIHNjcmFtYmxlZCBhdXRob3IncyBzb2x1dGlvbiI7CiAgICAgICAgICAgICAgICAkKHNvbHV0aW9uX2RpdikuY29sbGFwc2UoJ3Nob3cnKTsKICAgICAgICAgICAgICAgICQoc29sdXRpb25fZGl2KS5hdHRyKCJleHBhbmRlZCIsICJ0cnVlIik7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9CiAgICB2YXIgY29kZXJ1bm5lcl9hbGxfbGlua3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb2RlcnVubmVyLXNjcmFtYmxlZC1zb2x1dGlvbi1saW5rJyk7CiAKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZXJ1bm5lcl9hbGxfbGlua3MubGVuZ3RoOyBpKyspIHsKICAgICAgICB2YXIgZWwgPSBjb2RlcnVubmVyX2FsbF9saW5rc1tpXTsKICAgICAgICBpZiAoIWVsLmNsYXNzTGlzdC5jb250YWlucygnaGFzLWNsaWNrLWhhbmRsZXInKSkgewogICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHdpbmRvdy5jb2RlcnVubmVyX3NvbHV0aW9uX2xpbmtfY2xpY2tlZCk7CiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2hhcy1jbGljay1oYW5kbGVyJyk7CiAgICAgICAgfQogICAgfSAgICAKPC9zY3JpcHQ+Cgo=</file>
<file name="__languagetask.py" path="/" encoding="base64">IiIiVGhlIGdlbmVyaWMgTGFuZ3VhZ2VUYXNrLCBzdWJjbGFzc2VzIG9mIHdoaWNoIG1hbmFnZSBjb21waWxpbmcgYW5kIGV4ZWN1dGluZwogICBjb2RlIGluIGEgcGFydGljdWxhciBsYW5ndWFnZS4KIiIiCmZyb20gZGF0ZXRpbWUgaW1wb3J0IGRhdGV0aW1lCgpXQVRDSERPR19GUkVFQk9BUkQgPSAxCgpjbGFzcyBDb21waWxlRXJyb3IoRXhjZXB0aW9uKToKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBlcnJvcl9tZXNzYWdlKToKICAgICAgICBFeGNlcHRpb24uX19pbml0X18oc2VsZiwgZXJyb3JfbWVzc2FnZSkKCgpjbGFzcyBSdW5FcnJvcihFeGNlcHRpb24pOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIGVycm9yX21lc3NhZ2U9JycpOgogICAgICAgIEV4Y2VwdGlvbi5fX2luaXRfXyhzZWxmLCBlcnJvcl9tZXNzYWdlKQoKY2xhc3MgTGFuZ3VhZ2VUYXNrOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHBhcmFtcywgY29kZT1Ob25lKToKICAgICAgICAiIiJJbml0aWFsaXNlIHRoZSBvYmplY3QsIHJlY29yZGluZyB0aGUgcGFyYW1ldGVycyB0aGF0IHdpbGwgY29udHJvbCBjb21waWxhdGlvbiBhbmQKICAgICAgICAgICBydW5uaW5nIHBsdXMgdGhlIGNvZGUgaWYgc3VwcGxpZWQuIENvZGUgbWF5IGJlIGFsdGVybmF0aXZlbHkgYmUgc3VwcGxpZWQgbGF0ZXIgYnkKICAgICAgICAgICBjYWxscyB0byBzZXRfY29kZS4KICAgICAgICAgICBzZWxmLnBhcmFtcyBpcyB0aGUgZGljdGlvbmFyeSBvZiB0ZW1wbGF0ZSAmIGdsb2JhbCBwYXJhbWV0ZXJzIC0gbGFuZ3VhZ2Ugc3BlY2lmaWMuCiAgICAgICAgIiIiCiAgICAgICAgc2VsZi5wYXJhbXMgPSBwYXJhbXMKICAgICAgICBzZWxmLmNvZGUgPSBjb2RlCiAgICAgICAgc2VsZi5leGVjdXRhYmxlX2J1aWx0ID0gRmFsc2UKICAgICAgICBzZWxmLmNvbXBpbGVfZXJyb3JfbWVzc2FnZSA9IE5vbmUKICAgICAgICBzZWxmLmVycm9yX21lc3NhZ2Vfb2Zmc2V0ID0gMAogICAgICAgIHNlbGYuc3RkZXJyID0gJycKICAgICAgICBzZWxmLnN0ZG91dCA9ICcnCiAgICAgICAgc2VsZi5zdGFydF90aW1lID0gZGF0ZXRpbWUubm93KCkKICAgICAgICBzZWxmLnRpbWVkX291dCA9IEZhbHNlCiAgICAgICAgaWYgJ3RvdGFsdGltZW91dCcgbm90IGluIHBhcmFtczoKICAgICAgICAgICAgc2VsZi5wYXJhbXNbJ3RvdGFsdGltZW91dCddID0gMzAgIyBTZWNzCgogICAgZGVmIHNlY29uZHNfcmVtYWluaW5nKHNlbGYpOgogICAgICAgICIiIlRoZSBudW1iZXIgb2Ygc2Vjb25kcyBvZiBleGVjdXRpb24gdGltZSByZW1haW5pbmcgYmVmb3JlIHRoZSB3YXRjaGRvZyB0aW1lciBnb2VzIG9mZi4KICAgICAgICAgICBUaGUgd2F0Y2hkb2cgdGltZXIgZ29lcyBvZmYgMSBzZWNvbmQgYmVmb3JlIHJ1bmd1YXJkIGtpbGxzIHRoZSBqb2IgKGFzIGRldGVybWluZWQgYnkgdGhlICd0aW1lb3V0JyBwYXJhbWV0ZXIpLgogICAgICAgICIiIgogICAgICAgIHRfZWxhcHNlZCA9IChkYXRldGltZS5ub3coKSAtIHNlbGYuc3RhcnRfdGltZSkudG90YWxfc2Vjb25kcygpCiAgICAgICAgcmV0dXJuIHNlbGYucGFyYW1zWyd0b3RhbHRpbWVvdXQnXSAtIHRfZWxhcHNlZCAtIFdBVENIRE9HX0ZSRUVCT0FSRAoKICAgIGRlZiBzZXRfY29kZShzZWxmLCBjb2RlLCBlcnJvcl9tZXNzYWdlX29mZnNldD0wKToKICAgICAgICAiIiJTZXQgdGhlIGNvZGUgdG8gYmUgdXNlZCBmb3Igc3Vic2VxdWVudCBjb21waWxpbmcgYW5kIHJ1bm5pbmcuIFRoZSBvcHRpb25hbCBlcnJvcl9tZXNzYWdlX29mZnNldAogICAgICAgICAgIGlzIGEgbnVtYmVyIHRvIGJlIHN1YnRyYWN0ZWQgZnJvbSBhbnkgZXJyb3IgbWVzc2FnZXMgZ2VuZXJhdGVkIGJ5IGNvbXBpbGUgYW5kIHJ1bl9jb2RlIGNhbGxzLgogICAgICAgICAgIEV4YWN0bHkgaG93IChvciBldmVuICdpZicpIGl0IGlzIHVzZWQgaXMgbGFuZ3VhZ2UgZGVwZW5kZW50LgogICAgICAgICIiIgogICAgICAgIHNlbGYuY29kZSA9IGNvZGUKICAgICAgICBzZWxmLmVycm9yX21lc3NhZ2Vfb2Zmc2V0ID0gZXJyb3JfbWVzc2FnZV9vZmZzZXQKCiAgICBkZWYgY29tcGlsZShzZWxmLCBtYWtlX2V4ZWN1dGFibGU9RmFsc2UpOgogICAgICAgICIiIkNvbXBpbGUgdGhlIGN1cnJlbnRseSBzZXQgY29kZSwgZWl0aGVyIHRvIGFuIG9iamVjdCBmaWxlIG9yCiAgICAgICAgICAgdG8gYW4gZXhlY3V0YWJsZSBmaWxlIGRlcGVuZGluZyBvbiB0aGUgZ2l2ZW4gbWFrZV9leGVjdXRhYmxlIHBhcmFtZXRlci4KICAgICAgICAgICBBZGp1c3QgYW55IGVycm9yIG1lc3NhZ2UgYnkgc3VidHJhY3RpbmcgZXJyb3JfbWVzc2FnZV9vZmZzZXQuCiAgICAgICAgICAgUmFpc2UgQ29tcGlsZUVycm9yIGlmIHRoZSBjb2RlIGRvZXMgbm90CiAgICAgICAgICAgY29tcGlsZSwgd2l0aCB0aGUgY29tcGlsYXRpb24gZXJyb3IgbWVzc2FnZSB3aXRoaW4gdGhlIGV4Y2VwdGlvbgogICAgICAgICAgIGFuZCBhbHNvIHJlY29yZGVkIGluIHNlbGYuY29tcGlsZV9lcnJvcl9tZXNzYWdlLgogICAgICAgICAgIE5vIHJldHVybiB2YWx1ZS4KICAgICAgICAiIiIKICAgICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKCJjb21waWxlIG5vdCBpbXBsZW1lbnRlZCBieSBjb25jcmV0ZSBjbGFzcyIpCgogICAgZGVmIGRpc2NhcmRfZXhlY3V0YWJsZShzZWxmKToKICAgICAgICAiIiJDYWxsZWQgaWYgc29tZXRoaW5nIGJyZWFrcyBpbiB0aGUgZXhlY3V0YWJsZSBhbmQgaXQgd2lsbCBuZWVkIHJlYnVpbGRpbmcKICAgICAgICAgICAod2l0aCBkaWZmZXJlbnQgc291cmNlLCBwcmVzdW1hYmx5KQogICAgICAgICIiIgogICAgICAgIHNlbGYuZXhlY3V0YWJsZV9idWlsdCA9IEZhbHNlCgogICAgZGVmIHJ1bl9jb2RlKHNlbGYsIHN0YW5kYXJkX2lucHV0PU5vbmUsIGJhc2hfY29tbWFuZD1Ob25lKToKICAgICAgICAiIiJSdW4gdGhlIGNvZGUgaW4gdGhlIGV4ZWN1dGFibGUgcHJvZ3JhbSB0aGF0IGEgY2FsbCB0byBjb21waWxlIGlzIGFzc3VtZWQKICAgICAgICAgICB0byBoYXZlIGNyZWF0ZWQsIHVzaW5nIHRoZSBnaXZlbiBzdGFuZGFyZCBpbnB1dC4KICAgICAgICAgICBJZiBhIGJhc2hfY29tbWFuZCBpcyBzdXBwbGllZCBpdCB1c2VkIGFzIGdpdmVuLgogICAgICAgICAgIE90aGVyd2lzZSB0aGUgY29tbWFuZCB0byBiZSBleGVjdXRlZCBpcyB0aGUgY29tcGlsZWQgZXhlY3V0YWJsZS4KICAgICAgICAgICBSZXR1cm5zIGEgdHVwbGUgb2YgdGhlIG91dHB1dCBmcm9tIHRoZQogICAgICAgICAgIHJ1biBhbmQgYSBzdGRlcnIgKG9yIGEgZGVyaXZhdGl2ZSB0aGVyZW9mKSBzdHJpbmcuIFRob3NlIHR3byB2YWx1ZXMKICAgICAgICAgICBhcmUgYWxzbyByZWNvcmRlZCBpbiBzZWxmLnN0ZG91dCBhbmQgc2VsZi5zdGRlcnIgcmVzcGVjdGl2ZWx5LgogICAgICAgICIiIgogICAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoInJ1bl9jb2RlIG5vdCBpbXBsZW1lbnRlZCBieSBjb25jcmV0ZSBjbGFzcyIp</file>
<file name="__plottools.py" path="/" encoding="base64">IiIiRGVmaW5lIHN1cHBvcnQgZnVuY3Rpb25zIGZvciB0ZXN0aW5nIG9mIG1hdHBsb3RsaWIgcXVlc3Rpb25zLgogICBUaGUgbWFpbiBmdW5jdGlvbiBpcyBwcmludF9wbG90X2luZm8sIHdoaWNoIGRpc3BsYXlzIHN1aXRhYmx5IGZvcm1hdHRlZAogICBkYXRhIGFib3V0IHRoZSBjdXJyZW50IG1hdHBsb3RsaWIgcGxvdC4KCiAgIFRoaXMgbW9kdWxlIHdvcmtzIG9ubHkgaWYgaW1wb3J0ZWQgKmFmdGVyKiBhIGNhbGwgdG8gbWF0cGxvdGxpYmcudXNlKCJBZ2ciKSBoYXMKICAgYmVlbiBkb25lLgoiIiIKaW1wb3J0IHRyYWNlYmFjawppbXBvcnQgbnVtcHkgYXMgbnAKaW1wb3J0IG1hdHBsb3RsaWIucHlwbG90IGFzIHBsdApmcm9tIG1hdHBsb3RsaWIgaW1wb3J0IGNvbG9ycyBhcyBjb2xvcnMKZnJvbSBtYXRwbG90bGliLmNvbGxlY3Rpb25zIGltcG9ydCBQYXRoQ29sbGVjdGlvbgpmcm9tIHNjaXB5IGltcG9ydCBpbnRlcnBvbGF0ZQoKREVGQVVMVF9QQVJBTVMgPSB7CiAgICAneF9zYW1wbGVzJzogTm9uZSwgICMgQSBsaXN0IG9mIHgtdmFsdWVzIGF0IHdoaWNoIHkgdmFsdWVzIHNob3VsZCBiZSBpbnRlcnBvbGF0ZWQuCiAgICAnYmFyX2luZGljZXMnOiBOb25lLCAgIyBBIGxpc3Qgb2YgdGhlIDAtb3JpZ2luIGJhciBpbmRpY2VzIHRvIHJlcG9ydCBvbi4gTm9uZSBmb3IgYWxsIGJhcnMuCiAgICAnc2hvd194bGltJzogRmFsc2UsICAjIFRydWUgdG8gZGlzcGxheSB0aGUgeC1heGlzIGxpbWl0cwogICAgJ3Nob3dfeWxpbSc6IEZhbHNlLCAgIyBUcnVlIHRvIGRpc3BsYXkgdGhlIHktYXhpcyBsaW1pdHMKICAgICdzaG93X2NvbG91cic6IEZhbHNlLCAgIyBUcnVlIHRvIHJlcG9ydCBsaW5lL21hcmtlciBjb2xvdXIKICAgICdzaG93X3h0aWNrbGFiZWxzJzogRmFsc2UsICAjIFRydWUgdG8gZGlzcGxheSB4LXRpY2sgbGFiZWxzCiAgICAnc2hvd195dGlja2xhYmVscyc6IEZhbHNlLCAgIyBUcnVlIHRvIGRpc3BsYXkgeS10aWNrIGxhYmVscwogICAgJ3Nob3dfeHRpY2tzJzogRmFsc2UsICAjIFRydWUgdG8gZGlzcGxheSB4LXRpY2sgbnVtZXJpYyB2YWx1ZXMKICAgICdzaG93X3l0aWNrcyc6IEZhbHNlLCAgIyBUcnVlIHRvIGRpc3BsYXkgeS10aWNrIG51bWVyaWMgdmFsdWVzCiAgICAnc2hvd190aXRsZWZvbnQnOiBGYWxzZSwgIyBUcnVlIHRvIGRpc3BsYXkgdGl0bGUgZm9udG5hbWUgYW5kIHNpemUKICAgICdzaG93X2JhcngnOiBUcnVlLCAgIyBUcnVlIHRvIHByaW50IHRoZSB4LWNvb3JkaW5hdGVzIG9mIGFsbCBiYXJzCiAgICAnc2hvd19saW5lbGFiZWxzJzogTm9uZSwgICMgVHJ1ZSB0byBzaG93IGxpbmUgbGFiZWxzLCBkZWZhdWx0IGlzIFRydWUgaWYgdGhlcmUncyBhIGxlZ2VuZCBlbHNlIEZhbHNlCiAgICAnc29ydF9wb2ludHMnOiBGYWxzZSwgICMgVHJ1ZSB0byBzb3J0IGRhdGEgYnkgeCB0aGVuIHkuCiAgICAnZmlyc3RfbnVtX3BvaW50cyc6IDUsICAjIE51bWJlciBvZiBwb2ludHMgdG8gcHJpbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBwb2ludCBsaXN0LgogICAgJ2xhc3RfbnVtX3BvaW50cyc6IDUsICAjIE51bWJlciBvZiBwb2ludHMgdG8gcHJpbnQgYXQgdGhlIGVuZCBvZiB0aGUgcG9pbnQgbGlzdC4KICAgICdmbG9hdF9wcmVjaXNpb24nOiAoMSwgMSksICAjIE51bSBkaWdpdHMgdG8gZGlzcGxheSBhZnRlciBkZWNpbWFsIHBvaW50IGZvciB4IGFuZCB5IHZhbHVlcyByZXNwCiAgICAnbWF4X2xhYmVsX2xlbmd0aCc6IDYwLCAgIyBVc2UgbXVsdGlsaW5lIGRpc3BsYXkgaWYgdGljayBsYWJlbCBzdHJpbmcgbGVuZ3RoIGV4Y2VlZHMgdGhpcwogICAgJ2xpbmVzX3RvX3ByaW50JzogTm9uZSwgICMgSWYgbm9uLU5vbmUsIGEgbGlzdCBvZiBpbmRpY2VzIG9mIGxpbmVzIHRvIHByaW50ICgwIGlzIGZpcnN0IGxpbmUpLgogICAgJ2xpbmVfaW5mb19vbmx5JzogRmFsc2UsICAjIFRydWUgdG8gc3VwcHJlc3MgYWxsIGV4Y2VwdCB0aGUgbGluZS9iYXIvcG9pbnRzIGluZm8KfQoKCmNsYXNzIFBsb3RDaGVja2VyOgogICAgIiIiV3JhcHBlciBmb3IgYWxsIHRoZSBpbnRlcm5hbCBtZXRob2RzIHVzZWQgdG8gcHJpbnQgcGxvdCBpbmZvLiIiIgoKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBwYXJhbXNfZGljdCk6CiAgICAgICAgIiIiSW5pdGlhbGlzZSB3aXRoIGEgc3Vic2V0IG9mIHRoZSBvcHRpb25zIGxpc3RlZCBhYm92ZSIiIgogICAgICAgIHNlbGYucGFyYW1zID0gREVGQVVMVF9QQVJBTVMuY29weSgpCiAgICAgICAgc2VsZi5wYXJhbXMudXBkYXRlKHBhcmFtc19kaWN0KQoKICAgIEBzdGF0aWNtZXRob2QKICAgIGRlZiBteV9pbnRlcnBvbGF0ZShkYXRhLCB4cyk6CiAgICAgICAgIiIiUmV0dXJuIHRoZSBzcGxpbmUgaW50ZXJwb2xhdGVkIGxpc3Qgb2YgKHgsIHkpIHZhbHVlcyBhdCBhYnNjaXNzYSB4cywgZ2l2ZW4KICAgICAgICAgICBhIGxpc3Qgb2YgKHgsIHkpIHBhaXJzCiAgICAgICAgIiIiCgogICAgICAgIGRlZiBsaW5lYXIoeCwgeGEsIHlhLCB4YiwgeWIpOgogICAgICAgICAgICByZXR1cm4geWEgKyAoeCAtIHhhKSAvICh4YiAtIHhhKSAqICh5YiAtIHlhKQoKICAgICAgICBpZiBsZW4oZGF0YVs6LCAwXSkgPT0gMjoKICAgICAgICAgICAgeDAsIHkwID0gZGF0YVswXVswXSwgZGF0YVswXVsxXQogICAgICAgICAgICB4MSwgeTEgPSBkYXRhWy0xXVswXSwgZGF0YVstMV1bMV0KICAgICAgICAgICAgcmV0dXJuIFsoeCwgbGluZWFyKHgsIHgwLCB5MCwgeDEsIHkxKSkgZm9yIHggaW4geHNdCiAgICAgICAgZWxzZTogICMgY3ViaWMKICAgICAgICAgICAgdGNrID0gaW50ZXJwb2xhdGUuc3BscmVwKGRhdGFbOiwgMF0sIGRhdGFbOiwgMV0sIHM9MCkgICMgQ3ViaWMgc3BsaW5lIGludGVycG9sYXRvcgogICAgICAgICAgICByZXR1cm4gemlwKHhzLCBpbnRlcnBvbGF0ZS5zcGxldih4cywgdGNrKSkgICMgRXZhbHVhdGUgYXQgcmVxdWlyZWQgeCB2YWx1ZXMKCiAgICBAc3RhdGljbWV0aG9kCiAgICBkZWYgZm10X2Zsb2F0KHZhbHVlLCBkaWdpdHNfcHJlY2lzaW9uPTIpOgogICAgICAgICIiIlJldHVybiBhIGZvcm1hdHRlZCBmbG9hdGluZyBwb2ludCBudW1iZXIgdG8gdGhlIHByZWNpc2lvbiBzcGVjaWZpZWQsCiAgICAgICAgICAgcmVwbGFjaW5nIC0wIHdpdGggMCIiIgogICAgICAgIGZvcm1hdF9zdHJpbmcgPSBmJy57ZGlnaXRzX3ByZWNpc2lvbn1mJwogICAgICAgIHMgPSBmb3JtYXQodmFsdWUsIGZvcm1hdF9zdHJpbmcpCiAgICAgICAgaWYgcy5zdGFydHN3aXRoKCctJykgYW5kIGZsb2F0KHMpID09IDAuMDoKICAgICAgICAgICAgcyA9IHNbMTpdICAjIFN0cmlwIG9mZiB0aGUgbWludXMgc2lnbi4KICAgICAgICByZXR1cm4gcwogICAgICAgIAogICAgZGVmIGZtdF9mbG9hdF9heGlzKHNlbGYsIHZhbHVlLCBheGlzKToKICAgICAgICAiIiJGb3JtYXQgYSBnaXZlbiB2YWx1ZSBhcyBhIGZsb2F0IHdpdGggdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZgogICAgICAgICAgIGRpZ2l0cyBvZiBwcmVjaXNpb24gZm9yIHRoZSBzcGVjaWZpZWQgYXhpcyAoJ3gnIG9yICd5JykuCiAgICAgICAgICAgRXhjZXB0IC0gc3RyaW5nIHZhbHVlcyBhcmUgcmV0dXJuZWQgYXMgaXMuCiAgICAgICAgIiIiCiAgICAgICAgaWYgaXNpbnN0YW5jZSh2YWx1ZSwgc3RyKToKICAgICAgICAgICAgcmV0dXJuIHZhbHVlCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcHJlY2lzaW9uID0gc2VsZi5wYXJhbXNbJ2Zsb2F0X3ByZWNpc2lvbiddWzAgaWYgYXhpcyA9PSAneCcgZWxzZSAxXQogICAgICAgICAgICByZXR1cm4gc2VsZi5mbXRfZmxvYXQodmFsdWUsIHByZWNpc2lvbikKCiAgICBkZWYgZm10X2Zsb2F0X3BhaXIoc2VsZiwgcCwgcHJlY2lzaW9uPU5vbmUpOgogICAgICAgICIiIkEgZm9ybWF0dGVkICh4LCB5KSBwb2ludCBvciBvdGhlciBwYWlyIG9mIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuCiAgICAgICAgICAgQnkgZGVmYXVsdCwgdXNlIGZsb2F0X3ByZWNpc2lvbl94IGFuZCBmbG9hdF9wcmVjaXNpb25feSBmb3IgdGhlCiAgICAgICAgICAgZmlyc3QgYW5kIHNlY29uZCBudW1iZXJzIHJlc3AsIGVsc2UgdXNlIHByZWNpc2lvbiBpZiBnaXZlbi4KICAgICAgICAiIiIKICAgICAgICBpZiBwcmVjaXNpb24gaXMgTm9uZToKICAgICAgICAgICAgeF9wcmVjaXNpb24gPSBzZWxmLnBhcmFtc1snZmxvYXRfcHJlY2lzaW9uJ11bMF0KICAgICAgICAgICAgeV9wcmVjaXNpb24gPSBzZWxmLnBhcmFtc1snZmxvYXRfcHJlY2lzaW9uJ11bMV0KICAgICAgICBlbHNlOgogICAgICAgICAgICB4X3ByZWNpc2lvbiA9IHlfcHJlY2lzaW9uID0gcHJlY2lzaW9uCiAgICAgICAgcmV0dXJuIGYiKHtzZWxmLmZtdF9mbG9hdChwWzBdLCB4X3ByZWNpc2lvbil9LCB7c2VsZi5mbXRfZmxvYXQocFsxXSwgeV9wcmVjaXNpb24pfSkiCgogICAgQHN0YXRpY21ldGhvZAogICAgZGVmIG5vcm1hbGlzZV9jb2xvdXIoY29sb3VyKToKICAgICAgICAiIiJHaXZlbiBhIG1hdHBsb3RsaWIgY29sb3VyLCBjb252ZXJ0IHRvIGEgc3RhbmRhcmlzZWQgZm9ybWF0IiIiCiAgICAgICAgcmdiID0gY29sb3JzLnRvX3JnYihjb2xvdXIpCiAgICAgICAgcmV0dXJuIGYiUkdCKHtyZ2JbMF06MC4yZn0sIHtyZ2JbMV06MC4yZn0sIHtyZ2JbMl06MC4yZn0pIgogICAgCiAgICAKICAgIGRlZiBwcmludF9wb2ludHMoc2VsZiwgZGF0YSk6CiAgICAgICAgIiIiUHJpbnQgYSBzdWJzZXQgb2YgdGhlIGdpdmVuIHBvaW50cyIiIgogICAgICAgIHByaW50KGYiTnVtIHBvaW50czoge2xlbihkYXRhKX0iKQogICAgICAgIG4gPSBtaW4obGVuKGRhdGEpLCBzZWxmLnBhcmFtc1snZmlyc3RfbnVtX3BvaW50cyddKQogICAgICAgIGlmIG46CiAgICAgICAgICAgIHBvaW50cyA9ICdcbiAgICAnLmpvaW4oc2VsZi5mbXRfZmxvYXRfcGFpcihwKSBmb3IgcCBpbiBkYXRhWzpuXSkKICAgICAgICAgICAgaWYgbiA8IGxlbihkYXRhKToKICAgICAgICAgICAgICAgIHByaW50KGYiRmlyc3Qge259IHBvaW50czpcbiAgICB7cG9pbnRzfSIpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBwcmludChmIiAgICB7cG9pbnRzfSIpCiAgICAgICAgbGFzdF9uID0gbWluKGxlbihkYXRhKSAtIG4sIHNlbGYucGFyYW1zWydsYXN0X251bV9wb2ludHMnXSkKICAgICAgICBpZiBsYXN0X246CiAgICAgICAgICAgIHBvaW50cyA9ICdcbiAgICAnLmpvaW4oc2VsZi5mbXRfZmxvYXRfcGFpcihwKSBmb3IgcCBpbiBkYXRhWy1sYXN0X246XSkKICAgICAgICAgICAgcHJpbnQoZiJMYXN0IHtsYXN0X259IHBvaW50czpcbiAgICB7cG9pbnRzfSIpCiAgICAgICAgICAgIAogICAgCiAgICBkZWYgcHJpbnRfc2NhdHRlcihzZWxmLCBzY2F0dGVyKToKICAgICAgICAiIiJQcmludCB0aGUgZGF0YSBmb3IgYSBnaXZlbiBzY2F0dGVyIHBsb3QuCiAgICAgICAgICAgVW5mb3J0dW5hdGVseSB3ZSBjYW4ndCBkZXRlcm1pbmUgd2hhdCB0aGUgb3JpZ2luYWwgbWFya2VyIHNoYXBlCiAgICAgICAgICAgd2FzLCBhcyBpdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBwYXRoIG9iamVjdC4gSXQncyBub3QgcHJhY3RpY2FibGUKICAgICAgICAgICB0byB0cnkgaW5mZXJyaW5nIHRoZSBwbG90IGNoYXIgKCdvJywgJ14nIGV0YykgZnJvbSB0aGF0LgogICAgICAgICIiIgogICAgICAgIGlmIHNlbGYucGFyYW1zWydzaG93X2NvbG91ciddOgogICAgICAgICAgICBmYWNlY29sb3JzID0gc2NhdHRlci5nZXRfZmFjZWNvbG9ycygpCiAgICAgICAgICAgIHByaW50KCJDb2xvcjoiLCBzZWxmLm5vcm1hbGlzZV9jb2xvdXIoZmFjZWNvbG9yc1swXSkgaWYgbGVuKGZhY2Vjb2xvcnMpIGVsc2UgIlVua25vd24iKQogICAgICAgIHByaW50KCJNYXJrZXI6IG8iKQogICAgICAgIHByaW50KCJMaW5lIHN0eWxlOiBOb25lIikKICAgICAgICBwb2ludHMgPSBzY2F0dGVyLmdldF9vZmZzZXRzKCkKICAgICAgICBpZiBzZWxmLnBhcmFtc1snc29ydF9wb2ludHMnXToKICAgICAgICAgICAgcG9pbnRzID0gbnAuYXJyYXkoc29ydGVkKFtbcG9pbnRbMF0sIHBvaW50WzFdXSBmb3IgcG9pbnQgaW4gcG9pbnRzXSkpCiAgICAgICAgICAgIHByaW50KCJQbG90dGVkIGRhdGEsIGFmdGVyIHNvcnRpbmcgLi4uIikgICAgICAgIAogICAgICAgIHNlbGYucHJpbnRfcG9pbnRzKHBvaW50cykKCgogICAgZGVmIHByaW50X2xpbmUoc2VsZiwgbGluZSwgeHNhbXBsZXMpOgogICAgICAgICIiIlByaW50IHRoZSBpbmZvIGZvciB0aGUgZ2l2ZW4gbGluZSIiIgogICAgICAgIGlmIHNlbGYucGFyYW1zWydzaG93X2NvbG91ciddOgogICAgICAgICAgICBwcmludCgiQ29sb3I6Iiwgc2VsZi5ub3JtYWxpc2VfY29sb3VyKGxpbmUuZ2V0X2NvbG9yKCkpKQogICAgICAgIG1hcmtlciA9IGxpbmUuZ2V0X21hcmtlcigpCiAgICAgICAgaWYgbWFya2VyID09ICcnOgogICAgICAgICAgICBtYXJrZXIgPSBOb25lCiAgICAgICAgcHJpbnQoIk1hcmtlcjoiLCBtYXJrZXIpCiAgICAgICAgbGluZXN0eWxlID0gbGluZS5nZXRfbGluZXN0eWxlKCkKICAgICAgICBpZiBub3QgbGluZXN0eWxlOgogICAgICAgICAgICBsaW5lc3R5bGUgPSBOb25lCiAgICAgICAgcHJpbnQoIkxpbmUgc3R5bGU6IiwgbGluZXN0eWxlKQogICAgICAgIGxhYmVsID0gbGluZS5nZXRfbGFiZWwoKQogICAgICAgIGlmIGxhYmVsIGFuZCBzZWxmLnBhcmFtc1snc2hvd19saW5lbGFiZWxzJ106CiAgICAgICAgICAgIHByaW50KCJMYWJlbDoiLCBsYWJlbCkKICAgICAgICBkYXRhID0gbGluZS5nZXRfeHlkYXRhKCkKCiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ3NvcnRfcG9pbnRzJ106CiAgICAgICAgICAgIGRhdGEgPSBucC5hcnJheShzb3J0ZWQoW1tyb3dbMF0sIHJvd1sxXV0gZm9yIHJvdyBpbiBkYXRhXSkpCiAgICAgICAgICAgIHByaW50KCJQbG90dGVkIGRhdGEsIGFmdGVyIHNvcnRpbmcgLi4uIikKCiAgICAgICAgaWYgeHNhbXBsZXMgaXMgbm90IE5vbmU6CiAgICAgICAgICAgIHByaW50KGYiRmlyc3QgcG9pbnQ6IHtzZWxmLmZtdF9mbG9hdF9wYWlyKGRhdGFbMF0pfSIpCiAgICAgICAgICAgIHByaW50KGYiTGFzdCBwb2ludDoge3NlbGYuZm10X2Zsb2F0X3BhaXIoZGF0YVstMV0pfSIpCiAgICAgICAgICAgIHByaW50KGYiSW50ZXJwb2xhdGluZyBsaW5lIGF0IHNlbGVjdGVkIHggdmFsdWVzOiIpCiAgICAgICAgICAgIGludGVycG9sYXRlZCA9IHNlbGYubXlfaW50ZXJwb2xhdGUoZGF0YSwgeHNhbXBsZXMpCiAgICAgICAgICAgIGZvciBwIGluIGludGVycG9sYXRlZDoKICAgICAgICAgICAgICAgIHByaW50KCcgICAnLCBzZWxmLmZtdF9mbG9hdF9wYWlyKHApKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHNlbGYucHJpbnRfcG9pbnRzKGRhdGEpCgogICAgZGVmIHByaW50X2xpbmVzKHNlbGYsIHN1YnBsb3QsIHhzYW1wbGVzKToKICAgICAgICAiIiJQcmludCBhbGwgc2VsZWN0ZWQgbGluZXMgaW4gdGhlIHBsb3Qgc2hvd2luZyB5IHZhbHVlcyBpbnRlcnBsb2xhdGVkIGF0IHRoZSB4IHNhbXBsZSBwb2ludHMsCiAgICAgICAgICAgaWYgZ2l2ZW4uIE90aGVyd2lzZSwgcHJpbnQganVzdCB0aGUgZmlyc3QgZmlyc3RfbnVtX3BvaW50cyBhbmQgbGFzdCBsYXN0X251bV9wb2ludHMuIEFsc28KICAgICAgICAgICBzaG93IGxpbmUgY29sb3VycyBpZiB0aGUgc2hvd19jb2xvdXIgcGFyYW1ldGVyIGlzIFRydWUuCiAgICAgICAgICAgRXh0ZW5kZWQgdG8gcHJpbnQgdGhlIHBvaW50cyBmcm9tIGEgc2NhdHRlciBwbG90IGlmIHRoZSBzdHVkZW50IGNhbGxlZAogICAgICAgICAgIHNjYXR0ZXIuCiAgICAgICAgIiIiCiAgICAgICAgbGluZXMgPSBzdWJwbG90LmdldF9saW5lcygpCiAgICAgICAgaXNfc2NhdHRlcl9wbG90ID0gRmFsc2UKICAgICAgICBpZiBsZW4obGluZXMpID09IDA6CiAgICAgICAgICAgICMgTWF5IGJlIGEgY2FsbCB0byBzY2F0dGVyLiBUcnkgZm9yIHRoYXQuCiAgICAgICAgICAgIHNjYXR0ZXJfcGxvdHMgPSBbY2hpbGQgZm9yIGNoaWxkIGluIHN1YnBsb3QuX2NoaWxkcmVuIGlmIGlzaW5zdGFuY2UoY2hpbGQsIFBhdGhDb2xsZWN0aW9uKV0KICAgICAgICAgICAgaWYgeHNhbXBsZXMgb3IgbGVuKHNjYXR0ZXJfcGxvdHMpID09IDA6CiAgICAgICAgICAgICAgICBwcmludCgiTm8gcGxvdHRlZCBkYXRhIGZvdW5kIikKICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgbGluZXMgPSBzY2F0dGVyX3Bsb3RzICMgVGVsbGluZyBwb3JraWVzIGhlcmUsIGJ1dCByZWFkIG9uLgogICAgICAgICAgICAgICAgaXNfc2NhdHRlcl9wbG90ID0gVHJ1ZQoKICAgICAgICBsaW5lX2luZGljZXMgPSBzZWxmLnBhcmFtc1snbGluZXNfdG9fcHJpbnQnXQogICAgICAgIGlmIGxpbmVfaW5kaWNlcyBpcyBOb25lOgogICAgICAgICAgICB3YW50ZWRfbGluZXMgPSBsaW5lcwogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHdhbnRlZF9saW5lcyA9IFtdCiAgICAgICAgICAgIGZvciBpIGluIGxpbmVfaW5kaWNlczoKICAgICAgICAgICAgICAgIGlmIGkgPj0gbGVuKGxpbmVzKToKICAgICAgICAgICAgICAgICAgICBwcmludChmIkNhbid0IGRpc3BsYXkgaW5mbyBmb3IgcGxvdCB7aX0gLSBubyBzdWNoIHBsb3QhIikKICAgICAgICAgICAgICAgICAgICByZXR1cm4KICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgd2FudGVkX2xpbmVzLmFwcGVuZChsaW5lc1tpXSkKCiAgICAgICAgbXVsdGlsaW5lcyA9IGxlbih3YW50ZWRfbGluZXMpID4gMQogICAgICAgIGlmIG11bHRpbGluZXM6CiAgICAgICAgICAgIHByaW50KGYiRGlzcGxheWluZyBpbmZvIGZvciB7bGVuKHdhbnRlZF9saW5lcyl9IGxpbmVzIikKICAgICAgICBmb3IgaSwgbGluZSBpbiBlbnVtZXJhdGUod2FudGVkX2xpbmVzLCAxKToKICAgICAgICAgICAgaWYgbXVsdGlsaW5lczoKICAgICAgICAgICAgICAgIHByaW50KGYiTGluZSB7aX06IikKICAgICAgICAgICAgaWYgaXNfc2NhdHRlcl9wbG90OgogICAgICAgICAgICAgICAgc2VsZi5wcmludF9zY2F0dGVyKGxpbmUpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBzZWxmLnByaW50X2xpbmUobGluZSwgeHNhbXBsZXMpCiAgICAgICAgICAgIGlmIG11bHRpbGluZXM6CiAgICAgICAgICAgICAgICBwcmludCgpCiAgICAgICAgICAgCgogICAgQHN0YXRpY21ldGhvZAogICAgZGVmIGluX3JhbmdlKGxhYmVscywgbGltaXRzKToKICAgICAgICAiIiJSZXR1cm4gdGhlIGxpc3Qgb2YgYXhpcyBsYWJlbHMsIGZpbHRlcmVkIHRvIGluY2x1ZGUgb25seSB0aG9zZSB3aXRoaW4KICAgICAgICAgICB0aGUgZ2l2ZW4gbGltaXRzIChtaW4sIG1heCkuIElmIGFueSBvZiB0aGUgYXhpcyBsYWJlbHMgYXJlIG5vbi1udW1lcmljCiAgICAgICAgICAgdGhlIGxpc3QgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLgogICAgICAgICIiIgogICAgICAgIHRyeToKICAgICAgICAgICAgY2xpcHBlZF9sYWJlbHMgPSBbXQogICAgICAgICAgICBmb3IgcyBpbiBsYWJlbHM6CiAgICAgICAgICAgICAgICBpZiBpc2luc3RhbmNlKHMsIHN0cik6CiAgICAgICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgn4oiSJywgJy0nKQogICAgICAgICAgICAgICAgaWYgbGltaXRzWzBdIDw9IGZsb2F0KHMpIDw9IGxpbWl0c1sxXToKICAgICAgICAgICAgICAgICAgICBjbGlwcGVkX2xhYmVscy5hcHBlbmQocykKICAgICAgICAgICAgcmV0dXJuIGNsaXBwZWRfbGFiZWxzCiAgICAgICAgZXhjZXB0IFZhbHVlRXJyb3I6CiAgICAgICAgICAgIHJldHVybiBsYWJlbHMKCiAgICBkZWYgcHJpbnRfYmFycyhzZWxmLCBzdWJwbG90KToKICAgICAgICAiIiJQcmludCBhIGxpc3Qgb2YgYWxsIGJhcnMgaWYgdGhlIGJhcl9pbmRpY2VzIHBhcmFtIGlzIE5vbmUgb3IgYSBsaXN0IG9mIHRoZQogICAgICAgICAgIGJhcnMgd2l0aCB0aGUgZ2l2ZW4gaW5kaWNlcywgb3RoZXJ3aXNlLgogICAgICAgICIiIgogICAgICAgIHByaW50KCJCYXJzOiIpCiAgICAgICAgYmFycyA9IHN1YnBsb3QucGF0Y2hlcwogICAgICAgIGlmIGJhcnMgYW5kIHNlbGYucGFyYW1zWydzaG93X2NvbG91ciddOgogICAgICAgICAgICBwcmludChmIkZpcnN0IGJhciBjb2xvdXI6IHtzZWxmLm5vcm1hbGlzZV9jb2xvdXIoYmFyc1swXS5nZXRfZmFjZWNvbG9yKCkpfSIpCiAgICAgICAgYmFyX2luZGljZXMgPSBzZWxmLnBhcmFtc1snYmFyX2luZGljZXMnXQogICAgICAgIGlmIGJhcl9pbmRpY2VzIGlzIE5vbmU6CiAgICAgICAgICAgIGJhcl9pbmRpY2VzID0gcmFuZ2UoMCwgbGVuKHN1YnBsb3QucGF0Y2hlcykpCiAgICAgICAgZm9yIGkgaW4gYmFyX2luZGljZXM6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGJhciA9IHN1YnBsb3QucGF0Y2hlc1tpXQogICAgICAgICAgICAgICAgeSA9IGJhci5nZXRfaGVpZ2h0KCkKICAgICAgICAgICAgICAgIGlmIHNlbGYucGFyYW1zWydzaG93X2JhcngnXToKICAgICAgICAgICAgICAgICAgICB4ID0gYmFyLmdldF94eSgpWzBdICsgYmFyLmdldF93aWR0aCgpIC8gMgogICAgICAgICAgICAgICAgICAgIGJhcl9zcGVjID0gZiJCYXJ7aX06IHggPSB7c2VsZi5mbXRfZmxvYXRfYXhpcyh4LCAneCcpfSwgaGVpZ2h0ID0ge3NlbGYuZm10X2Zsb2F0X2F4aXMoeSwgJ3knKX0iCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIGJhcl9zcGVjID0gZiJCYXJ7aX06IGhlaWdodCA9IHtzZWxmLmZtdF9mbG9hdF9heGlzKHksICd5Jyl9IgogICAgICAgICAgICAgICAgcHJpbnQoYmFyX3NwZWMpCiAgICAgICAgICAgIGV4Y2VwdCBJbmRleEVycm9yOgogICAgICAgICAgICAgICAgcHJpbnQoZiJCYXJ7aX0gbm90IGZvdW5kLiBOdW1iZXIgb2YgYmFycyA9IHtsZW4oc3VicGxvdC5wYXRjaGVzKX0iKQogICAgICAgICAgICAgICAgYnJlYWsKCiAgICBkZWYgdGlja19sYWJlbF90ZXh0KHNlbGYsIGxhYmVscyk6CiAgICAgICAgIiIiUmV0dXJuIGEgc3RyaW5nIHN1aXRhYmxlIGZvciBkaXNwbGF5aW5nIHRpY2sgbGFiZWxzIChtdWx0aWxpbmUgb3IKICAgICAgICAgICBzaW5nbGUgbGluZSBkZXBlbmRpbmcgb24gbGVuZ3RoLgogICAgICAgICIiIgogICAgICAgIGxhYmVsX3RleHQgPSAnLCAnLmpvaW4obGFiZWxzKQogICAgICAgIGlmIGxlbihsYWJlbF90ZXh0KSA+IHNlbGYucGFyYW1zWydtYXhfbGFiZWxfbGVuZ3RoJ106CiAgICAgICAgICAgIGxhYmVsX3RleHQgPSAnXG4nLmpvaW4obGFiZWxzKQogICAgICAgIHJldHVybiBsYWJlbF90ZXh0CiAgICAKICAgIGRlZiBwcmludF90aWNrc19mb3JfYXhpcyhzZWxmLCBheGlzLCBzdWJwbG90LCBheGlzX2xpbWl0KToKICAgICAgICAiIiJQcmludCB0aWNrIGFuZCB0aWNrbGFiZWwgaW5mbyBmb3IgdGhlIGdpdmVuIGF4aXMgKCd4JyBvciAneScpIG9mCiAgICAgICAgICAgdGhlIGdpdmVuIHN1YnBsb3QuIGF4aXNfbGltaXQgaXMgZWl0aGVyIHhsaW0gb3IgeWxpbS4KICAgICAgICAiIiIKICAgICAgICBheGlzID0gYXhpcy5sb3dlcigpICAjIEp1c3QgdG8gYmUgc2FmZQogICAgICAgIGlmIGF4aXMgPT0gJ3gnOgogICAgICAgICAgICB0aWNrcyA9IHN1YnBsb3QuZ2V0X3h0aWNrcygpCiAgICAgICAgICAgIHRpY2tfbGFiZWxzX29iaiA9IHN1YnBsb3QuZ2V0X3h0aWNrbGFiZWxzKCkKICAgICAgICBlbHNlOgogICAgICAgICAgICBhc3NlcnQgYXhpcyA9PSAneScKICAgICAgICAgICAgdGlja3MgPSBzdWJwbG90LmdldF95dGlja3MoKQogICAgICAgICAgICB0aWNrX2xhYmVsc19vYmogPSBzdWJwbG90LmdldF95dGlja2xhYmVscygpCiAgICAgICAgICAgIAogICAgICAgIHRpY2tfbGFiZWxzID0gW2xhYmVsLmdldF90ZXh0KCkgZm9yIGxhYmVsIGluIHRpY2tfbGFiZWxzX29ial0KICAgICAgICAgICAgCiAgICAgICAgaWYgYWxsKGZsb2F0KGludCh0aWNrKSkgPT0gdGljayBmb3IgdGljayBpbiB0aWNrcyk6CiAgICAgICAgICAgICMgSWYgYWxsIHRpY2tzIGFyZSBpbnRlZ2VycywgZG9uJ3QgZm9ybWF0IGFzIGZsb2F0cwogICAgICAgICAgICBmb3JtYXR0ZWRfdGlja3MgPSBbc3RyKGludCh0aWNrKSkgZm9yIHRpY2sgaW4gdGlja3NdCiAgICAgICAgZWxzZToKICAgICAgICAgICAgZm9ybWF0dGVkX3RpY2tzID0gW3NlbGYuZm10X2Zsb2F0X2F4aXMocG9zLCBheGlzKSBmb3IgcG9zIGluIHRpY2tzXQogICAgICAgIAogICAgICAgIGlmIHNlbGYucGFyYW1zW2Ync2hvd197YXhpc310aWNrcyddOgogICAgICAgICAgICBwcmludChmJ3theGlzLnVwcGVyKCl9LWF4aXMgdGlja3MgYXQgJywgJywgJy5qb2luKGZvcm1hdHRlZF90aWNrcykpCgogICAgICAgIGlmIHNlbGYucGFyYW1zW2Ync2hvd197YXhpc310aWNrbGFiZWxzJ106CiAgICAgICAgICAgICMgQSBwcm9ibGVtIGhlcmUgaXMgdGhhdCBpbiBhIGNhbGwgdG8gYmFyKGF4aXNfbGFiZWxzLCBiYXJfaGVpZ2h0cykKICAgICAgICAgICAgIyB0aGUgY2FsbCB0byBnZXRfeHRpY2tsYWJlbHMgZG9lc24ndCByZXR1cm4gdGhlIGFjdHVhbCBsYWJlbHMsCiAgICAgICAgICAgICMgYnV0IHJhdGhlciB0aGVpciB0aWNrIGxvY2F0aW9ucy4KICAgICAgICAgICAgIyBJIGNhbid0IGZpbmQgYSB3b3JrYXJvdW5kIGZvciB0aGlzLgogICAgICAgICAgICBpZiBhbGwobGFiZWwuc3RyaXAoKSA9PSAnJyBmb3IgbGFiZWwgaW4gdGlja19sYWJlbHMpOgogICAgICAgICAgICAgICAgdGlja19sYWJlbHMgPSBmb3JtYXR0ZWRfdGlja3MKICAgICAgICAgICAgdGlja19sYWJlbHMgPSBzZWxmLmluX3JhbmdlKHRpY2tfbGFiZWxzLCBheGlzX2xpbWl0KQogICAgICAgICAgICBwcmludChmJ3theGlzLnVwcGVyKCl9LWF4aXMgdGljayBsYWJlbHM6JykKICAgICAgICAgICAgcHJpbnQoc2VsZi50aWNrX2xhYmVsX3RleHQodGlja19sYWJlbHMpKSAgICAgICAgCiAgICAgICAgCgogICAgZGVmIHByaW50X3RpY2tzKHNlbGYsIHN1YnBsb3QsIHhsaW0sIHlsaW0pOgogICAgICAgICIiIlByaW50IHRpY2sgYW5kIHRpY2tsYWJlbCBpbmZvIGZvciB0aGUgZ2l2ZW4gc3VicGxvdC4iIiIKICAgICAgICBzZWxmLnByaW50X3RpY2tzX2Zvcl9heGlzKCd4Jywgc3VicGxvdCwgeGxpbSkKICAgICAgICBzZWxmLnByaW50X3RpY2tzX2Zvcl9heGlzKCd5Jywgc3VicGxvdCwgeWxpbSkKCiAgICBkZWYgcHJpbnRfYXhpc19pbmZvKHNlbGYsIHN1YnBsb3QpOgogICAgICAgICIiIlByaW50IHRoZSBheGlzIGluZm8gZm9yIHRoZSBnaXZlbiBzdWJwbG90IiIiCgogICAgICAgIHByaW50KCJYLWF4aXMgbGFiZWw6ICd7fSciLmZvcm1hdChzdWJwbG90LmdldF94bGFiZWwoKSkpCiAgICAgICAgcHJpbnQoIlktYXhpcyBsYWJlbDogJ3t9JyIuZm9ybWF0KHN1YnBsb3QuZ2V0X3lsYWJlbCgpKSkKICAgICAgICB4Z3JpZGxpbmVzID0gc3VicGxvdC5nZXRfeGdyaWRsaW5lcygpCiAgICAgICAgeWdyaWRsaW5lcyA9IHN1YnBsb3QuZ2V0X3lncmlkbGluZXMoKQogICAgICAgIGdyaWR4X29uID0gbGVuKHhncmlkbGluZXMpID4gMCBhbmQgYm9vbCh4Z3JpZGxpbmVzWzBdLmdldF92aXNpYmxlKCkpCiAgICAgICAgZ3JpZHlfb24gPSBsZW4oeWdyaWRsaW5lcykgPiAwIGFuZCBib29sKHlncmlkbGluZXNbMF0uZ2V0X3Zpc2libGUoKSkKICAgICAgICBwcmludChmIih4LCB5KSBncmlkIGxpbmVzIGVuYWJsZWQ6ICh7Z3JpZHhfb259LCB7Z3JpZHlfb259KSIpCiAgICAgICAgeGxpbSA9IHN1YnBsb3QuZ2V0X3hsaW0oKQogICAgICAgIHlsaW0gPSBzdWJwbG90LmdldF95bGltKCkKICAgICAgICBpZiBzZWxmLnBhcmFtc1snc2hvd194bGltJ106CiAgICAgICAgICAgIHByaW50KGYiWC1heGlzIGxpbWl0czoge3NlbGYuZm10X2Zsb2F0X3BhaXIoeGxpbSwgcHJlY2lzaW9uPXNlbGYucGFyYW1zWydmbG9hdF9wcmVjaXNpb24nXVswXSl9IikKICAgICAgICBpZiBzZWxmLnBhcmFtc1snc2hvd195bGltJ106CiAgICAgICAgICAgIHByaW50KGYiWS1heGlzIGxpbWl0czoge3NlbGYuZm10X2Zsb2F0X3BhaXIoeWxpbSwgcHJlY2lzaW9uPXNlbGYucGFyYW1zWydmbG9hdF9wcmVjaXNpb24nXVsxXSl9IikKICAgICAgICBzZWxmLnByaW50X3RpY2tzKHN1YnBsb3QsIHhsaW0sIHlsaW0pCgogICAgICAgIGlmIHN1YnBsb3QuZ2V0X2xlZ2VuZCgpIGlzIG5vdCBOb25lOgogICAgICAgICAgICBwcmludChmIkxlZ2VuZDogVHJ1ZSIpCiAgICAgICAgcHJpbnQoKQoKICAgIGRlZiBwcmludF9zdWJwbG90X2luZm8oc2VsZiwgZGF0YV90eXBlLCBzdWJwbG90LCB0aXRsZSk6CiAgICAgICAgIiIiUHJpbnQgdGhlIGluZm8gZm9yIGEgc2luZ2xlIGdpdmVuIHN1YnBsb3QuCiAgICAgICAgICAgSWYgdGhlIGRhdGFfdHlwZSBpcyAnbGluZXMnIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB4X3NhbXBsZXMKICAgICAgICAgICBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHggdmFsdWVzIGF0IHdoaWNoIHRoZSBsaW5lIHNob3VsZCBiZSBzYW1wbGVkLgogICAgICAgICAgIHRpY2tzIGFuZCB0aWNrIGxhYmVscyBhcmUgc2hvd24gb25seSBpZiB0aGUgc2hvd197YXhpc310aWNrcyBhbmQKICAgICAgICAgICBzaG93X3theGlzfWxhYmVscyBwYXJhbWV0ZXJzIGFyZSBleHBsaWNpdGx5IHNldCB0byBUcnVlLgogICAgICAgICAgIHRpdGxlIGlzIGEgVGV4dCBvYmplY3QsIG5vdCBhIHN0cmluZy4KICAgICAgICAiIiIKICAgICAgICBpZiBub3Qgc2VsZi5wYXJhbXNbJ2xpbmVfaW5mb19vbmx5J106CiAgICAgICAgICAgIGhhc19sZWdlbmQgPSBzdWJwbG90LmdldF9sZWdlbmQoKSBpcyBub3QgTm9uZQogICAgICAgICAgICBpZiBoYXNfbGVnZW5kIGFuZCBzZWxmLnBhcmFtc1snc2hvd19saW5lbGFiZWxzJ10gaXMgTm9uZToKICAgICAgICAgICAgICAgIHNlbGYucGFyYW1zWydzaG93X2xpbmVsYWJlbHMnXSA9IFRydWUKICAgICAgICAgICAgdGl0bGVfdGV4dCA9IHRpdGxlLmdldF90ZXh0KCkKICAgICAgICAgICAgcHJpbnQoIlBsb3QgdGl0bGU6ICd7fSciLmZvcm1hdCh0aXRsZV90ZXh0KSkKICAgICAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ3Nob3dfdGl0bGVmb250J106CiAgICAgICAgICAgICAgICBpZiBzZWxmLnBhcmFtc1snc2hvd19jb2xvdXInXToKICAgICAgICAgICAgICAgICAgICBjb2xvdXIgPSAnICcgKyBzZWxmLm5vcm1hbGlzZV9jb2xvdXIodGl0bGUuZ2V0X2NvbG9yKCkpCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIGNvbG91ciA9ICcnCiAgICAgICAgICAgICAgICBwcmludChmIlRpdGxlIGZvbnQ6IHt0aXRsZS5nZXRfZm9udHNpemUoKX0gcHQge3RpdGxlLmdldF9mb250ZmFtaWx5KClbMF19e2NvbG91cn0iKQogICAgICAgICAgICBzZWxmLnByaW50X2F4aXNfaW5mbyhzdWJwbG90KQoKICAgICAgICBpZiBkYXRhX3R5cGUgPT0gJ3BvaW50cyc6CiAgICAgICAgICAgIHNlbGYucHJpbnRfbGluZXMoc3VicGxvdCwgTm9uZSkKICAgICAgICBlbGlmIGRhdGFfdHlwZSA9PSAnbGluZXMnOgogICAgICAgICAgICBzZWxmLnByaW50X2xpbmVzKHN1YnBsb3QsIHNlbGYucGFyYW1zWyd4X3NhbXBsZXMnXSkKICAgICAgICBlbGlmIGRhdGFfdHlwZSA9PSAnYmFycyc6CiAgICAgICAgICAgIHNlbGYucHJpbnRfYmFycyhzdWJwbG90KQoKICAgIGRlZiBwcmludF9pbmZvKHNlbGYsIGRhdGFfdHlwZSk6CiAgICAgICAgIiIiUHJpbnQgYWxsIHRoZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGN1cnJlbnQgcGxvdC4gZGF0YV90eXBlCiAgICAgICAgICAgbXVzdCBiZSAncG9pbnRzJywgJ2xpbmVzJyBvciAnYmFycycuCiAgICAgICAgIiIiCiAgICAgICAgdHJ5OgogICAgICAgICAgICBheGVzID0gcGx0LmdjZigpLmdldF9heGVzKCkKICAgICAgICAgICAgdGV4dHMgPSBwbHQuZ2NmKCkudGV4dHMKICAgICAgICAgICAgaWYgbm90IHNlbGYucGFyYW1zWydsaW5lX2luZm9fb25seSddOgogICAgICAgICAgICAgICAgaWYgbGVuKGF4ZXMpID4gMToKICAgICAgICAgICAgICAgICAgICBwcmludChmIkZpZ3VyZSBoYXMge2xlbihheGVzKX0gc3VicGxvdHMiKQogICAgICAgICAgICAgICAgaWYgbGVuKHRleHRzKSAhPSAwOgogICAgICAgICAgICAgICAgICAgIHByaW50KGYiU3VwdGl0bGU6IHt0ZXh0c1swXS5nZXRfdGV4dCgpfVxuIikKICAgICAgICAgICAgZm9yIGksIGN1cnJlbnRfYXhlcyBpbiBlbnVtZXJhdGUoYXhlcywgMSk6CiAgICAgICAgICAgICAgICBpZiBsZW4oYXhlcykgPiAxIGFuZCBub3Qgc2VsZi5wYXJhbXNbJ2xpbmVfaW5mb19vbmx5J106CiAgICAgICAgICAgICAgICAgICAgcHJpbnQoZiJTdWJwbG90IHtpfVxuLS0tLS0tLS0tIikKICAgICAgICAgICAgICAgIHN1YnBsb3QgPSBjdXJyZW50X2F4ZXMuYXhlcwogICAgICAgICAgICAgICAgdGl0bGUgPSBjdXJyZW50X2F4ZXMudGl0bGUKICAgICAgICAgICAgICAgIHNlbGYucHJpbnRfc3VicGxvdF9pbmZvKGRhdGFfdHlwZSwgc3VicGxvdCwgdGl0bGUpCiAgICAgICAgICAgICAgICBpZiBsZW4oYXhlcykgPiAxIGFuZCBub3Qgc2VsZi5wYXJhbXNbJ2xpbmVfaW5mb19vbmx5J106CiAgICAgICAgICAgICAgICAgICAgcHJpbnQoNDAgKiAiPSIpCiAgICAgICAgICAgICAgICAgICAgcHJpbnQoKQoKICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgIHByaW50KCJGYWlsZWQgdG8gZ2V0IHBsb3QgaW5mbzoiLCByZXByKGUpKQogICAgICAgICAgICB0cmFjZWJhY2sucHJpbnRfZXhjZXB0aW9uKGUpCgoKZGVmIHByaW50X3Bsb3RfaW5mbyhkYXRhX3R5cGUsICoqa3dwYXJhbXMpOgogICAgIiIiT3V0cHV0IGtleSBhdHRyaWJ1dGVzIG9mIGN1cnJlbnQgcGxvdCwgYXMgZGVmaW5lZCBieSBwbHQuZ2NhKCkuCiAgICAgICBkYXRhX3R5cGUgbXVzdCBiZSBvbmUgb2YgJ3BvaW50cycsICdsaW5lcycgb3IgJ2JhcnMnLCB0byBwcmludCB0aGUKICAgICAgIGFwcHJvcHJpYXRlIHR5cGUgb2YgZGF0YS4KICAgICAgIEZvciB2YWx1ZXMgb2YgcG9zc2libGUga2V5d29yZCBwYXJhbWV0ZXJzIHNlZSBERUZBVUxUX1BBUkFNUyBkZWNsYXJhdGlvbgogICAgIiIiCgogICAgdW5rbm93bl9wYXJhbXMgPSBzZXQoa3dwYXJhbXMpIC0gc2V0KERFRkFVTFRfUEFSQU1TKQogICAgaWYgdW5rbm93bl9wYXJhbXM6CiAgICAgICAgcHJpbnQoZiJVbmtub3duIHBhcmFtZXRlcihzKSBwYXNzZWQgdG8gcHJpbnRfcGxvdF9pbmZvOiB7JywgJy5qb2luKHVua25vd25fcGFyYW1zKX0iKQogICAgICAgIHJldHVybgoKICAgIGNoZWNrZXIgPSBQbG90Q2hlY2tlcihrd3BhcmFtcykKICAgIGNoZWNrZXIucHJpbnRfaW5mbyhkYXRhX3R5cGUp</file>
<file name="pyproject.toml" path="/" encoding="base64">W3Rvb2wucnVmZl0KbGluZS1sZW5ndGggPSAxMDAKaW5kZW50LXdpZHRoID0gNApvdXRwdXQtZm9ybWF0ID0gJ3B5bGludCcKClt0b29sLnJ1ZmYubGludC5weWxpbnRdCm1heC1icmFuY2hlcyA9IDEwCgpbdG9vbC5ydWZmLmxpbnRdIApzZWxlY3QgPSBbIkEwMCIsIAogICAgICAgICAgIkFSRyIsICAKICAgICAgICAgICJCMDE1IiwgIkIwMTgiLCAiQjAyMCIsIAogICAgICAgICAgIkQxIiwgCiAgICAgICAgICAiRTEiLCAiRTUiLCAiRTcwMSIsICJFNzAyIiwgIkU3MDMiLCAiRTcxMSIsICJFNzIyIiwgCiAgICAgICAgICAiRiIsIAogICAgICAgICAgIklTQzAwMSIsICAgCiAgICAgICAgICAiTiIsIAogICAgICAgICAgIlBMRSIsICJQTFIwOTEyIiwgIlBMVzA2MDMiLCAiUExXMTUwMSIsICJQTFczMjAxIiwgCiAgICAgICAgICAiUzMwNyIsICAKICAgICAgICAgICJSRVQ1MDMiLCAgCiAgICAgICAgICBdIAppZ25vcmUgPSBbIkQxMDUiLCAiRDEwNyIsICJFMTE3IiwgIkY0MDEiLCAiRjg0MSJdIApwcmV2aWV3ID0gdHJ1ZSAK</file>
<file name="__pystylechecker.py" path="/" encoding="base64">IiIiQWxsIHRoZSBzdHlsZSBjaGVja2luZyBjb2RlIGZvciBQeXRob24zIiIiCgpmcm9tIGlvIGltcG9ydCBCeXRlc0lPCmltcG9ydCBvcwppbXBvcnQgc3lzCmltcG9ydCBzdWJwcm9jZXNzCmltcG9ydCBhc3QKaW1wb3J0IHRva2VuaXplCmltcG9ydCB0b2tlbgppbXBvcnQgcmUKaW1wb3J0IHNodXRpbApmcm9tIGNvbGxlY3Rpb25zIGltcG9ydCBkZWZhdWx0ZGljdAoKY2xhc3MgU3R5bGVDaGVja2VyOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHByZWx1ZGUsIHN0dWRlbnRfYW5zd2VyLCBwYXJhbXMpOgogICAgICAgIHNlbGYucHJlbHVkZSA9IHByZWx1ZGUKICAgICAgICBzZWxmLnN0dWRlbnRfYW5zd2VyID0gc3R1ZGVudF9hbnN3ZXIKICAgICAgICBzZWxmLnBhcmFtcyA9IHBhcmFtcwogICAgICAgIHNlbGYuZnVuY3Rpb25fY2FsbF9tYXAgPSBOb25lCiAgICAgICAgc2VsZi5fdHJlZSA9IE5vbmUKCiAgICBAcHJvcGVydHkKICAgIGRlZiB0cmVlKHNlbGYpOgogICAgICAgIGlmIHNlbGYuX3RyZWUgaXMgTm9uZToKICAgICAgICAgICAgc2VsZi5fdHJlZSA9IGFzdC5wYXJzZShzZWxmLnN0dWRlbnRfYW5zd2VyKQogICAgICAgIHJldHVybiBzZWxmLl90cmVlCgogICAgZGVmIHN0eWxlX2Vycm9ycyhzZWxmKToKICAgICAgICAiIiJSZXR1cm4gYSBsaXN0IG9mIGVycm9ycyBmcm9tIGxvY2FsIHN0eWxlIGNoZWNrcyBwbHVzIHB5bGludCBhbmQvb3IgbXlweQogICAgICAgICIiIgogICAgICAgIGVycm9ycyA9IFtdCiAgICAgICAgc291cmNlID0gb3BlbignX19zb3VyY2UucHknLCAndycsIGVuY29kaW5nPSJ1dGYtOCIpCiAgICAgICAgY29kZV90b19jaGVjayA9IHNlbGYucHJlbHVkZSArIHNlbGYuc3R1ZGVudF9hbnN3ZXIKICAgICAgICBwcmVsdWRlX2xlbiA9IGxlbihzZWxmLnByZWx1ZGUuc3BsaXRsaW5lcygpKQogICAgICAgIHNvdXJjZS53cml0ZShjb2RlX3RvX2NoZWNrKQogICAgICAgIHNvdXJjZS5jbG9zZSgpCiAgICAgICAgZW52ID0gb3MuZW52aXJvbi5jb3B5KCkKICAgICAgICBlbnZbJ0hPTUUnXSA9IG9zLmdldGN3ZCgpCiAgICAgICAgcHlsaW50X29wdHMgPSBzZWxmLnBhcmFtcy5nZXQoJ3B5bGludG9wdGlvbnMnLFtdKQogICAgICAgIHJ1ZmZfb3B0cyA9IHNlbGYucGFyYW1zLmdldCgncnVmZm9wdGlvbnMnLCBbXSkKCiAgICAgICAgcHJlY2hlY2tlcnMgPSBzZWxmLnBhcmFtcy5nZXQoJ3ByZWNoZWNrZXJzJywgWydweWxpbnQnXSkKICAgICAgICByZXN1bHQgPSAnJwoKICAgICAgICAjIEZpcnN0IHRyeSBjaGVja2luZyB3aXRoIHB5bGludCBhbmQvb3IgcnVmZi4KICAgICAgICAjIFJ1ZmYgdHJlYXRzIGZpbGVuYW1lcyBzdGFydGluZyB3aXRoIHVuZGVyc2NvcmUgYXMgcHJpdmF0ZSwgY2hhbmdpbmcgaXRzIGJlaGF2aW91ci4KICAgICAgICAjIFNvIHdlIGNyZWF0ZSBhIHRlbXBvcmFyeSBmaWxlIHNvdXJjZS5weSB0aGVuIGRlbGV0ZSBpdCBhZ2Fpbi4KICAgICAgICBsaW50ZXJzID0gWwogICAgICAgICAgICAoJ3B5bGludCcsIGYne3N5cy5leGVjdXRhYmxlfSAtbSBweWxpbnQgJyArICcgJy5qb2luKHB5bGludF9vcHRzKSArICcgX19zb3VyY2UucHknLCAncHlsaW50OicpLAogICAgICAgICAgICAoJ3J1ZmYnLCBmJ2NwIF9fc291cmNlLnB5IHNvdXJjZS5weTsvdXNyL2xvY2FsL2Jpbi9ydWZmIGNoZWNrIC0tcXVpZXQgeyIgIi5qb2luKHJ1ZmZfb3B0cyl9IHNvdXJjZS5weTsgcm0gc291cmNlLnB5JywgJ25vcWEnKSwKICAgICAgICBdCgogICAgICAgIGZvciBsaW50ZXIsIGNtZCwgZGlzYWJsZV9rZXl3b3JkIGluIGxpbnRlcnM6CiAgICAgICAgICAgIGlmIGxpbnRlciBpbiBwcmVjaGVja2VyczoKICAgICAgICAgICAgICAgIHRyeTogICMgUnVuIHB5bGludCBvciBydWZmCiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc3VicHJvY2Vzcy5jaGVja19vdXRwdXQoY21kLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGRlcnI9c3VicHJvY2Vzcy5TVERPVVQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXZlcnNhbF9uZXdsaW5lcz1UcnVlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnY9ZW52LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGVsbD1UcnVlKQogICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGUub3V0cHV0CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICMgKG1jdDYzKSBBYm9ydCBpZiB0aGVyZSBhcmUgYW55IGNvbW1lbnRzIGRpc2FibGluZyB0aGUgbGludGVyJy4KICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuaXplciA9IHRva2VuaXplLnRva2VuaXplKEJ5dGVzSU8oc2VsZi5zdHVkZW50X2Fuc3dlci5lbmNvZGUoJ3V0Zi04JykpLnJlYWRsaW5lKQogICAgICAgICAgICAgICAgICAgICAgICBmb3IgdG9rZW5fdHlwZSwgdG9rZW5fdGV4dCwgKl8gaW4gdG9rZW5pemVyOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgdG9rZW5fdHlwZSA9PSB0b2tlbml6ZS5DT01NRU5UIGFuZCBkaXNhYmxlX2tleXdvcmQgaW4gdG9rZW5fdGV4dDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMuYXBwZW5kKGYiQ29tbWVudHMgY2FuIG5vdCBpbmNsdWRlICd7ZGlzYWJsZV9rZXl3b3JkfSciKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIlNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIHBhcnNpbmcgY29tbWVudHMuIFJlcG9ydCB0aGlzLiIpCgogICAgICAgICAgICAgICAgaWYgIlVzaW5nIGNvbmZpZyBmaWxlIiBpbiByZXN1bHQ6CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gJ1xuJy5qb2luKHJlc3VsdC5zcGxpdGxpbmVzKClbMTpdKS5zcGxpdCgpCgoKICAgICAgICBpZiByZXN1bHQgPT0gJycgYW5kICdteXB5JyBpbiBwcmVjaGVja2VyczoKICAgICAgICAgICAgY29kZV90b19jaGVjayA9ICdmcm9tIHR5cGluZyBpbXBvcnQgTGlzdCBhcyBsaXN0LCBEaWN0IGFzIGRpY3QsIFR1cGxlIGFzIHR1cGxlLCBTZXQgYXMgc2V0LCBBbnlcbicgKyBjb2RlX3RvX2NoZWNrCiAgICAgICAgICAgIHdpdGggb3BlbignX19zb3VyY2UyLnB5JywgJ3cnLCBlbmNvZGluZz0ndXRmLTgnKSBhcyBvdXRmaWxlOgogICAgICAgICAgICAgICAgb3V0ZmlsZS53cml0ZShjb2RlX3RvX2NoZWNrKQogICAgICAgICAgICBjbWQgPSBmJ3tzeXMuZXhlY3V0YWJsZX0gLW0gbXlweSAtLW5vLWVycm9yLXN1bW1hcnkgLS1uby1zdHJpY3Qtb3B0aW9uYWwgX19zb3VyY2UyLnB5JwogICAgICAgICAgICB0cnk6ICMgUnVuIG15cHkKICAgICAgICAgICAgICAgIHN1YnByb2Nlc3MuY2hlY2tfb3V0cHV0KGNtZCwgICMgUmFpc2VzIGFuIGV4Y2VwdGlvbiBpZiB0aGVyZSBhcmUgZXJyb3JzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGRlcnI9c3VicHJvY2Vzcy5TVERPVVQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bml2ZXJzYWxfbmV3bGluZXM9VHJ1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudj1lbnYsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGVsbD1UcnVlKQogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgICAgICByZXN1bHQgPSBlLm91dHB1dAogICAgICAgICAgICAgICAgbGluZV9udW1fZml4ID0gbGFtYmRhIG1hdGNoOiAiTGluZSAiICsgc3RyKGludChtYXRjaFsxXSkgLSAxIC0gcHJlbHVkZV9sZW4pICsgbWF0Y2hbMl0KICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlLnN1YihyJ19fc291cmNlMi5weTooXGQrKSguKiknLCBsaW5lX251bV9maXgsIHJlc3VsdCkKCiAgICAgICAgaWYgcmVzdWx0ID09ICcnIGFuZCBzZWxmLnBhcmFtcy5nZXQoJ3JlcXVpcmV0eXBlaGludHMnLCBGYWxzZSk6CiAgICAgICAgICAgIGJhZF9mdW5jcyA9IHNlbGYuY2hlY2tfdHlwZV9oaW50cygpCiAgICAgICAgICAgIGZvciBmdW4gaW4gYmFkX2Z1bmNzOgogICAgICAgICAgICAgICAgcmVzdWx0ICs9IGYiRnVuY3Rpb24gJ3tmdW59JyBkb2VzIG5vdCBoYXZlIGNvcnJlY3QgdHlwZSBoaW50c1xuIgoKICAgICAgICBpZiByZXN1bHQ6CiAgICAgICAgICAgIGVycm9ycyA9IHJlc3VsdC5zdHJpcCgpLnNwbGl0bGluZXMoKQoKICAgICAgICByZXR1cm4gZXJyb3JzCiAgICAKICAgIGRlZiBwcmV0dGllZChzZWxmLCBjb25zdHJ1Y3QpOgogICAgICAgICIiIkV4cGFuZCwgaWYgcG9zc2libGUsIHRoZSBuYW1lIG9mIHRoZSBnaXZlbiBQeXRob24gY29uc3RydWN0IHRvIGEgbW9yZQogICAgICAgICAgIHVzZXIgZnJpZW5kbHkgdmVyc2lvbiwgZS5nLiAnbGlzdGNvbXByZWhlbnNpb24nIC0+ICdsaXN0IGNvbXByZWhlbnNpb24nCiAgICAgICAgIiIiCiAgICAgICAgZXhwYW5kZWQgPSB7CiAgICAgICAgICAgICdsaXN0Y29tcHJlaGVuc2lvbic6ICdsaXN0IGNvbXByZWhlbnNpb24nLAogICAgICAgICAgICAnd2hpbGUnOiAnd2hpbGUgbG9vcCcsCiAgICAgICAgICAgICdmb3InOiAnZm9yIGxvb3AnLAogICAgICAgICAgICAndHJ5JzogJ3RyeSAuLi4gZXhjZXB0IHN0YXRlbWVudCcsCiAgICAgICAgICAgICdkaWN0Y29tcHJlaGVuc2lvbic6ICdkaWN0aW9uYXJ5IGNvbXByZWhlbnNpb24nLAogICAgICAgICAgICAnc2xpY2UnOiAnc2xpY2UnCiAgICAgICAgfQogICAgICAgIGlmIGNvbnN0cnVjdCBpbiBleHBhbmRlZDoKICAgICAgICAgICAgcmV0dXJuIGV4cGFuZGVkW2NvbnN0cnVjdF0KICAgICAgICBlbHNlOgogICAgICAgICAgICByZXR1cm4gZiJ7Y29uc3RydWN0fSBzdGF0ZW1lbnQiCgogICAgZGVmIGxvY2FsX2Vycm9ycyhzZWxmKToKICAgICAgICAiIiJQZXJmb3JtIHZhcmlvdXMgbG9jYWwgY2hlY2tzIGFzIHNwZWNpZmllZCBieSB0aGUgY3VycmVudCBzZXQgb2YKICAgICAgICAgICB0ZW1wbGF0ZSBwYXJhbWV0ZXJzLgogICAgICAgICIiIgogICAgICAgIGVycm9ycyA9IFtdCgogICAgICAgIGZvciBiYW5uZWQgaW4gc2VsZi5wYXJhbXMuZ2V0KCdwcm9zY3JpYmVkc3Vic3RyaW5ncycsIFtdKToKICAgICAgICAgICAgaWYgYmFubmVkIGluIHNlbGYuc3R1ZGVudF9hbnN3ZXI6CiAgICAgICAgICAgICAgICBlcnJvcnMuYXBwZW5kKGYiVGhlIHN0cmluZyAne2Jhbm5lZH0nIGlzIG5vdCBwZXJtaXR0ZWQgYW55d2hlcmUgaW4geW91ciBjb2RlLiIpCgogICAgICAgIGZvciByZXF1aXJlZCBpbiBzZWxmLnBhcmFtcy5nZXQoJ3JlcXVpcmVkc3Vic3RyaW5ncycsIFtdKToKICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShyZXF1aXJlZCwgc3RyKSBhbmQgcmVxdWlyZWQgbm90IGluIHNlbGYuc3R1ZGVudF9hbnN3ZXI6CiAgICAgICAgICAgICAgICBlcnJvcnMuYXBwZW5kKGYnVGhlIHN0cmluZyAie3JlcXVpcmVkfSIgbXVzdCBvY2N1ciBzb21ld2hlcmUgaW4geW91ciBjb2RlLicpCiAgICAgICAgICAgIGVsaWYgaXNpbnN0YW5jZShyZXF1aXJlZCwgZGljdCk6IAogICAgICAgICAgICAgICAgaWYgJ3BhdHRlcm4nIGluIHJlcXVpcmVkIGFuZCBub3QgcmUuZmluZGFsbChyZXF1aXJlZFsncGF0dGVybiddLCBzZWxmLnN0dWRlbnRfYW5zd2VyKToKICAgICAgICAgICAgICAgICAgICBlcnJvcnMuYXBwZW5kKHJlcXVpcmVkWydlcnJvcm1lc3NhZ2UnXSkKICAgICAgICAgICAgICAgIGVsaWYgJ3N0cmluZycgaW4gcmVxdWlyZWQgYW5kIHJlcXVpcmVkWydzdHJpbmcnXSBub3QgaW4gc2VsZi5zdHVkZW50X2Fuc3dlcjoKICAgICAgICAgICAgICAgICAgICBlcnJvcnMuYXBwZW5kKHJlcXVpcmVkWydlcnJvcm1lc3NhZ2UnXSkKCiAgICAgICAgaWYgc2VsZi5wYXJhbXMuZ2V0KCdiYW5nbG9iYWxjb2RlJywgVHJ1ZSk6CiAgICAgICAgICAgIGVycm9ycyArPSBzZWxmLmZpbmRfZ2xvYmFsX2NvZGUoKQoKICAgICAgICBpZiBub3Qgc2VsZi5wYXJhbXMuZ2V0KCdhbGxvd25lc3RlZGZ1bmN0aW9ucycsIFRydWUpOgogICAgICAgICAgICAjIEV4Y2VwdCBmb3IgbGVnYWN5IHF1ZXN0aW9ucyBvciB3aGVyZSBleHBsaWNpdGx5IGFsbG93ZWQsIG5lc3RlZCBmdW5jdGlvbnMgYXJlIGJhbm5lZAogICAgICAgICAgICBuZXN0ZWRfZnVuY3MgPSBzZWxmLmZpbmRfbmVzdGVkX2Z1bmN0aW9ucygpCiAgICAgICAgICAgIGZvciBmdW5jIGluIG5lc3RlZF9mdW5jczoKICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIkZ1bmN0aW9uICd7fScgaXMgZGVmaW5lZCBpbnNpZGUgYW5vdGhlciBmdW5jdGlvbiIuZm9ybWF0KGZ1bmMpKQoKICAgICAgICBtYXhfbGVuZ3RoID0gc2VsZi5wYXJhbXNbJ21heGZ1bmN0aW9ubGVuZ3RoJ10KICAgICAgICBiYWRfZnVuY3MgPSBzZWxmLmZpbmRfdG9vX2xvbmdfZnVuY3MobWF4X2xlbmd0aCkKICAgICAgICBmb3IgZnVuYywgY291bnQgaW4gYmFkX2Z1bmNzOgogICAgICAgICAgICBlcnJvcnMuYXBwZW5kKCJGdW5jdGlvbiAne30nIGlzIHRvbyBsb25nXG4oe30gc3RhdGVtZW50cywgbWF4IGlzIHt9KSIKICAgICAgICAgICAgICAgICAgICAgICAgICAiIi5mb3JtYXQoZnVuYywgY291bnQsIG1heF9sZW5ndGgpKQoKICAgICAgICBiYWRfdXNlZCA9IHNlbGYuZmluZF9pbGxlZ2FsX2Z1bmN0aW9ucygpCiAgICAgICAgZm9yIG5hbWUgaW4gYmFkX3VzZWQ6CiAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIllvdSBjYWxsZWQgdGhlIGJhbm5lZCBmdW5jdGlvbiAne30nLiIuZm9ybWF0KG5hbWUpKQoKICAgICAgICBtaXNzaW5nX2Z1bmNzID0gc2VsZi5maW5kX21pc3NpbmdfcmVxdWlyZWRfZnVuY3Rpb25fY2FsbHMoKQogICAgICAgIGZvciBuYW1lIGluIG1pc3NpbmdfZnVuY3M6CiAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIllvdSBmb3Jnb3QgdG8gdXNlIHRoZSByZXF1aXJlZCBmdW5jdGlvbiAne30nLiIuZm9ybWF0KG5hbWUpKQoKICAgICAgICBtaXNzaW5nX2Z1bmNzID0gc2VsZi5maW5kX21pc3NpbmdfcmVxdWlyZWRfZnVuY3Rpb25fZGVmaW5pdGlvbnMoKQogICAgICAgIGZvciBuYW1lIGluIG1pc3NpbmdfZnVuY3M6CiAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIllvdSBmb3Jnb3QgdG8gZGVmaW5lIHRoZSByZXF1aXJlZCBmdW5jdGlvbiAne30nLiIuZm9ybWF0KG5hbWUpKQoKICAgICAgICBtaXNzaW5nX2NvbnN0cnVjdHMgPSBzZWxmLmZpbmRfbWlzc2luZ19yZXF1aXJlZF9jb25zdHJ1Y3RzKCkKICAgICAgICBmb3IgcmVxZCBpbiBtaXNzaW5nX2NvbnN0cnVjdHM6CiAgICAgICAgICAgIGV4cGFuZGVkID0gc2VsZi5wcmV0dGllZChyZXFkKQogICAgICAgICAgICBlcnJvcnMuYXBwZW5kKGYiWW91ciBwcm9ncmFtIG11c3QgaW5jbHVkZSBhdCBsZWFzdCBvbmUge2V4cGFuZGVkfS4iKQoKICAgICAgICBiYWRfY29uc3RydWN0cyA9IHNlbGYuZmluZF9pbGxlZ2FsX2NvbnN0cnVjdHMoKQogICAgICAgIGZvciBub3RhbGxvd2VkIGluIGJhZF9jb25zdHJ1Y3RzOgogICAgICAgICAgICBleHBhbmRlZCA9IHNlbGYucHJldHRpZWQobm90YWxsb3dlZCkKICAgICAgICAgICAgZXJyb3JzLmFwcGVuZChmIllvdXIgcHJvZ3JhbSBtdXN0IG5vdCBpbmNsdWRlIGFueSB7ZXhwYW5kZWR9cy4iKQoKICAgICAgICBudW1fY29uc3RhbnRzID0gbGVuKFtsaW5lIGZvciBsaW5lIGluIHNlbGYuc3R1ZGVudF9hbnN3ZXIuc3BsaXQoJ1xuJykgaWYgcmUubWF0Y2goJyAqW0EtWl9dW0EtWl8wLTldKiAqPScsIGxpbmUpXSkKICAgICAgICBpZiBudW1fY29uc3RhbnRzID4gc2VsZi5wYXJhbXNbJ21heG51bWNvbnN0YW50cyddOgogICAgICAgICAgICBlcnJvcnMuYXBwZW5kKCJZb3UgbWF5IG5vdCB1c2UgbW9yZSB0aGFuICIgKyBzdHIoc2VsZi5wYXJhbXNbJ21heG51bWNvbnN0YW50cyddKSArICIgY29uc3RhbnRzLiIpCgogICAgICAgIGlmIHNlbGYucGFyYW1zLmdldCgnYmFuZnVuY3Rpb25yZWRlZmluaXRpb25zJywgVHJ1ZSk6CiAgICAgICAgICAgIGVycm9ycyArPSBzZWxmLmZpbmRfcmVkZWZpbml0aW9ucygpCgogICAgICAgICMgKG1jdDYzKSBDaGVjayBpZiBhbnl0aGluZyByZXN0cmljdGVkIGlzIGJlaW5nIGltcG9ydGVkLgogICAgICAgIGlmICdyZXN0cmljdGVkbW9kdWxlcycgaW4gc2VsZi5wYXJhbXM6CiAgICAgICAgICAgIHJlc3RyaWN0ZWQgPSBzZWxmLnBhcmFtc1sncmVzdHJpY3RlZG1vZHVsZXMnXQogICAgICAgICAgICBmb3IgaW1wb3J0X25hbWUsIG5hbWVzIGluIHNlbGYuZmluZF9hbGxfaW1wb3J0cygpLml0ZW1zKCk6CiAgICAgICAgICAgICAgICBpZiBpbXBvcnRfbmFtZSBpbiByZXN0cmljdGVkOgogICAgICAgICAgICAgICAgICAgIGlmIHJlc3RyaWN0ZWRbaW1wb3J0X25hbWVdLmdldCgnb25seWFsbG93JywgTm9uZSkgPT0gW106CiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIllvdXIgcHJvZ3JhbSBzaG91bGQgbm90IGltcG9ydCBhbnl0aGluZyBmcm9tICd7fScuIi5mb3JtYXQoaW1wb3J0X25hbWUpKQogICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgIGZvciBuYW1lIGluIG5hbWVzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgnb25seWFsbG93JyBpbiByZXN0cmljdGVkW2ltcG9ydF9uYW1lXSBhbmQgbmFtZSBub3QgaW4gcmVzdHJpY3RlZFtpbXBvcnRfbmFtZV1bJ29ubHlhbGxvdyddKSBvcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lIGluIHJlc3RyaWN0ZWRbaW1wb3J0X25hbWVdLmdldCgnZGlzYWxsb3cnLCBbXSkpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIllvdXIgcHJvZ3JhbSBzaG91bGQgbm90IGltcG9ydCAne30nIGZyb20gJ3t9Jy4iLmZvcm1hdChuYW1lLCBpbXBvcnRfbmFtZSkpCgogICAgICAgIGlmICdtYXhyZXR1cm5kZXB0aCcgaW4gc2VsZi5wYXJhbXMgYW5kIChtYXhfZGVwdGggOj0gc2VsZi5wYXJhbXNbJ21heHJldHVybmRlcHRoJ10pIGlzIG5vdCBOb25lOgogICAgICAgICAgICBiYWRfcmV0dXJucyA9IHNlbGYuZmluZF9uZXN0ZWRfcmV0dXJucyhtYXhfZGVwdGgpCiAgICAgICAgICAgIGlmIGJhZF9yZXR1cm5zOgogICAgICAgICAgICAgICAgaWYgbWF4X2RlcHRoID09IDE6CiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgiVGhpcyBxdWVzdGlvbiBkb2VzIG5vdCBhbGxvdyByZXR1cm4gc3RhdGVtZW50cyB3aXRoaW4gbG9vcHMsIGlmIHN0YXRlbWVudHMgZXRjIikKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLmFwcGVuZChmIlRoaXMgcXVlc3Rpb24gZG9lcyBub3QgYWxsb3cgcmV0dXJuIHN0YXRlbWVudHMgdG8gYmUgaW5kZW50ZWQgbW9yZSB0aGFuICd7bWF4X2RlcHRofScgbGV2ZWxzIikKICAgICAgICByZXR1cm4gZXJyb3JzCgogICAgZGVmIGZpbmRfYWxsX2ltcG9ydHMoc2VsZik6CiAgICAgICAgIiIiUmV0dXJucyBhIGRpY3Rpb25hcnkgbWFwcGluZyBpbiB3aGljaCB0aGUga2V5cyBhcmUgYWxsIG1vZHVsZXMKICAgICAgICAgICBiZWluZyBpbXBvcnRlZCBhbmQgdGhlIHZhbHVlcyBhcmUgYSBsaXN0IG9mIHdoYXQgdGhpbmdzIHdpdGhpbgogICAgICAgICAgIHRoZSBtb2R1bGUgYXJlIGJlaW5nIG1vZHVsZXMuIEFuIGVtcHR5IGxpc3QgaW5kaWNhdGVzIHRoZSBlbnRpcmUKICAgICAgICAgICBtb2R1bGUgaXMgaW1wb3J0ZWQuIiIiCiAgICAgICAgZm91bmRfaW1wb3J0cyA9IHt9CiAgICAgICAgY2xhc3MgSW1wb3J0RmluZGVyKGFzdC5Ob2RlVmlzaXRvcik6CiAgICAgICAgICAgIGRlZiB2aXNpdF9JbXBvcnQoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBmb3IgYWxpYXMgaW4gbm9kZS5uYW1lczoKICAgICAgICAgICAgICAgICAgICBpZiBhbGlhcy5uYW1lIG5vdCBpbiBmb3VuZF9pbXBvcnRzOgogICAgICAgICAgICAgICAgICAgICAgICBmb3VuZF9pbXBvcnRzW2FsaWFzLm5hbWVdID0gW10KICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfSW1wb3J0RnJvbShzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGlmIG5vZGUubW9kdWxlIG5vdCBpbiBmb3VuZF9pbXBvcnRzOgogICAgICAgICAgICAgICAgICAgIGZvdW5kX2ltcG9ydHNbbm9kZS5tb2R1bGVdID0gW10KICAgICAgICAgICAgICAgIGZvciBhbGlhcyBpbiBub2RlLm5hbWVzOgogICAgICAgICAgICAgICAgICAgIGZvdW5kX2ltcG9ydHNbbm9kZS5tb2R1bGVdLmFwcGVuZChhbGlhcy5uYW1lKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCgogICAgICAgIHZpc2l0b3IgPSBJbXBvcnRGaW5kZXIoKQogICAgICAgIHZpc2l0b3IudmlzaXQoc2VsZi50cmVlKQogICAgICAgIHJldHVybiBmb3VuZF9pbXBvcnRzCgogICAgZGVmIGZpbmRfYWxsX2Z1bmN0aW9uX2NhbGxzKHNlbGYpOgogICAgICAgICIiIlJldHVybiBhIGRpY3Rpb25hcnkgbWFwcGluZyBpbiB3aGljaCB0aGUga2V5cyBhcmUgYWxsIGZ1bmN0aW9ucwogICAgICAgICAgIGNhbGxlZCBieSB0aGUgc291cmNlIGNvZGUgYW5kIHZhbHVlcyBhcmUgYSBsaXN0IG9mCiAgICAgICAgICAgKGxpbmVfbnVtYmVyLCBuZXN0aW5nX2RlcHRoKSB0dXBsZXMuIiIiCiAgICAgICAgY2xhc3MgRnVuY0ZpbmRlcihhc3QuTm9kZVZpc2l0b3IpOgoKICAgICAgICAgICAgZGVmIF9faW5pdF9fKHNlbGYsICphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgICAgICBzZWxmLmRlcHRoID0gMAogICAgICAgICAgICAgICAgc2VsZi5mb3VuZF9mdW5jcyA9IGRlZmF1bHRkaWN0KGxpc3QpCiAgICAgICAgICAgICAgICBzdXBlcigpLl9faW5pdF9fKCphcmdzLCAqKmt3YXJncykKCiAgICAgICAgICAgIGRlZiB2aXNpdF9GdW5jdGlvbkRlZihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgICIiIiBFdmVyeSB0aW1lIHdlIGVudGVyIGEgZnVuY3Rpb24sIHdlIGdldCAnZGVlcGVyJyBpbnRvIHRoZSBjb2RlLgogICAgICAgICAgICAgICAgICAgIFdlIHdhbnQgdG8gbm90ZSBob3cgZGVlcCBhIGZ1bmN0aW9uIGlzIHdoZW4gd2UgZmluZCBpdHMgY2FsbC4iIiIKICAgICAgICAgICAgICAgIHNlbGYuZGVwdGggKz0gMQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgICAgICBzZWxmLmRlcHRoIC09IDEKCiAgICAgICAgICAgIGRlZiB2aXNpdF9DYWxsKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgIiIiQSBmdW5jdGlvbiBoYXMgYmVlbiBjYWxsZWQsIHNvIGNoZWNrIGl0cyBuYW1lCiAgICAgICAgICAgICAgICAgICBhZ2FpbnN0IHRoZSBnaXZlbiBvbmUuIiIiCiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgaWYgJ2lkJyBpbiBkaXIobm9kZS5mdW5jKToKICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5vZGUuZnVuYy5pZAogICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBub2RlLmZ1bmMuYXR0cgogICAgICAgICAgICAgICAgICAgICMgTGluZSBudW1iZXJzIGFyZSAxLWluZGV4ZWQsIHNvIGRlY3JlbWVudCBieSAxCiAgICAgICAgICAgICAgICAgICAgc2VsZi5mb3VuZF9mdW5jc1tuYW1lXS5hcHBlbmQoKG5vZGUubGluZW5vIC0gMSwgc2VsZi5kZXB0aCkpCiAgICAgICAgICAgICAgICBleGNlcHQgQXR0cmlidXRlRXJyb3I6CiAgICAgICAgICAgICAgICAgICAgcGFzcyAgIyBlaXRoZXIgbm90IGNhbGxpbmcgYSBmdW5jdGlvbiAoPz8pIG9yIGl0J3Mgbm90IG5hbWVkLgogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCgogICAgICAgIGlmIHNlbGYuZnVuY3Rpb25fY2FsbF9tYXAgaXMgTm9uZToKICAgICAgICAgICAgdmlzaXRvciA9IEZ1bmNGaW5kZXIoKQogICAgICAgICAgICB2aXNpdG9yLnZpc2l0KHNlbGYudHJlZSkKICAgICAgICAgICAgc2VsZi5mdW5jdGlvbl9jYWxsX21hcCA9IHZpc2l0b3IuZm91bmRfZnVuY3MKICAgICAgICByZXR1cm4gc2VsZi5mdW5jdGlvbl9jYWxsX21hcAoKCiAgICBkZWYgZmluZF9kZWZpbmVkX2Z1bmN0aW9ucyhzZWxmKToKICAgICAgICAiIiJGaW5kIGFsbCB0aGUgZnVuY3Rpb25zIGRlZmluZWQuIiIiCiAgICAgICAgZGVmaW5lZCA9IHNldCgpCiAgICAgICAgY2xhc3MgRnVuY0ZpbmRlcihhc3QuTm9kZVZpc2l0b3IpOgoKICAgICAgICAgICAgZGVmIF9faW5pdF9fKHNlbGYpOgogICAgICAgICAgICAgICAgc2VsZi5wcmVmaXggPSAnJwoKICAgICAgICAgICAgZGVmIHZpc2l0X0NsYXNzRGVmKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgb2xkX3ByZWZpeCA9IHNlbGYucHJlZml4CiAgICAgICAgICAgICAgICBzZWxmLnByZWZpeCArPSBub2RlLm5hbWUgKyAnLicKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICAgICAgc2VsZi5wcmVmaXggPSBvbGRfcHJlZml4CgogICAgICAgICAgICBkZWYgdmlzaXRfRnVuY3Rpb25EZWYoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBkZWZpbmVkLmFkZChzZWxmLnByZWZpeCArIG5vZGUubmFtZSkKICAgICAgICAgICAgICAgIG9sZF9wcmVmaXggPSBzZWxmLnByZWZpeAogICAgICAgICAgICAgICAgc2VsZi5wcmVmaXggKz0gbm9kZS5uYW1lICsgJy4nCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgICAgIHNlbGYucHJlZml4ID0gb2xkX3ByZWZpeAoKICAgICAgICAgICAgZGVmIHZpc2l0X0FzeW5jRnVuY3Rpb25EZWYoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBzZWxmLnZpc2l0X0Z1bmN0aW9uRGVmKG5vZGUpCgogICAgICAgIHZpc2l0b3IgPSBGdW5jRmluZGVyKCkKICAgICAgICB2aXNpdG9yLnZpc2l0KHNlbGYudHJlZSkKICAgICAgICByZXR1cm4gZGVmaW5lZAogICAgCgogICAgZGVmIG5lc3RlZF9yZXR1cm5zKHNlbGYpOgogICAgICAgICIiIlJldHVybiBhIGRpY3Rpb25hcnkgaW4gd2hpY2ggdGhlIGtleXMgYXJlIG5lc3RpbmcgZGVwdGggKDAsIDEsIDIsIC4uOSkgYW5kIHRoZQogICAgICAgICAgIHZhbHVlcyBhcmUgY291bnRzIG9mIHRoZSBudW1iZXIgb2YgcmV0dXJuIHN0YXRlbWVudHMgYXQgdGhhdCBsZXZlbC4gTmVzdGluZwogICAgICAgICAgIGxldmVsIGlzIGRlZW1lZCB0byBpbmNyZWFzZSB3aXRoIGRlZiwgaWYsIGZvciwgd2hpbGUsIHRyeSwgZXhjZXB0IGFuZCB3aXRoCiAgICAgICAgICAgc3RhdGVtZW50cy4KICAgICAgICAiIiIKICAgICAgICBjb3VudHMgPSB7aTogMCBmb3IgaSBpbiByYW5nZSgxMCl9CiAgICAgICAgZGVwdGggPSAwCiAgICAgICAgY2xhc3MgUmV0dXJuRmluZGVyKGFzdC5Ob2RlVmlzaXRvcik6CiAgICAgICAgICAgIGRlZiB2aXNpdF9ib2R5KHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgbm9ubG9jYWwgZGVwdGgKICAgICAgICAgICAgICAgIGRlcHRoICs9IDEKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICAgICAgZGVwdGggLT0gMQogICAgICAgICAgICBkZWYgdmlzaXRfRm9yKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgc2VsZi52aXNpdF9ib2R5KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9XaGlsZShzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIHNlbGYudmlzaXRfYm9keShub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfRnVuY3Rpb25EZWYoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBzZWxmLnZpc2l0X2JvZHkobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X0lmKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgc2VsZi52aXNpdF9ib2R5KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9Ucnkoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBzZWxmLnZpc2l0X2JvZHkobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X1RyeUV4Y2VwdChzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIHNlbGYudmlzaXRfYm9keShub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfVHJ5RmluYWxseShzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIHNlbGYudmlzaXRfYm9keShub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfRXhjZXB0SGFuZGxlcihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIHNlbGYudmlzaXRfYm9keShub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfV2l0aChzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIHNlbGYudmlzaXRfYm9keShub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfUmV0dXJuKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgbm9ubG9jYWwgZGVwdGgKICAgICAgICAgICAgICAgIGNvdW50c1tkZXB0aF0gKz0gMQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCgogICAgICAgIHZpc2l0b3IgPSBSZXR1cm5GaW5kZXIoKQogICAgICAgIHZpc2l0b3IudmlzaXQoc2VsZi50cmVlKQogICAgICAgIHJldHVybiBjb3VudHMKCgogICAgZGVmIGNvbnN0cnVjdHNfdXNlZChzZWxmKToKICAgICAgICAiIiJSZXR1cm4gYSBzZXQgb2YgYWxsIGNvbnN0cnVjdHMgZW5jb3VudGVyZWQgaW4gdGhlIHBhcnNlIHRyZWUiIiIKICAgICAgICBjb25zdHJ1Y3RzX3NlZW4gPSBzZXQoKQogICAgICAgIGNsYXNzIENvbnN0cnVjdEZpbmRlcihhc3QuTm9kZVZpc2l0b3IpOgogICAgICAgICAgICBkZWYgdmlzaXRfQXNzZXJ0KHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnYXNzZXJ0JykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfUmFpc2Uoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdyYWlzZScpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X0xhbWJkYShzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ2xhbWJkYScpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X0ltcG9ydChzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ2ltcG9ydCcpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X0ltcG9ydEZyb20oc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdpbXBvcnQnKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9Gb3Ioc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdmb3InKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9XaGlsZShzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ3doaWxlJykKICAgICAgICAgICAgICAgIGlmIG5vZGUub3JlbHNlOgogICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ3doaWxlX3dpdGhfZWxzZScpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X0NvbXByZWhlbnNpb24oc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdjb21wcmVoZW5zaW9uJykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfTGlzdENvbXAoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdsaXN0Y29tcHJlaGVuc2lvbicpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X1NldENvbXAoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdzZXRjb21wcmVoZW5zaW9uJykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfRGljdENvbXAoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdkaWN0Y29tcHJlaGVuc2lvbicpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X1NsaWNlKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnc2xpY2UnKQogICAgICAgICAgICBkZWYgdmlzaXRfSWYoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdpZicpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X0JyZWFrKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnYnJlYWsnKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9Db250aW51ZShzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ2NvbnRpbnVlJykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfVHJ5KHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgndHJ5JykKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKQogICAgICAgICAgICBkZWYgdmlzaXRfVHJ5RXhjZXB0KHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgndHJ5JykKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ2V4Y2VwdCcpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X1RyeUZpbmFsbHkoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCd0cnknKQogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnZmluYWxseScpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X0V4Y2VwdEhhbmRsZXIoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCdleGNlcHQnKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9XaXRoKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgnd2l0aCcpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X1lpZWxkKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgY29uc3RydWN0c19zZWVuLmFkZCgneWllbGQnKQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCiAgICAgICAgICAgIGRlZiB2aXNpdF9ZaWVsZEZyb20oc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RzX3NlZW4uYWRkKCd5aWVsZCcpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKICAgICAgICAgICAgZGVmIHZpc2l0X1JldHVybihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIGNvbnN0cnVjdHNfc2Vlbi5hZGQoJ3JldHVybicpCiAgICAgICAgICAgICAgICBzZWxmLmdlbmVyaWNfdmlzaXQobm9kZSkKCiAgICAgICAgdmlzaXRvciA9IENvbnN0cnVjdEZpbmRlcigpCiAgICAgICAgdmlzaXRvci52aXNpdChzZWxmLnRyZWUpCiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdHNfc2VlbgoKICAgIGRlZiBjaGVja190eXBlX2hpbnRzKHNlbGYpOgogICAgICAgICIiIlJldHVybiBhIGxpc3Qgb2YgdGhlIG5hbWVzIG9mIGZ1bmN0aW9ucyB0aGF0IGRvbid0IGhhdmUgZnVsbCB0eXBlIGhpbnRpbmcuIiIiCiAgICAgICAgdW5oaW50ZWQgPSBbXQogICAgICAgIGNsYXNzIE15VmlzaXRvcihhc3QuTm9kZVZpc2l0b3IpOgogICAgICAgICAgICBkZWYgdmlzaXRfRnVuY3Rpb25EZWYoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBpZiBub2RlLnJldHVybnMgaXMgTm9uZSBvciBhbnkoW2FyZy5hbm5vdGF0aW9uIGlzIE5vbmUgZm9yIGFyZyBpbiBub2RlLmFyZ3MuYXJnc10pOgogICAgICAgICAgICAgICAgICAgIHVuaGludGVkLmFwcGVuZChub2RlLm5hbWUpCgogICAgICAgIHZpc2l0b3IgPSBNeVZpc2l0b3IoKQogICAgICAgIHRyZWUgPSBzZWxmLnRyZWUKICAgICAgICB2aXNpdG9yLnZpc2l0KHNlbGYudHJlZSkKICAgICAgICByZXR1cm4gdW5oaW50ZWQKCiAgICBkZWYgZmluZF9mdW5jdGlvbl9jYWxscyhzZWxmLCBuYW1lKToKICAgICAgICAiIiJMb29rIGZvciBvY2N1cmFuY2VzIG9mIGEgc3BlY2lmaWMgZnVuY3Rpb24gY2FsbCIiIgogICAgICAgIHJldHVybiBzZWxmLmZpbmRfYWxsX2Z1bmN0aW9uX2NhbGxzKCkuZ2V0KG5hbWUsIFtdKQoKCiAgICBkZWYgZmluZF9pbGxlZ2FsX2Z1bmN0aW9ucyhzZWxmKToKICAgICAgICAiIiJGaW5kIGEgc2V0IG9mIGFsbCB0aGUgZnVuY3Rpb25zIHRoYXQgdGhlIHN0dWRlbnQgdXNlcwogICAgICAgICAgIHRoYXQgdGhleSBhcmUgbm90IGFsbG93ZWQgdG8gdXNlLiAiIiIKICAgICAgICBmdW5jX2NhbGxzID0gc2VsZi5maW5kX2FsbF9mdW5jdGlvbl9jYWxscygpCiAgICAgICAgcmV0dXJuIGZ1bmNfY2FsbHMua2V5cygpICYgc2V0KHNlbGYucGFyYW1zWydwcm9zY3JpYmVkZnVuY3Rpb25zJ10pCgoKICAgIGRlZiBmaW5kX21pc3NpbmdfcmVxdWlyZWRfZnVuY3Rpb25fY2FsbHMoc2VsZik6CiAgICAgICAgIiIiRmluZCBhIHNldCBvZiB0aGUgcmVxdWlyZWQgZnVuY3Rpb25zIHRoYXQgdGhlIHN0dWRlbnQgZmFpbHMgdG8gdXNlIiIiCiAgICAgICAgZnVuY19jYWxscyA9IHNlbGYuZmluZF9hbGxfZnVuY3Rpb25fY2FsbHMoKQogICAgICAgIHJldHVybiBzZXQoc2VsZi5wYXJhbXNbJ3JlcXVpcmVkZnVuY3Rpb25jYWxscyddKSAtIGZ1bmNfY2FsbHMua2V5cygpCgoKICAgIGRlZiBmaW5kX21pc3NpbmdfcmVxdWlyZWRfZnVuY3Rpb25fZGVmaW5pdGlvbnMoc2VsZik6CiAgICAgICAgIiIiRmluZCBhIHNldCBvZiByZXF1aXJlZCBmdW5jdGlvbnMgdGhhdCB0aGUgc3R1ZGVudCBmYWlscyB0byBkZWZpbmUiIiIKICAgICAgICBmdW5jX2RlZnMgPSBzZWxmLmZpbmRfZGVmaW5lZF9mdW5jdGlvbnMoKQogICAgICAgIHJldHVybiBzZXQoc2VsZi5wYXJhbXNbJ3JlcXVpcmVkZnVuY3Rpb25kZWZpbml0aW9ucyddKSAtIGZ1bmNfZGVmcwoKCiAgICBkZWYgZmluZF9pbGxlZ2FsX2NvbnN0cnVjdHMoc2VsZik6CiAgICAgICAgIiIiRmluZCBhbGwgdGhlIGNvbnN0cnVjdHMgdGhhdCB3ZXJlIHVzZWQgYnV0IG5vdCBhbGxvd2VkIiIiCiAgICAgICAgY29uc3RydWN0cyA9IHNlbGYuY29uc3RydWN0c191c2VkKCkKICAgICAgICByZXR1cm4gY29uc3RydWN0cyAmIHNldChzZWxmLnBhcmFtc1sncHJvc2NyaWJlZGNvbnN0cnVjdHMnXSkKCgogICAgZGVmIGZpbmRfbWlzc2luZ19yZXF1aXJlZF9jb25zdHJ1Y3RzKHNlbGYpOgogICAgICAgICIiIkZpbmQgd2hpY2ggb2YgdGhlIHJlcXVpcmVkIGNvbnN0cnVjdHMgd2VyZSBub3QgdXNlZCIiIgogICAgICAgIGNvbnN0cnVjdHMgPSBzZWxmLmNvbnN0cnVjdHNfdXNlZCgpCiAgICAgICAgcmV0dXJuIHNldChzZWxmLnBhcmFtc1sncmVxdWlyZWRjb25zdHJ1Y3RzJ10pIC0gY29uc3RydWN0cwoKCiAgICBkZWYgZmluZF90b29fbG9uZ19mdW5jcyhzZWxmLCBtYXhfbGVuZ3RoKToKICAgICAgICAiIiJSZXR1cm4gYSBsaXN0IG9mIHRoZSBmdW5jdGlvbnMgdGhhdCBleGNlZWQgdGhlIGdpdmVuIG1heF9sZW5ndGgKICAgICAgICAgICBFYWNoIGxpc3QgZWxlbWVudCBpcyBhIHR1cGxlIG9mIHRoZSBmdW5jdGlvbiBuYW1lIGFuZCB0aGUgbnVtYmVyIG9mIHN0YXRlbWVudHMKICAgICAgICAgICBpbiBpdHMgYm9keS4iIiIKCiAgICAgICAgYmFkX2Z1bmNzID0gW10KCiAgICAgICAgY2xhc3MgTXlWaXNpdG9yKGFzdC5Ob2RlVmlzaXRvcik6CgogICAgICAgICAgICBkZWYgdmlzaXRfRnVuY3Rpb25EZWYoc2VsZiwgbm9kZSk6CgogICAgICAgICAgICAgICAgZGVmIGNvdW50X3N0YXRlbWVudHMobm9kZSk6CiAgICAgICAgICAgICAgICAgICAgIiIiTnVtYmVyIG9mIHN0YXRlbWVudHMgaW4gdGhlIGdpdmVuIG5vZGUgYW5kIGl0cyBjaGlsZHJlbiIiIgogICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMQogICAgICAgICAgICAgICAgICAgIGlmIGlzaW5zdGFuY2Uobm9kZSwgYXN0LkV4cHIpIGFuZCBpc2luc3RhbmNlKG5vZGUudmFsdWUsIGFzdC5TdHIpOgogICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDAKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICBmb3IgYXR0ciBpbiBbJ2JvZHknLCAnb3JlbHNlJywgJ2ZpbmFsYm9keSddOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgaGFzYXR0cihub2RlLCBhdHRyKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IG5vZGUuX19kaWN0X19bYXR0cl0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCArPSBzdW0oY291bnRfc3RhdGVtZW50cyhjaGlsZCkgZm9yIGNoaWxkIGluIGNoaWxkcmVuKQogICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3VudAoKICAgICAgICAgICAgICAgIG51bV9zdGF0ZW1lbnRzID0gY291bnRfc3RhdGVtZW50cyhub2RlKSAtIDEgIyBEaXNyZWdhcmQgZGVmIGl0c2VsZgogICAgICAgICAgICAgICAgaWYgbnVtX3N0YXRlbWVudHMgPiBtYXhfbGVuZ3RoOgogICAgICAgICAgICAgICAgICAgIGJhZF9mdW5jcy5hcHBlbmQoKG5vZGUubmFtZSwgbnVtX3N0YXRlbWVudHMpKQoKICAgICAgICAgICAgZGVmIHZpc2l0X0FzeW5jRnVuY3Rpb25EZWYoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBzZWxmLnZpc2l0X0Z1bmN0aW9uRGVmKG5vZGUpCgogICAgICAgIHZpc2l0b3IgPSBNeVZpc2l0b3IoKQogICAgICAgIHZpc2l0b3IudmlzaXQoc2VsZi50cmVlKQogICAgICAgIHJldHVybiBiYWRfZnVuY3MKCgogICAgZGVmIGZpbmRfZ2xvYmFsX2NvZGUoc2VsZik6CiAgICAgICAgIiIiUmV0dXJuIGEgbGlzdCBvZiBlcnJvciBtZXNzYWdlcyByZWxhdGluZyB0byB0aGUgZXhpc3RlbmNlIG9mCiAgICAgICAgICAgYW55IGdsb2JhbCBhc3NpZ25tZW50LCBmb3IsIHdoaWxlIGFuZCBpZiBub2Rlcy4gSWdub3JlcwogICAgICAgICAgIGdsb2JhbCBhc3NpZ25tZW50IHN0YXRlbWVudHMgd2l0aCBhbiBBTExfQ0FQUyB0YXJnZXQgYW5kCiAgICAgICAgICAgaWYgX19uYW1lX18gPT0gIl9fbWFpbl9fIgogICAgICAgICIiIgogICAgICAgIHN0eWxlX2NoZWNrZXIgPSBzZWxmCiAgICAgICAgZ2xvYmFsX2Vycm9ycyA9IFtdCiAgICAgICAgY2xhc3MgTXlWaXNpdG9yKGFzdC5Ob2RlVmlzaXRvcik6CiAgICAgICAgICAgIGRlZiB2aXNpdF9Bc3NpZ24oc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBpZiBub2RlLmNvbF9vZmZzZXQgPT0gMDoKICAgICAgICAgICAgICAgICAgICBpZiBsZW4obm9kZS50YXJnZXRzKSA+IDEgb3IgaXNpbnN0YW5jZShub2RlLnRhcmdldHNbMF0sIGFzdC5UdXBsZSk6CiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbF9lcnJvcnMuYXBwZW5kKGYiTXVsdGlwbGUgdGFyZ2V0cyBpbiBnbG9iYWwgYXNzaWdubWVudCBzdGF0ZW1lbnQgYXQgbGluZSB7bm9kZS5saW5lbm99IikKICAgICAgICAgICAgICAgICAgICBlbGlmIG5vdCAobm9kZS50YXJnZXRzWzBdLmlkLmlzdXBwZXIoKSBvciBpc2luc3RhbmNlKG5vZGUudmFsdWUsIGFzdC5MYW1iZGEpKToKICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsX2Vycm9ycy5hcHBlbmQoZiJHbG9iYWwgYXNzaWdubWVudCBzdGF0ZW1lbnQgYXQgbGluZSB7bm9kZS5saW5lbm99IikKCiAgICAgICAgICAgIGRlZiB2aXNpdF9Gb3Ioc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBpZiBub2RlLmNvbF9vZmZzZXQgPT0gMDoKICAgICAgICAgICAgICAgICAgICBnbG9iYWxfZXJyb3JzLmFwcGVuZChmIkdsb2JhbCBmb3IgbG9vcCBhdCBsaW5lIHtub2RlLmxpbmVub30iKQoKICAgICAgICAgICAgZGVmIHZpc2l0X1doaWxlKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgaWYgbm9kZS5jb2xfb2Zmc2V0ID09IDA6CiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsX2Vycm9ycy5hcHBlbmQoZiJHbG9iYWwgd2hpbGUgbG9vcCBhdCBsaW5lIHtub2RlLmxpbmVub30iKQoKICAgICAgICAgICAgZGVmIHZpc2l0X0lmKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgaWYgbm9kZS5jb2xfb2Zmc2V0ID09IDAgYW5kIG5vdCBzdHlsZV9jaGVja2VyLmlzX21haW5fY2hlY2sobm9kZSk6CiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsX2Vycm9ycy5hcHBlbmQoZiJHbG9iYWwgaWYgc3RhdGVtZW50IGF0IGxpbmUge25vZGUubGluZW5vfSIpCgogICAgICAgIHZpc2l0b3IgPSBNeVZpc2l0b3IoKQogICAgICAgIHZpc2l0b3IudmlzaXQoc2VsZi50cmVlKQogICAgICAgIHJldHVybiBnbG9iYWxfZXJyb3JzCgoKICAgIGRlZiBmaW5kX3JlZGVmaW5pdGlvbnMoc2VsZik6CiAgICAgICAgIiIiQ2hlY2sgdGhlIGNvZGUgZm9yIGFueSBjYXNlcyB3aGVyZSBhIHZhcmlhYmxlIGhhcyB0aGUgc2FtZSBuYW1lIGFzIHRoZQogICAgICAgICAgIGZ1bmN0aW9uIGluIHdoaWNoIGl0IGlzIGJlaW5nIHVzZWQuCiAgICAgICAgIiIiCiAgICAgICAgcmVkZWZpbml0aW9ucyA9IFtdCiAgICAgICAgY2xhc3MgUmVkZWZpbml0aW9uQ2hlY2tlcihhc3QuTm9kZVZpc2l0b3IpOgogICAgICAgICAgICBkZWYgX19pbml0X18oc2VsZik6CiAgICAgICAgICAgICAgICBzZWxmLnNjb3BlcyA9IFtdCiAgICAgICAgICAgICAgICBzZWxmLmZ1bmN0aW9uX25hbWVzID0ge30gICMgTWFwIGZyb20gbmFtZSB0byBsaW5lIG51bWJlciBvZiBkZWYKCiAgICAgICAgICAgIGRlZiB2aXNpdF9GdW5jdGlvbkRlZihzZWxmLCBub2RlKToKICAgICAgICAgICAgICAgIHNlbGYuZnVuY3Rpb25fbmFtZXNbbm9kZS5uYW1lXSA9IG5vZGUubGluZW5vICAjIFJlY29yZCB0aGUgZnVuY3Rpb24gbmFtZSBhbmQgbGluZSBuby4KICAgICAgICAgICAgICAgIHNlbGYuc2NvcGVzLmFwcGVuZChzZXQoKSkKICAgICAgICAgICAgICAgIHNlbGYuZ2VuZXJpY192aXNpdChub2RlKSAgIyBWaXNpdCB0aGUgYm9keQogICAgICAgICAgICAgICAgc2VsZi5zY29wZXMucG9wKCkKCiAgICAgICAgICAgIGRlZiB2aXNpdF9Bc3NpZ24oc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBpZiBzZWxmLnNjb3BlczoKICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3Njb3BlID0gc2VsZi5zY29wZXNbLTFdCiAgICAgICAgICAgICAgICAgICAgZm9yIHRhcmdldCBpbiBub2RlLnRhcmdldHM6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UodGFyZ2V0LCBhc3QuTmFtZSk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiB0YXJnZXQuaWQgaW4gc2VsZi5mdW5jdGlvbl9uYW1lcyBhbmQgdGFyZ2V0LmlkIG5vdCBpbiBjdXJyZW50X3Njb3BlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZl9saW5lbnVtID0gc2VsZi5mdW5jdGlvbl9uYW1lc1t0YXJnZXQuaWRdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkZWZpbml0aW9ucy5hcHBlbmQoZiJTb3VyY2VGaWxlOnt0YXJnZXQubGluZW5vfTowIEZVTkNfUkVERUY6IFZhcmlhYmxlICd7dGFyZ2V0LmlkfScgaXMgdGhlIG5hbWUgb2YgYSBmdW5jdGlvbiBkZWZpbmVkIGF0IGxpbmUge2RlZl9saW5lbnVtfS4iKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9zY29wZS5hZGQodGFyZ2V0LmlkKSAjIFByZXZlbnQgcmVwZXRpdGlvbnMgb2YgdGhlIGVycm9yLgogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpCgogICAgICAgIHZpc2l0b3IgPSBSZWRlZmluaXRpb25DaGVja2VyKCkKICAgICAgICB2aXNpdG9yLnZpc2l0KHNlbGYudHJlZSkKICAgICAgICByZXR1cm4gcmVkZWZpbml0aW9ucwoKCgogICAgZGVmIGlzX21haW5fY2hlY2soc2VsZiwgbm9kZSk6CiAgICAgICAgIiIiUmV0dXJuIFRydWUgaWZmIHRoZSBnaXZlbiBub2RlIGlzIGEgY2hlY2sgaWYgdGhlIGN1cnJlbnQgbW9kdWxlIGlzICdfX21haW5fXycuCiAgICAgICAgICAgSnVzdCBjaGVja3MgaWYgYm90aCB0aGUgc3RyaW5ncyAnX19uYW1lX18nIGFuZCAnX19tYWluX18nIGFyZSBwcmVzZW50IGluIHRoZSBsaW5lLgogICAgICAgICIiIgogICAgICAgIGxpbmUgPSBzZWxmLnN0dWRlbnRfYW5zd2VyLnNwbGl0bGluZXMoKVtub2RlLmxpbmVubyAtIDFdCiAgICAgICAgcmV0dXJuICdfX21haW5fXycgaW4gbGluZSBhbmQgJ19fbmFtZV9fJyBpbiBsaW5lCgoKICAgIGRlZiBmaW5kX25lc3RlZF9mdW5jdGlvbnMoc2VsZik6CiAgICAgICAgIiIiUmV0dXJuIGEgbGlzdCBvZiBmdW5jdGlvbnMgdGhhdCBhcmUgZGVjbGFyZWQgd2l0aCBub24tZ2xvYmFsIHNjb3BlIiIiCiAgICAgICAgYmFkX2Z1bmNzID0gW10KCiAgICAgICAgY2xhc3MgTXlWaXNpdG9yKGFzdC5Ob2RlVmlzaXRvcik6CiAgICAgICAgICAgIGlzX3Zpc2l0aW5nX2Z1bmMgPSBGYWxzZQoKICAgICAgICAgICAgZGVmIHZpc2l0X0Z1bmN0aW9uRGVmKHNlbGYsIG5vZGUpOgogICAgICAgICAgICAgICAgaWYgc2VsZi5pc192aXNpdGluZ19mdW5jOgogICAgICAgICAgICAgICAgICAgIGJhZF9mdW5jcy5hcHBlbmQobm9kZS5uYW1lKQogICAgICAgICAgICAgICAgc2VsZi5pc192aXNpdGluZ19mdW5jID0gVHJ1ZQogICAgICAgICAgICAgICAgc2VsZi5nZW5lcmljX3Zpc2l0KG5vZGUpICMgVmlzaXQgYWxsIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5CiAgICAgICAgICAgICAgICBzZWxmLmlzX3Zpc2l0aW5nX2Z1bmMgPSBGYWxzZQoKICAgICAgICAgICAgZGVmIHZpc2l0X0FzeW5jRnVuY3Rpb25EZWYoc2VsZiwgbm9kZSk6CiAgICAgICAgICAgICAgICBzZWxmLnZpc2l0X0Z1bmN0aW9uRGVmKG5vZGUpCgogICAgICAgIHZpc2l0b3IgPSBNeVZpc2l0b3IoKQogICAgICAgIHZpc2l0b3IudmlzaXQoc2VsZi50cmVlKQogICAgICAgIHJldHVybiBiYWRfZnVuY3MKICAgIAoKICAgIGRlZiBmaW5kX25lc3RlZF9yZXR1cm5zKHNlbGYsIG1heF9kZXB0aCk6CiAgICAgICAgIiIiUmV0dXJuIGEgY291bnQgb2YgdGhlIG51bWJlciBvZiByZXR1cm4gc3RhdGVtZW50cwogICAgICAgICAgIGF0IGEgbmVzdGluZyBkZXB0aCBpbiBleGNlc3Mgb2YgbWF4X2RlcHRoLgogICAgICAgICIiIgogICAgICAgIHJldHVybnMgPSBzZWxmLm5lc3RlZF9yZXR1cm5zKCkKICAgICAgICByZXR1cm4gc3VtKHJldHVybnNbZGVwdGhdIGZvciBkZXB0aCBpbiByYW5nZShtYXhfZGVwdGggKyAxLCAxMCkpCg==</file>
<file name="__pytask.py" path="/" encoding="base64">IiIiIENvZGUgZm9yIGNvbXBpbGluZyAoTi9BKSBhbmQgcnVubmluZyBhIFB5dGhvbjMgdGFzay4KIiIiCmltcG9ydCBfX2xhbmd1YWdldGFzayBhcyBsYW5ndWFnZXRhc2sKaW1wb3J0IGlvCmltcG9ydCBzeXMKaW1wb3J0IHRyYWNlYmFjawppbXBvcnQgdHlwZXMKZnJvbSBtYXRoIGltcG9ydCBmbG9vcgppbXBvcnQgb3MKaW1wb3J0IHJlCmZyb20gX193YXRjaGRvZyBpbXBvcnQgV2F0Y2hkb2cKClNPVVJDRV9GSUxFTkFNRSA9ICdzdHVkZW50X2Fuc3dlci5weScKREVGQVVMVF9USU1FT1VUID0gMyAjIHNlY3MKREVGQVVMVF9NQVhPVVRQVVQgPSAxMDAwMDAgIyAxMDAga0IKCmNsYXNzIE91dE9mSW5wdXQoRXhjZXB0aW9uKToKICAgIHBhc3MKCmNsYXNzIEV4Y2Vzc2l2ZU91dHB1dChFeGNlcHRpb24pOgogICAgcGFzcwoKIyAobWN0KSBOZXcgZXhjZXB0aW9uIGZvciBoYW5kbGluZyBzaXR1YXRpb25zIHdoZXJlIHN1Ym1pdHRlZCBjb2RlIGRvZXMgc29tZXRoaW5nIGl0IHNob3VsZCBub3QuCmNsYXNzIEludmFsaWRBY3Rpb24oRXhjZXB0aW9uKToKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBlcnJvcl9tZXNzYWdlPScnKToKICAgICAgICBFeGNlcHRpb24uX19pbml0X18oc2VsZiwgZXJyb3JfbWVzc2FnZSkKCmRlZiBuYW1lX21hdGNoZXNfcmVzKG5hbWUsIHJlX3N0cmluZ3MpOgogICAgcmV0dXJuIGJvb2wocmUubWF0Y2goZiJeeyckfF4nLmpvaW4ocmVfc3RyaW5ncyl9JCIsIG5hbWUpKQoKY2xhc3MgQ29kZVRyYXAob2JqZWN0KToKICAgICIiIiBBIHNhZmUgbGl0dGxlIGNvbnRhaW5lciB0byBob2xkIHRoZSBzdHVkZW50J3MgY29kZSBhbmQgZ3JhYgogICAgICAgIGl0cyBvdXRwdXQsIHdoaWxlIGFsc28gcmVmb3JtYXR0aW5nIGV4Y2VwdGlvbnMgdG8gYmUgbmljZXIuCiAgICAiIiIKCiAgICBkZWYgX19pbml0X18oc2VsZiwgc3R1ZGVudF9jb2RlLCBwYXJhbXMsIHNlY29uZHNfcmVtYWluaW5nPU5vbmUpOgogICAgICAgIHNlbGYucGFyYW1zID0gcGFyYW1zCiAgICAgICAgaWYgJ3RpbWVvdXQnIG5vdCBpbiBwYXJhbXM6CiAgICAgICAgICAgIHNlbGYucGFyYW1zWyd0aW1lb3V0J10gPSBERUZBVUxUX1RJTUVPVVQKICAgICAgICBpZiAnbWF4b3V0cHV0Ynl0ZXMnIG5vdCBpbiBwYXJhbXM6CiAgICAgICAgICAgIHNlbGYucGFyYW1zWydtYXhvdXRwdXRieXRlcyddID0gREVGQVVMVF9NQVhPVVRQVVQKICAgICAgICBpZiAnZWNob3N0YW5kYXJkaW5wdXQnIG5vdCBpbiBwYXJhbXM6CiAgICAgICAgICAgIHNlbGYucGFyYW1zWydlY2hvc3RhbmRhcmRpbnB1dCddID0gVHJ1ZQogICAgICAgIHNlbGYucnVuX2NvZGUgPSBzdHVkZW50X2NvZGUKICAgICAgICBzZWxmLnNjb3BlZF9nbG9iYWxzID0gc2VsZi5fZ2V0X2dsb2JhbHMoKQoKICAgICAgICBpZiBzZWNvbmRzX3JlbWFpbmluZyBpcyBOb25lOgogICAgICAgICAgICBzZWxmLnNlY29uZHNfcmVtYWluaW5nID0gc2VsZi5wYXJhbXNbJ3RpbWVvdXQnXQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHNlbGYuc2Vjb25kc19yZW1haW5pbmcgPSBtaW4oc2Vjb25kc19yZW1haW5pbmcsIHNlbGYucGFyYW1zWyd0aW1lb3V0J10pCiAgICAgICAgQ29kZVRyYXAuTUFYX09VVFBVVF9DSEFSUyA9IDMwMDAwCiAgICAgICAgQ29kZVRyYXAub3V0cHV0X2NoYXJzID0gMCAgIyBDb3VudCBvZiBwcmludGVkIGNoYXJzIChtb3JlIG9yIGxlc3MpCgogICAgZGVmIF9nZXRfZ2xvYmFscyhzZWxmKToKICAgICAgICAiIiIgSGVyZSB3ZSBkZWZpbmUgYW55IGdsb2JhbHMgdGhhdCBtdXN0IGJlIGF2YWlsYWJsZSAiIiIKICAgICAgICAjIGNoYW5nZSB0aGUgZGVmYXVsdCBvcHRpb25zIGZvciAnb3BlbicuCiAgICAgICAgZ2xvYmFsIG5wICAjIE1heSBub3QgYWN0dWFsbHkgYmUgZGVmaW5lZCBidXQgd2UnbGwgY2hlY2sgc29vbgogICAgICAgIGRlZiBuZXdfb3BlbihmaWxlLCBtb2RlPSdyJywgYnVmZmVyaW5nPS0xLAogICAgICAgICAgICAgICAgICAgICBlbmNvZGluZz0ndXRmLTgnLCBlcnJvcnM9Tm9uZSwKICAgICAgICAgICAgICAgICAgICAgbmV3bGluZT1Ob25lLCBjbG9zZWZkPVRydWUsIG9wZW5lcj1Ob25lKToKICAgICAgICAgICAgCiAgICAgICAgICAgICMgKG1jdDYzKSBPbmx5IG9wZW4gYWxsb3dlZCBmaWxlcy4KICAgICAgICAgICAgaWYgKCdyZXN0cmljdGVkZmlsZXMnIGluIHNlbGYucGFyYW1zCiAgICAgICAgICAgICAgICAgICAgYW5kICgnb25seWFsbG93JyBub3QgaW4gc2VsZi5wYXJhbXNbJ3Jlc3RyaWN0ZWRmaWxlcyddIG9yIG5hbWVfbWF0Y2hlc19yZXMoZmlsZSwgc2VsZi5wYXJhbXNbJ3Jlc3RyaWN0ZWRmaWxlcyddWydvbmx5YWxsb3cnXSkpCiAgICAgICAgICAgICAgICAgICAgYW5kIG5vdCBuYW1lX21hdGNoZXNfcmVzKGZpbGUsIHNlbGYucGFyYW1zWydyZXN0cmljdGVkZmlsZXMnXS5nZXQoJ2Rpc2FsbG93JywgW10pKSk6CiAgICAgICAgICAgICAgICByZXR1cm4gb3BlbihmaWxlLCBtb2RlLCBidWZmZXJpbmcsIGVuY29kaW5nLCBlcnJvcnMsIG5ld2xpbmUsIGNsb3NlZmQsIG9wZW5lcikKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIHJhaXNlIEludmFsaWRBY3Rpb24oZiJZb3UgYXJlIG5vdCBhbGxvd2VkIHRvIG9wZW4gJ3tmaWxlfScuIikKICAgICAgICAgICAgICAgIAogICAgICAgICMgKG1jdDYzKSBGdW5jdGlvbiB0aGF0IGNyZWF0ZXMgc3R1YiBpbnZhbGlkIGZ1bmN0aW9uLgogICAgICAgIGRlZiBjcmVhdGVfaW52YWxpZF9mdW5jKG5hbWUpOgogICAgICAgICAgICBkZWYgaW52YWxpZF9mdW5jKCphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgICAgICByYWlzZSBJbnZhbGlkQWN0aW9uKGYiWW91IGFyZSBub3QgYWxsb3dlZCB0byB1c2UgJ3tuYW1lfSchIikKICAgICAgICAgICAgcmV0dXJuIGludmFsaWRfZnVuYwogICAgICAgIAogICAgICAgICMgKG1jdDYzKSBDaGVja3Mgd2hhdCBpcyBiZWluZyBpbXBvcnRlZCBhbmQgbWFrZXMgc3VyZSBpdCBpcyBhbGxvd2VkLiBJZiBpdCBpcyBub3QsIHRoZSB0aGluZyB0aGF0IAogICAgICAgICMgaXMgbm90IGFsbG93ZWQgaXMgcmVwbGFjZWQgYnkgYW4gJ2ludmFsaWQgZnVuY3Rpb24nLiBJZiBpdCBpcyBhbiBhdHRyaWJ1dGUgdGhlbiBpdCBpcyAKICAgICAgICAjIG5vdCBpbmNsdWRlZCBzaW5jZSBJIGNvdWxkIG5vdCB0aGluayBvZiBhIGJldHRlciB0aGluZyB0byBkby4gQ291bGQgbGV0IGl0IHJhaXNlCiAgICAgICAgIyAgJ0F0dHJpYnV0ZU5vdEZvdW5kJyBleGNlcHRpb24gYW5kIHRoZW4gY2hlY2sgaWYgdGhpcyB3YXMgY2F1c2VkIGZyb20gcmVtb3ZpbmcgdGhlIAogICAgICAgICMgYXR0cmlidXRlIGZyb20gdGhlIG1vZHVsZSBidXQgZ2l2ZW4gaG93IHVubGlrZWx5IHRoaXMgaXMgaXRzIG5vdCB3b3J0aCBpdCBhdCB0aGlzIHRpbWUuCiAgICAgICAgZGVmIG5ld19pbXBvcnQobmFtZSwgKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgbW9kdWxlID0gX19pbXBvcnRfXyhuYW1lLCAqYXJncywgKiprd2FyZ3MpCiAgICAgICAgICAgIHJlc3RyaWN0ZWRfbW9kdWxlID0gbW9kdWxlCiAgICAgICAgICAgIGlmICdyZXN0cmljdGVkbW9kdWxlcycgaW4gc2VsZi5wYXJhbXMgYW5kIG5hbWUgaW4gc2VsZi5wYXJhbXNbJ3Jlc3RyaWN0ZWRtb2R1bGVzJ106CiAgICAgICAgICAgICAgICBOZXdNb2R1bGVUeXBlID0gdHlwZSgnbW9kdWxlJywgKHR5cGVzLk1vZHVsZVR5cGUsKSwge30pCiAgICAgICAgICAgICAgICByZXN0cmljdGVkX21vZHVsZSA9IE5ld01vZHVsZVR5cGUobmFtZSkKICAgICAgICAgICAgICAgIGZvciB2YXIgaW4gZGlyKG1vZHVsZSk6CiAgICAgICAgICAgICAgICAgICAgaWYgKCgnb25seWFsbG93JyBub3QgaW4gc2VsZi5wYXJhbXNbJ3Jlc3RyaWN0ZWRtb2R1bGVzJ11bbmFtZV0gb3IKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVfbWF0Y2hlc19yZXModmFyLCBzZWxmLnBhcmFtc1sncmVzdHJpY3RlZG1vZHVsZXMnXVtuYW1lXVsnb25seWFsbG93J10pKSBhbmQKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBuYW1lX21hdGNoZXNfcmVzKHZhciwgc2VsZi5wYXJhbXNbJ3Jlc3RyaWN0ZWRtb2R1bGVzJ11bbmFtZV0uZ2V0KCdkaXNhbGxvdycsIFtdKSkpOgogICAgICAgICAgICAgICAgICAgICAgICBzZXRhdHRyKHJlc3RyaWN0ZWRfbW9kdWxlLCB2YXIsIGdldGF0dHIobW9kdWxlLCB2YXIpKQogICAgICAgICAgICAgICAgICAgIGVsaWYgY2FsbGFibGUoZ2V0YXR0cihtb2R1bGUsIHZhcikpOgogICAgICAgICAgICAgICAgICAgICAgICBzZXRhdHRyKHJlc3RyaWN0ZWRfbW9kdWxlLCB2YXIsIGNyZWF0ZV9pbnZhbGlkX2Z1bmMoZid7bmFtZX0ue3Zhcn0nKSkKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRhdHRyKE5ld01vZHVsZVR5cGUsIHZhciwgcHJvcGVydHkoY3JlYXRlX2ludmFsaWRfZnVuYyhmJ3tuYW1lfS57dmFyfScpKSkKICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0IFR5cGVFcnJvcjoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgU29tZSBhdHRyaWJ1dGVzIGNhbiBub3QgYmUgc2V0IHRvIGEgcHJvcGVydHkgc28gd2UgaWdub3JlIHRoZW0uCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZQoKICAgICAgICAgICAgcmV0dXJuIHJlc3RyaWN0ZWRfbW9kdWxlCgogICAgICAgICMgKG1jdDYzKSBJbnN1cmUgcHJpbnQgYWx3YXlzIHByaW50cyB0byB0aGUgcmVkaXJlY3RlZCBzdGRvdXQgYW5kIG5vdCBhY3R1YWwgc3Rkb3V0LgogICAgICAgICMgKHJqbDgzKSBBbHNvIGtlZXAgdHJhY2sgb2YgcHJpbnQgcXVhbnRpdHkgYW5kIHJhaXNlIEV4Y2Vzc2l2ZU91dHB1dCBpZiB0b28gbXVjaCBpcyBnZW5lcmF0ZWQuCiAgICAgICAgZGVmIG5ld19wcmludCgqdmFsdWVzLCBzZXA9JyAnLCBlbmQ9J1xuJywgZmlsZT1Ob25lLCBmbHVzaD1GYWxzZSk6CiAgICAgICAgICAgIGZvciB2YWx1ZSBpbiB2YWx1ZXM6CiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgQ29kZVRyYXAub3V0cHV0X2NoYXJzICs9IGxlbihzdHIodmFsdWUpKQogICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgaWYgQ29kZVRyYXAub3V0cHV0X2NoYXJzID4gc2VsZi5wYXJhbXNbJ21heG91dHB1dGJ5dGVzJ106CiAgICAgICAgICAgICAgICByYWlzZSBFeGNlc3NpdmVPdXRwdXQoKQogICAgICAgICAgICByZXR1cm4gcHJpbnQoKnZhbHVlcywgc2VwPXNlcCwgZW5kPWVuZCwgZmlsZT1zeXMuc3Rkb3V0KQogICAgICAgICAgICAKICAgICAgICAjIGZvcmNlICdpbnB1dCcgdG8gZWNobyB0byBzdGRpbiB0byBzdGRvdXQKICAgICAgICBpZiBzZWxmLnBhcmFtc1snZWNob3N0YW5kYXJkaW5wdXQnXToKICAgICAgICAgICAgZGVmIG5ld19pbnB1dChwcm9tcHQ9JycpOgogICAgICAgICAgICAgICAgIiIiIFJlcGxhY2UgdGhlIHN0YW5kYXJkIGlucHV0IHByb21wdCB3aXRoIGEgY2xldmVyZXIgb25lLiAiIiIKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICBzID0gaW5wdXQocHJvbXB0KQogICAgICAgICAgICAgICAgZXhjZXB0IEVPRkVycm9yOgogICAgICAgICAgICAgICAgICAgIHJhaXNlIE91dE9mSW5wdXQoKQogICAgICAgICAgICAgICAgcHJpbnQocykKICAgICAgICAgICAgICAgIHJldHVybiBzCiAgICAgICAgZWxzZToKICAgICAgICAgICAgbmV3X2lucHV0ID0gaW5wdXQKICAgICAgICAKICAgICAgICAjIChtY3Q2MykgQ3JlYXRlIGEgbmV3IGJ1aWx0aW5zIGRpY3Rpb25hcnksIHJlZGZpbmluZyBhbnkgZnVuY3Rpb25zIHRoYXQgYXJlIG5vdCBhbGxvd2VkLgogICAgICAgIG5ld19idWlsdGlucyA9IHtrZXk6dmFsdWUgZm9yIGtleSwgdmFsdWUgaW4gX19idWlsdGluc19fLml0ZW1zKCl9CiAgICAgICAgbmV3X2J1aWx0aW5zWydvcGVuJ10gPSBuZXdfb3BlbgogICAgICAgIG5ld19idWlsdGluc1snaW5wdXQnXSA9IG5ld19pbnB1dAogICAgICAgIG5ld19idWlsdGluc1sncHJpbnQnXSA9IG5ld19wcmludAogICAgICAgIG5ld19idWlsdGluc1snX19pbXBvcnRfXyddID0gbmV3X2ltcG9ydAoKICAgICAgICBpZiAncHJvc2NyaWJlZGJ1aWx0aW5zJyBpbiBzZWxmLnBhcmFtczoKICAgICAgICAgICAgZm9yIGZ1bmMgaW4gc2VsZi5wYXJhbXNbJ3Byb3NjcmliZWRidWlsdGlucyddOgogICAgICAgICAgICAgICAgbmV3X2J1aWx0aW5zW2Z1bmNdID0gY3JlYXRlX2ludmFsaWRfZnVuYyhmdW5jKQoKICAgICAgICAjIFRoaXMgd291bGQgYmUgbmljZSBidXQgaXQgY2FuIG1lc3Mgd2l0aCB0ZXN0aW5nIGNvZGUuCiAgICAgICAgIyBmb3IgZnVuYyBpbiBzZWxmLnBhcmFtc1sncHJvc2NyaWJlZGZ1bmN0aW9ucyddOgogICAgICAgICMgICAgICAgICBuZXdfYnVpbHRpbnNbZnVuY10gPSBjcmVhdGVfaW52YWxpZF9mdW5jKGZ1bmMpCiAgICAgICAgCiAgICAgICAgZ2xvYmFsX2RpY3QgPSB7CiAgICAgICAgICAgICdfX2J1aWx0aW5zX18nOiBuZXdfYnVpbHRpbnMsCiAgICAgICAgICAgICdfX25hbWVfXyc6ICdfX21haW5fXycKICAgICAgICB9CiAgICAgICAgaWYgJ3VzZXNudW1weScgaW4gc2VsZi5wYXJhbXMgYW5kIHNlbGYucGFyYW1zWyd1c2VzbnVtcHknXToKICAgICAgICAgICAgaW1wb3J0IG51bXB5IGFzIG5wCiAgICAgICAgICAgIGdsb2JhbF9kaWN0WyducCddID0gbnAKCiAgICAgICAgcmV0dXJuIGdsb2JhbF9kaWN0CgogICAgZGVmIF9fZW50ZXJfXyhzZWxmKToKICAgICAgICBpZiAnTVBMQ09ORklHRElSJyBub3QgaW4gb3MuZW52aXJvbiBvciBvcy5lbnZpcm9uWydNUExDT05GSUdESVInXS5zdGFydHN3aXRoKCcvaG9tZScpOgogICAgICAgICAgICBpbXBvcnQgdGVtcGZpbGUKICAgICAgICAgICAgb3MuZW52aXJvblsnTVBMQ09ORklHRElSJ10gPSB0ZW1wZmlsZS5ta2R0ZW1wKCkKICAgICAgICBzZWxmLm9sZF9zdGRvdXQgPSBzeXMuc3Rkb3V0CiAgICAgICAgc2VsZi5vbGRfc3RkZXJyID0gc3lzLnN0ZGVycgogICAgICAgIHNlbGYub2xkX3BhdGggPSBvcy5lbnZpcm9uWyJQQVRIIl0KICAgICAgICBzeXMuc3Rkb3V0ID0gaW8uU3RyaW5nSU8oKQogICAgICAgIHN5cy5zdGRlcnIgPSBpby5TdHJpbmdJTygpCiAgICAgICAgb3MuZW52aXJvblsiUEFUSCJdID0gJycgICAgICMgKG1jdDYzKSBHZXQgcmlkIG9mIFBBVEggdG8gbWFrZSBpdCBoYXJkZXIgdG8gZXhlY3V0ZSBjb21tYW5kcy4KICAgICAgICByZXR1cm4gc2VsZgoKICAgIGRlZiBfX2V4aXRfXyhzZWxmLCAqYXJncyk6CiAgICAgICAgc3lzLnN0ZG91dCA9IHNlbGYub2xkX3N0ZG91dAogICAgICAgIHN5cy5zdGRlcnIgPSBzZWxmLm9sZF9zdGRlcnIKICAgICAgICBvcy5lbnZpcm9uWyJQQVRIIl0gPSBzZWxmLm9sZF9wYXRoCgogICAgZGVmIGV4ZWMoc2VsZik6CiAgICAgICAgIiIiIFJ1biB0aGUgY29kZS4gT3V0cHV0IHRvIHN0ZG91dCBhbmQgc3RkZXJyIGlzIHN0b3JlZCBhbmQKICAgICAgICAgICAgcmV0dXJuZWQgb24gYSBjYWxsIHRvIHJlYWQKICAgICAgICAiIiIKICAgICAgICBpZiBzZWxmLnNlY29uZHNfcmVtYWluaW5nIDw9IDE6CiAgICAgICAgICAgIHByaW50KCJPdXQgb2YgdGltZS4gQWJvcnRlZC4iLCBmaWxlPXN5cy5zdGRlcnIpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgd2l0aCBXYXRjaGRvZyhzZWxmLnNlY29uZHNfcmVtYWluaW5nKToKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICBleGVjKHNlbGYucnVuX2NvZGUsIHNlbGYuc2NvcGVkX2dsb2JhbHMpCiAgICAgICAgICAgICAgICBleGNlcHQgT3V0T2ZJbnB1dDoKICAgICAgICAgICAgICAgICAgICBwcmludCgiJ2lucHV0JyBmdW5jdGlvbiBjYWxsZWQgd2hlbiBubyBpbnB1dCBkYXRhIGF2YWlsYWJsZS4iLAogICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU9c3lzLnN0ZGVycikKICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlc3NpdmVPdXRwdXQ6CiAgICAgICAgICAgICAgICAgICAgcHJpbnQoIkV4Y2Vzc2l2ZSBvdXRwdXQgLi4uIGpvYiBhYm9ydGVkIiwKICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlPXN5cy5zdGRlcnIpCiAgICAgICAgICAgICAgICBleGNlcHQgV2F0Y2hkb2c6CiAgICAgICAgICAgICAgICAgICAgcHJpbnQoIlRpbWUgbGltaXQgZXhjZWVkZWQiLCBmaWxlPXN5cy5zdGRlcnIpCiAgICAgICAgICAgICAgICAjIChtY3Q2MykgQ2F0Y2ggYW55IGludmFsaWQgYWN0aW9ucy4KICAgICAgICAgICAgICAgIGV4Y2VwdCBJbnZhbGlkQWN0aW9uIGFzIGU6CiAgICAgICAgICAgICAgICAgICAgcHJpbnQoZiJJbnZhbGlkIEFjdGlvbjoge2V9IiwgZmlsZT1zeXMuc3RkZXJyKQogICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgICAgICBldHlwZSwgdmFsdWUsIHRiID0gc3lzLmV4Y19pbmZvKCkKICAgICAgICAgICAgICAgICAgICB0Yl90dXBsZXMgPSB0cmFjZWJhY2suZXh0cmFjdF90Yih0YikKICAgICAgICAgICAgICAgICAgICBuZXdfdGIgPSBbXQogICAgICAgICAgICAgICAgICAgIGZvciBmaWxlbmFtZSwgbGluZW51bWJlciwgc2NvcGUsIHRleHQgaW4gdGJfdHVwbGVzOgogICAgICAgICAgICAgICAgICAgICAgICBpZiBmaWxlbmFtZSA9PSAiPHN0cmluZz4iOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld190Yi5hcHBlbmQoKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiX19zb3VyY2UucHkiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lbnVtYmVyLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ydW5fY29kZS5zcGxpdGxpbmVzKClbbGluZW51bWJlciAtIDFdLnN0cmlwKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKQogICAgICAgICAgICAgICAgICAgIHByaW50KCJUcmFjZWJhY2sgKG1vc3QgcmVjZW50IGNhbGwgbGFzdCk6IiwgZmlsZT1zeXMuc3RkZXJyKQogICAgICAgICAgICAgICAgICAgIHByaW50KCcnLmpvaW4odHJhY2ViYWNrLmZvcm1hdF9saXN0KG5ld190YikpLCBlbmQ9JycsIGZpbGU9c3lzLnN0ZGVycikKICAgICAgICAgICAgICAgICAgICBwcmludCh0cmFjZWJhY2suZm9ybWF0X2V4Y2VwdGlvbl9vbmx5KGV0eXBlLCB2YWx1ZSlbLTFdLCBlbmQ9JycsIGZpbGU9c3lzLnN0ZGVycikKICAgICAgICAgICAgICAgIGV4Y2VwdCBTeXN0ZW1FeGl0OgogICAgICAgICAgICAgICAgICAgIHByaW50KCJVbmV4cGVjdGVkIHRlcm1pbmF0aW9uOiBQbGVhc2UgZG8gbm90IGNhbGwgZXhpdCgpIG9yIHF1aXQoKS4iLAogICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU9c3lzLnN0ZGVycikKICAgICAgICAgICAgICAgIGV4Y2VwdCBLZXlib2FyZEludGVycnVwdDoKICAgICAgICAgICAgICAgICAgICBwcmludCgiS2V5Ym9hcmRJbnRlcnJ1cHQiLCBmaWxlPXN5cy5zdGRlcnIpCiAgICAgICAgICAgICAgICBleGNlcHQgR2VuZXJhdG9yRXhpdDoKICAgICAgICAgICAgICAgICAgICBwcmludCgiR2VuZXJhdG9yRXhpdCIsIGZpbGU9c3lzLnN0ZGVycikKCiAgICAgICAgICAgICAgICAjIChtY3Q2MykgTWlnaHQgYXMgd2VsbCBjYXRjaCB0aGUgYmFzZSBleGNlcHRpb24gaW4gY2FzZSBzb21ldGhpbmcgdmVyeSBzdHJhbmdlIGhhcHBlbnMuCiAgICAgICAgICAgICAgICAjIEZvciBleGFtcGxlIGludGVudGlvbmFsbHkgcmFpc2VpbmcgdGhlIEJhc2VFeGNlcHRpb24gdG8gdHJ5IGFuZCBza2lwIGFsbCBvZiB0aGlzLiAKICAgICAgICAgICAgICAgIGV4Y2VwdCBCYXNlRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgIHByaW50KCJDYXVnaHQgQmFzZUV4Y2VwdGlvbi4gWW91IGRpZCBzb21ldGhpbmcgdmVyeSBzdHJhbmdlIHRvIGdldCB0aGlzIG1lc3NhZ2UuIiwKICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlPXN5cy5zdGRlcnIpCgoKCiAgICBkZWYgcmVhZChzZWxmKToKICAgICAgICAiIiIgR2V0IHRoZSBvdXRwdXQgYW5kIGVycm9yIGZyb20gdGhlIGV4ZWMKICAgICAgICAiIiIKICAgICAgICByZXR1cm4gc3lzLnN0ZG91dC5nZXR2YWx1ZSgpLCBzeXMuc3RkZXJyLmdldHZhbHVlKCkKCgpjbGFzcyBQeVRhc2sobGFuZ3VhZ2V0YXNrLkxhbmd1YWdlVGFzayk6CiAgICAiIiJBIFB5VGFzayBtYW5hZ2VzIGNvbXBpbGluZyAoYWxtb3N0IGEgTk9QKSBhbmQgZXhlY3V0aW5nIG9mIGEgUHl0aG9uMyBwcm9ncmFtLgogICAgIiIiCiAgICBkZWYgX19pbml0X18oc2VsZiwgcGFyYW1zLCBjb2RlPU5vbmUpOgogICAgICAgICIiIkluaXRpYWxpc2F0aW9uIGlzIGRlbGVnYXRlZCB0byB0aGUgc3VwZXJjbGFzcy4KICAgICAgICAiIiIKICAgICAgICBzdXBlcigpLl9faW5pdF9fKHBhcmFtcywgY29kZSkKICAgICAgICBzZWxmLmV4ZWN1dGFibGVfYnVpbHQgPSBGYWxzZQoKICAgIGRlZiBjb21waWxlKHNlbGYsIG1ha2VfZXhlY3V0YWJsZT1GYWxzZSk6CiAgICAgICAgIiIiQSBOby1vcCBmb3IgUHl0aG9uLgogICAgICAgICIiIgogICAgICAgIHBhc3MKCiAgICBkZWYgZGlzY2FyZF9leGVjdXRhYmxlKHNlbGYpOgogICAgICAgICIiIkEgbm8tb3AgZm9yIHB5dGhvbiIiIgogICAgICAgIHBhc3MKCiAgICBkZWYgcnVuX2NvZGUoc2VsZiwgc3RhbmRhcmRfaW5wdXQ9Tm9uZSk6CiAgICAgICAgIiIiUnVuIGNvZGUgdXNpbmcgQWFyb24ncyBDb2RlVHJhcAogICAgICAgICIiIgogICAgICAgIHN5cy5zdGRpbiA9IGlvLlN0cmluZ0lPKHN0YW5kYXJkX2lucHV0KQogICAgICAgIHdpdGggQ29kZVRyYXAoc2VsZi5jb2RlLCBzZWxmLnBhcmFtcywgZmxvb3Ioc2VsZi5zZWNvbmRzX3JlbWFpbmluZygpKSkgYXMgcnVubmVyOgogICAgICAgICAgICBydW5uZXIuZXhlYygpCiAgICAgICAgICAgIG91dHB1dCwgZXJyb3IgPSBydW5uZXIucmVhZCgpCiAgICAgICAgc2VsZi5zdGRvdXQsIHNlbGYuc3RkZXJyID0gb3V0cHV0LCBlcnJvcgogICAgICAgIHJldHVybiBvdXRwdXQsIGVycm9yCgo=</file>
<file name="pytester.py" path="/" encoding="base64">IiIiVGhlIG1haW4gcHl0aG9uLXByb2dyYW0gdGVzdGluZyBjbGFzcyB0aGF0IGRvZXMgYWxsIHRoZSB3b3JrIC0gc3R5bGUgY2hlY2tzLAogICBydW4gYW5kIGdyYWRlLiBBIHN1YmNsYXNzIG9mIHRoZSBnZW5lcmljIHRlc3Rlci4KICAgU2luY2UgZWFjaCB0ZXN0IGNhbiBieSBydW4gd2l0aGluIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIFB5dGhvbiB1c2luZwogICBhbiBleGVjLCB3ZSBhdm9pZCB0aGUgdXN1YWwgY29tcGxpY2F0aW9uIG9mIGNvbWJpbmF0b3JzIGJ5IHJ1bm5pbmcKICAgZWFjaCB0ZXN0IHNlcGFyYXRlbHkgcmVnYXJkbGVzcyBvZiBwcmVzZW5jZSBvZiBzdGRpbiwgdGVzdGNvZGUsIGV0Yy4KIiIiCmltcG9ydCBfX3B5dGFzayBhcyBweXRhc2sKaW1wb3J0IHJlCmZyb20gX190ZXN0ZXIgaW1wb3J0IFRlc3Rlcgpmcm9tIF9fcHlzdHlsZWNoZWNrZXIgaW1wb3J0IFN0eWxlQ2hlY2tlcgpmcm9tIHJhbmRvbSBpbXBvcnQgcmFuZGludAoKCmNsYXNzIFB5VGVzdGVyKFRlc3Rlcik6CiAgICBkZWYgX19pbml0X18oc2VsZiwgcGFyYW1zLCB0ZXN0Y2FzZXMpOgogICAgICAgICIiIkluaXRpYWxpc2UgdGhlIGluc3RhbmNlLCBnaXZlbiB0aGUgdGVzdCBvZiB0ZW1wbGF0ZSBhbmQgZ2xvYmFsIHBhcmFtZXRlcnMgcGx1cwogICAgICAgICAgIGFsbCB0aGUgdGVzdGNhc2VzLiBQYXJhbWV0ZXJzIHJlbGV2YW50IHRvIHRoaXMgY2xhc3MgYXJlIGFsbCB0aG9zZSBsaXN0ZWQgZm9yIHRoZSBUZXN0ZXIgY2xhc3MgcGx1cwogICAgICAgICAgICAgICAnZXh0cmEnIHdoaWNoIHRha2VzIHRoZSB2YWx1ZXMgJ3ByZXRlc3QnIG9yICdwb3N0dGVzdCcgKHRoZSBvdGhlciBwb3NzaWJsZSB2YWx1ZSwgJ3N0ZGluJywgaGFzIGJlZW4KICAgICAgICAgICAgICAgaGFuZGxlZCBieSB0aGUgbWFpbiB0ZW1wbGF0ZSkuCiAgICAgICAgICAgQWRkaXRpb25hbGx5IHRoZSBzdXBwb3J0IGNsYXNzZXMgbGlrZSBzdHlsZWNoZWNrZXIgYW5kIHB5cGFyc2VyIG5lZWQgdGhlaXIKICAgICAgICAgICBvd24gcGFyYW1zIC0gcS52LgogICAgICAgICIiIgogICAgICAgIHN1cGVyKCkuX19pbml0X18ocGFyYW1zLCB0ZXN0Y2FzZXMpICAjIE1vc3Qgb2YgdGhlIHRhc2sgaXMgaGFuZGVkIGJ5IHRoZSBnZW5lcmljIHRlc3RlcgogICAgICAgIAogICAgICAgICMgSWYgdGhlIGV4dHJhIGZpZWxkIGlzIHNldCB0byBmaWxlcywgdGhlIGZpcnN0IGxpbmUgb2Ygc3RkaW4gbXVzdCBiZSBmaWxlbmFtZXMuCiAgICAgICAgIyBDcmVhdGUgYWxsIHJlcXVpcmVkIGZpbGVzLgogICAgICAgIGlmIHBhcmFtc1snZXh0cmEnXSA9PSAnZmlsZXMnOgogICAgICAgICAgICBpZiBub3QgcGFyYW1zWydJU19QUkVDSEVDSyddOgogICAgICAgICAgICAgICAgZm9yIHRlc3QgaW4gdGVzdGNhc2VzOgogICAgICAgICAgICAgICAgICAgIHN0ZGluX2xpbmVzID0gdGVzdC5zdGRpbi5zcGxpdGxpbmVzKCkKICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IHN0ZGluX2xpbmVzWzBdLnN0cmlwKCkgaWYgc3RkaW5fbGluZXMgZWxzZSAnJwogICAgICAgICAgICAgICAgICAgIGlmIGZpbGVuYW1lID09ICcnOgogICAgICAgICAgICAgICAgICAgICAgICByYWlzZSBFeGNlcHRpb24oJ1RoZSBmaXJzdCBsaW5lIG9mIHN0ZGluIG11c3QgYmUgdGhlIGZpbGVuYW1lJykKICAgICAgICAgICAgICAgICAgICBpZiBmaWxlbmFtZSBub3QgaW4gcGFyYW1zWydwcm90ZWN0ZWRmaWxlcyddOgogICAgICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4oZmlsZW5hbWUsICd3JykgYXMgb3V0ZmlsZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGZpbGUud3JpdGUodGVzdC5leHRyYS5yc3RyaXAoKSArICdcbicpCgogICAgICAgICMgUHktZGVwZW5kZW50IGF0dHJpYnV0ZXMKICAgICAgICBzZWxmLnRhc2sgPSBweXRhc2suUHlUYXNrKHBhcmFtcykKICAgICAgICBzZWxmLnByZWx1ZGUgPSAnJwoKICAgICAgICBpZiBwYXJhbXNbJ2lzZnVuY3Rpb24nXToKICAgICAgICAgICAgaWYgbm90IHNlbGYuaGFzX2RvY3N0cmluZygpOgogICAgICAgICAgICAgICAgc2VsZi5wcmVsdWRlID0gJyIiIkR1bW15IGRvY3N0cmluZyBmb3IgYSBmdW5jdGlvbiIiIlxuJwoKICAgICAgICBpZiBwYXJhbXNbJ3VzZXNtYXRwbG90bGliJ106CiAgICAgICAgICAgIHNlbGYucHJlbHVkZSArPSAnXG4nLmpvaW4oWwogICAgICAgICAgICAgICAgJ2ltcG9ydCBvcycsCiAgICAgICAgICAgICAgICAnaW1wb3J0IG1hdHBsb3RsaWIgYXMgX21wbCcsCiAgICAgICAgICAgICAgICAnX21wbC51c2UoIkFnZyIpJywKICAgICAgICAgICAgICAgICdmcm9tIF9fcGxvdHRvb2xzIGltcG9ydCBwcmludF9wbG90X2luZm8nLAogICAgICAgICAgICBdKSArICdcbicKICAgICAgICAgICAgc2VsZi5wYXJhbXNbJ3B5bGludG9wdGlvbnMnXS5hcHBlbmQoIi0tZGlzYWJsZT11bmdyb3VwZWQtaW1wb3J0cyIpCgogICAgICAgIGlmIHBhcmFtc1sndXNlc251bXB5J106CiAgICAgICAgICAgIHNlbGYucHJlbHVkZSArPSAgJ2ltcG9ydCBudW1weSBhcyBucFxuJwogICAgICAgICAgICBzZWxmLnBhcmFtc1sncHlsaW50b3B0aW9ucyddLmFwcGVuZCgiLS1kaXNhYmxlPXVudXNlZC1pbXBvcnQsdW5ncm91cGVkLWltcG9ydHMiKQogICAgICAgICAgICBzZWxmLnBhcmFtc1sncHlsaW50b3B0aW9ucyddLmFwcGVuZCgiLS1leHRlbnNpb24tcGtnLXdoaXRlbGlzdD1udW1weSIpCgogICAgICAgIGZvciBpbXBvcnRfc3RyaW5nIGluIHBhcmFtc1snaW1wb3J0cyddOgogICAgICAgICAgICBpZiAnICcgbm90IGluIGltcG9ydF9zdHJpbmc6CiAgICAgICAgICAgICAgICBzZWxmLnByZWx1ZGUgKz0gJ2ltcG9ydCAnICsgaW1wb3J0X3N0cmluZyArICdcbicKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIHNlbGYucHJlbHVkZSArPSBpbXBvcnRfc3RyaW5nICsgJ1xuJwoKICAgICAgICBpZiBwYXJhbXNbJ3ByZWx1ZGUnXSAhPSAnJzoKICAgICAgICAgICAgc2VsZi5wcmVsdWRlICs9ICdcbicgKyBwYXJhbXNbJ3ByZWx1ZGUnXS5yc3RyaXAoKSArICdcbicKCiAgICAgICAgdHJ5OgogICAgICAgICAgICB3aXRoIG9wZW4oJ19wcmVmaXgucHknKSBhcyBwcmVmaXg6CiAgICAgICAgICAgICAgICBwcmVmaXhfY29kZSA9IHByZWZpeC5yZWFkKCkKICAgICAgICAgICAgICAgIHNlbGYucHJlbHVkZSArPSBwcmVmaXhfY29kZS5yc3RyaXAoKSArICdcbicKCiAgICAgICAgZXhjZXB0IEZpbGVOb3RGb3VuZEVycm9yOgogICAgICAgICAgICBwYXNzCgogICAgICAgIHNlbGYucHJlbHVkZV9sZW5ndGggPSBsZW4oc2VsZi5wcmVsdWRlLnNwbGl0bGluZXMoKSkKICAgICAgICBpZiBzZWxmLmhhc19kb2NzdHJpbmcoKSBhbmQgc2VsZi5wcmVsdWRlX2xlbmd0aCA+IDA6CiAgICAgICAgICAgICMgSWYgd2UgaW5zZXJ0IHByZWx1ZGUgaW4gZnJvbnQgb2YgdGhlIGRvY3N0cmluZywgcHlsaW50IHdpbGwKICAgICAgICAgICAgIyBnaXZlIGEgbWlzc2luZyBkb2NzdHJpbmcgZXJyb3IuIE91ciBob3JyaWJsZSBoYWNrIHNvbHV0aW9uIGlzCiAgICAgICAgICAgICMgdG8gaW5zZXJ0IGFuIGV4dHJhIGRvY3N0cmluZyBhdCB0aGUgc3RhcnQgYW5kIHR1cm4gb2ZmIHRoZQogICAgICAgICAgICAjIHJlc3VsdGluZyAnc3RyaW5nIHN0YXRlbWVudCBoYXMgbm8gZWZmZWN0JyBlcnJvci4KICAgICAgICAgICAgc2VsZi5wcmVsdWRlID0gJyIiIkR1bW15IGRvY3N0cmluZyBmb3IgYSBmdW5jdGlvbiIiIlxuJyArIHNlbGYucHJlbHVkZQogICAgICAgICAgICBzZWxmLnByZWx1ZGVfbGVuZ3RoICs9IDEKICAgICAgICAgICAgc2VsZi5wYXJhbXNbJ3B5bGludG9wdGlvbnMnXS5hcHBlbmQoIi0tZGlzYWJsZT1XMDEwNSIpCiAgICAgICAgc2VsZi5zdHlsZV9jaGVja2VyID0gU3R5bGVDaGVja2VyKHNlbGYucHJlbHVkZSwgc2VsZi5wYXJhbXNbJ1NUVURFTlRfQU5TV0VSJ10sIHNlbGYucGFyYW1zKQoKICAgIGRlZiBoYXNfZG9jc3RyaW5nKHNlbGYpOgogICAgICAgICIiIlRydWUgaWYgdGhlIHN0dWRlbnQgYW5zd2VyIGhhcyBhIGRvY3N0cmluZywgd2hpY2ggbWVhbnMgdGhhdCwKICAgICAgICAgICB3aGVuIHN0cmlwcGVkLCBpdCBzdGFydHMgd2l0aCBhIHN0cmluZyBsaXRlcmFsLgogICAgICAgICIiIgogICAgICAgIHByb2cgPSBzZWxmLnBhcmFtc1snU1RVREVOVF9BTlNXRVInXS5sc3RyaXAoKQogICAgICAgIHJldHVybiBwcm9nLnN0YXJ0c3dpdGgoJyInKSBvciBwcm9nLnN0YXJ0c3dpdGgoIiciKQogICAgCgogICAgZGVmIHR3ZWFrZWRfd2FybmluZyhzZWxmLCBtZXNzYWdlKToKICAgICAgICAiIiJJbXByb3ZlIHRoZSB3YXJuaW5nIG1lc3NhZ2UgYnkgdXBkYXRpbmcgbGluZSBudW1iZXJzIGFuZCByZXBsYWNpbmcgPHN0cmluZz46IHdpdGggTGluZQogICAgICAgICIiIgogICAgICAgIHJldHVybiBzZWxmLmFkanVzdF9lcnJvcl9saW5lX251bXMobWVzc2FnZSkucmVwbGFjZSgnPHN0cmluZz46JywgJ0xpbmUgJykKICAgIAoKICAgIGRlZiBzdHlsZV9lcnJvcnMoc2VsZik6CiAgICAgICAgIiIiUmV0dXJuIGEgbGlzdCBvZiBhbGwgdGhlIHN0eWxlIGVycm9ycy4gU3RhcnQgd2l0aCBsb2NhbCB0ZXN0cyBhbmQgY29udGludWUgd2l0aCBweWxpbnQKICAgICAgICAgICBvbmx5IGlmIHRoZXJlIGFyZSBubyBsb2NhbCBlcnJvcnMuCiAgICAgICAgIiIiCiAgICAgICAgZXJyb3JzID0gW10KICAgICAgICBpZiBzZWxmLnBhcmFtcy5nZXQoJ2xvY2FscHJlY2hlY2tzJywgVHJ1ZSk6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGVycm9ycyArPSBzZWxmLnN0eWxlX2NoZWNrZXIubG9jYWxfZXJyb3JzKCkgIyBOb3RlOiBwcmVsdWRlIG5vdCBpbmNsdWRlZCBzbyBkb24ndCBhZGp1c3QgbGluZSBudW1zCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIGVycm9ycyArPSBbc3RyKGUpXQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgY2hlY2tfZm9yX3Bhc3NpdmUgPSAoc2VsZi5wYXJhbXNbJ3dhcm5pZnBhc3NpdmVvdXRwdXQnXSBhbmQgc2VsZi5wYXJhbXNbJ2lzZnVuY3Rpb24nXSkKICAgICAgICAgICAgICAgIGlmIGNoZWNrX2Zvcl9wYXNzaXZlOgogICAgICAgICAgICAgICAgICAgIHBhc3NpdmUgPSBzZWxmLnBhc3NpdmVfb3V0cHV0KCkKICAgICAgICAgICAgICAgICAgICB3YXJuaW5nX21lc3NhZ2VzID0gW2xpbmUgZm9yIGxpbmUgaW4gcGFzc2l2ZS5zcGxpdGxpbmVzKCkgaWYgJ1dhcm5pbmc6JyBpbiBsaW5lXQogICAgICAgICAgICAgICAgICAgIGlmIHdhcm5pbmdfbWVzc2FnZXM6CiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyArPSBbc2VsZi50d2Vha2VkX3dhcm5pbmcobWVzc2FnZSkgZm9yIG1lc3NhZ2UgaW4gd2FybmluZ19tZXNzYWdlc10KICAgICAgICAgICAgICAgICAgICBlbGlmIHBhc3NpdmU6CiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIllvdXIgY29kZSB3YXMgbm90IGV4cGVjdGVkIHRvIGdlbmVyYXRlIGFueSBvdXRwdXQgIiArCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIndoZW4gZXhlY3V0ZWQgc3RhbmQtYWxvbmUuXG5EaWQgeW91IGFjY2lkZW50YWxseSBpbmNsdWRlICIgKwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJ5b3VyIHRlc3QgY29kZT9cbk9yIHlvdSBtaWdodCBoYXZlIGEgd3JvbmcgaW1wb3J0IHN0YXRlbWVudCAtIGhhdmUgeW91IHRlc3RlZCBpbiBXaW5nPyIpCiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQocGFzc2l2ZSkKCiAgICAgICAgaWYgbGVuKGVycm9ycykgPT0gMCBvciBzZWxmLnBhcmFtcy5nZXQoJ2ZvcmNlcHlsaW50JywgRmFsc2UpOgogICAgICAgICAgICAjIFJ1biBwcmVjaGVja2VycyAocHlsaW50LCBteXB5KQogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAjIFN0eWxlLWNoZWNrIHRoZSBwcm9ncmFtIHdpdGhvdXQgYW55IHRlc3QgY2FzZXMgb3Igb3RoZXIgcG9zdGx1ZGUgYWRkZWQKICAgICAgICAgICAgICAgIGVycm9ycyArPSBzZWxmLnN0eWxlX2NoZWNrZXIuc3R5bGVfZXJyb3JzKCkKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAgICAgZXJyb3JfdGV4dCA9ICcqKiogVW5leHBlY3RlZCBlcnJvciB3aGlsZSBydW5uaW5nIHByZWNoZWNrZXJzLiBQbGVhc2UgcmVwb3J0ICoqKlxuJyArIHN0cihlKQogICAgICAgICAgICAgICAgZXJyb3JzICs9IFtlcnJvcl90ZXh0XQogICAgICAgICAgICBlcnJvcnMgPSBbc2VsZi5zaW1wbGlmeV9lcnJvcihzZWxmLmFkanVzdF9lcnJvcl9saW5lX251bXMoZXJyb3IpKSBmb3IgZXJyb3IgaW4gZXJyb3JzXQogICAgICAgICAgICBlcnJvcnMgPSBbZXJyb3IgZm9yIGVycm9yIGluIGVycm9ycyBpZiBub3QgZXJyb3Iuc3RhcnRzd2l0aCgnKioqKioqKioqKioqKiBNb2R1bGUnKV0KCiAgICAgICAgZXJyb3JzID0gW2Vycm9yLnJlcGxhY2UoJzx1bmtub3duPiwgJywgJycpIGZvciBlcnJvciBpbiBlcnJvcnNdICAjIEFub3RoZXIgZXJyb3IgdGlkeWluZyBvcGVyYXRpb24KICAgICAgICBpZiBlcnJvcnM6CiAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoIlxuU29ycnksIGJ1dCB5b3VyIGNvZGUgZG9lc24ndCBwYXNzIHRoZSBzdHlsZSBjaGVja3MuIikKICAgICAgICByZXR1cm4gZXJyb3JzCgogICAgZGVmIHByZXJ1bl9ob29rKHNlbGYpOgogICAgICAgICIiIkEgaG9vayBmb3Igc3ViY2xhc3NlcyB0byBkbyBpbml0aWFsIHNldHVwIG9yIGNvZGUgaGFja3MgZXRjCiAgICAgICAgICAgUmV0dXJucyBhIGxpc3Qgb2YgZXJyb3JzLCB0byB3aGljaCBvdGhlciBlcnJvcnMgYXJlIGFwcGVuZGVkLgogICAgICAgICAgIEluIHRoaXMgY2xhc3Mgd2UgdXNlIGl0IGZpcnN0bHkgdG8gY2hlY2sgdGhhdCB0aGUgbnVtYmVyIG9mIFByZWNoZWNrcwogICAgICAgICAgIGFsbG93ZWQgaGFzIG5vdCBiZWVuIGV4Y2VlZGVkIGFuZCB0aGVuLCBvZiBub3QsIHRvIHBlcmZvcm0KICAgICAgICAgICByZXF1aXJlZCBoYWNrcyB0byBkaXNhYmxlIGNhbGxzIHRvIG1haW4uIElmIHRoZSBjYWxsIHRvIG1haW5faGFja3MKICAgICAgICAgICBmYWlscywgYXNzdW1lIHRoZSBjb2RlIGlzIGJhZCBhbmQgd2lsbCBnZXQgZmxhZ2dlZCBieSBweWxpbnQgaW4gZHVlIGNvdXJzZS4KICAgICAgICAiIiIKICAgICAgICBzdGVwX2luZm8gPSBzZWxmLnBhcmFtc1snU1RFUF9JTkZPJ10KICAgICAgICBtYXhfcHJlY2hlY2tzID0gc2VsZi5wYXJhbXMuZ2V0KCdtYXhwcmVjaGVja3MnLCBOb25lKQogICAgICAgIGlmIG1heF9wcmVjaGVja3MgYW5kIHN0ZXBfaW5mb1snbnVtcHJlY2hlY2tzJ10gPj0gbWF4X3ByZWNoZWNrczoKICAgICAgICAgICAgcmV0dXJuIFtmIlNvcnJ5LCB5b3UgaGF2ZSByZWFjaGVkIHRoZSBsaW1pdCBvbiBhbGxvd2VkIHByZWNoZWNrcyAoe21heF9wcmVjaGVja3N9KSBmb3IgdGhpcyBxdWVzdGlvbi4iXQogICAgICAgIAogICAgICAgIHRyeToKICAgICAgICAgICAgcmV0dXJuIHNlbGYubWFpbl9oYWNrcygpCiAgICAgICAgZXhjZXB0OgogICAgICAgICAgICByZXR1cm4gW10KCiAgICBkZWYgcGFzc2l2ZV9vdXRwdXQoc2VsZik6CiAgICAgICAgIiIiIFJldHVybiB0aGUgcGFzc2l2ZSBvdXRwdXQgZnJvbSB0aGUgc3R1ZGVudCBhbnN3ZXIgY29kZQogICAgICAgICAgICBUaGlzIGlzIGVzc2VudGlhbGx5IGEgImRyeSBydW4iIG9mIHRoZSBjb2RlLgogICAgICAgICIiIgogICAgICAgIGNvZGUgPSBzZWxmLnByZWx1ZGUgKyBzZWxmLnBhcmFtc1snU1RVREVOVF9BTlNXRVInXQogICAgICAgIGlmIHNlbGYucGFyYW1zWyd1c2VzbWF0cGxvdGxpYiddOgogICAgICAgICAgICBjb2RlICs9ICdcbicuam9pbihbCiAgICAgICAgICAgICAgICAnZmlncyA9IF9tcGwucHlwbG90LmdldF9maWdudW1zKCknLAogICAgICAgICAgICAgICAgJ2lmIGZpZ3M6JywKICAgICAgICAgICAgICAgICcgICAgcHJpbnQoZiJ7bGVuKGZpZ3MpfSBmaWd1cmVzIGZvdW5kIiknLAogICAgICAgICAgICAgICAgJyAgICBwcmludChmIntfbXBsLnB5cGxvdC5nZXRfZmlnbGFiZWxzKCl9IiknCiAgICAgICAgICAgIF0pICsgJ1xuJwogICAgICAgIHRhc2sgPSBweXRhc2suUHlUYXNrKHNlbGYucGFyYW1zLCBjb2RlKQogICAgICAgIHdpdGggb3BlbihmIldURntyYW5kaW50KDAsMTAwKX0ucHkiLCAndycpIGFzIG91dGZpbGU6CiAgICAgICAgICAgIG91dGZpbGUud3JpdGUoY29kZSkKICAgICAgICB0YXNrLmNvbXBpbGUoKQogICAgICAgIGNhcHR1cmVkX291dHB1dCwgY2FwdHVyZWRfZXJyb3IgPSB0YXNrLnJ1bl9jb2RlKCkKICAgICAgICByZXR1cm4gKGNhcHR1cmVkX291dHB1dCArICdcbicgKyBjYXB0dXJlZF9lcnJvcikuc3RyaXAoKQoKICAgIGRlZiBtYWtlX3Rlc3RfcG9zdGx1ZGUoc2VsZiwgdGVzdGNhc2VzKToKICAgICAgICAiIiJSZXR1cm4gdGhlIGNvZGUgdGhhdCBmb2xsb3dzIHRoZSBzdHVkZW50IGFuc3dlciBjb250YWluaW5nIGFsbCB0aGUgdGVzdGNvZGUKICAgICAgICAgICBmcm9tIHRoZSBnaXZlbiBsaXN0IG9mIHRlc3RjYXNlcywgd2hpY2ggc2hvdWxkIGFsd2F5cyBiZSBvZiBsZW5ndGggMQogICAgICAgICAgIChiZWNhdXNlIHdlIGRvbid0IGJvdGhlciB0cnlpbmcgdG8gY29tYmluZSBhbGwgdGhlIHRlc3RzIGludG8gYQogICAgICAgICAgIHNpbmdsZSBydW4gaW4gUHl0aG9uKQogICAgICAgICIiIgogICAgICAgIGFzc2VydCBsZW4odGVzdGNhc2VzKSA9PSAxCiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ25vdGVzdCddOgogICAgICAgICAgICByZXR1cm4gJycKICAgICAgICB0ZXN0ID0gdGVzdGNhc2VzWzBdCiAgICAgICAgdGVzdGVyID0gJycKICAgICAgICBpZiBzZWxmLnBhcmFtc1snZ2xvYmFsZXh0cmEnXSBhbmQgc2VsZi5wYXJhbXNbJ2dsb2JhbGV4dHJhJ10gPT0gJ3ByZXRlc3QnOgogICAgICAgICAgICB0ZXN0ZXIgKz0gc2VsZi5wYXJhbXNbJ0dMT0JBTF9FWFRSQSddICsgJ1xuJwogICAgICAgIGlmIHRlc3QuZXh0cmEgYW5kIHNlbGYucGFyYW1zWydleHRyYSddID09ICdwcmV0ZXN0JzoKICAgICAgICAgICAgdGVzdGVyICs9IHRlc3QuZXh0cmEgKyAnXG4nCiAgICAgICAgaWYgdGVzdC50ZXN0Y29kZToKICAgICAgICAgICAgdGVzdGVyICs9IHRlc3QudGVzdGNvZGUucnN0cmlwKCkgKyAnXG4nCiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ2dsb2JhbGV4dHJhJ10gYW5kIHNlbGYucGFyYW1zWydnbG9iYWxleHRyYSddID09ICdwb3N0dGVzdCc6CiAgICAgICAgICAgIHRlc3RlciArPSBzZWxmLnBhcmFtc1snR0xPQkFMX0VYVFJBJ10gKyAnXG4nCiAgICAgICAgaWYgdGVzdC5leHRyYSBhbmQgc2VsZi5wYXJhbXNbJ2V4dHJhJ10gPT0gJ3Bvc3R0ZXN0JzoKICAgICAgICAgICAgdGVzdGVyICs9IHRlc3QuZXh0cmEgKyAnXG4nCgogICAgICAgIGlmIHNlbGYucGFyYW1zWyd1c2VzbWF0cGxvdGxpYiddOgogICAgICAgICAgICBpZiAnZHBpJyBpbiBzZWxmLnBhcmFtcyBhbmQgc2VsZi5wYXJhbXNbJ2RwaSddOgogICAgICAgICAgICAgICAgZXh0cmEgPSBmIiwgZHBpPXtzZWxmLnBhcmFtc1snZHBpJ119IgogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgZXh0cmEgPSAnJwogICAgICAgICAgICBpZiBzZWxmLnBhcmFtcy5nZXQoJ3J1bm5pbmdfc2FtcGxlX2Fuc3dlcicsIEZhbHNlKToKICAgICAgICAgICAgICAgIGNvbHVtbiA9ICdFeHBlY3RlZCcKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGNvbHVtbiA9ICdHb3QnCiAgICAgICAgICAgIHRlc3RfbnVtID0gbGVuKHNlbGYucmVzdWx0X3RhYmxlLnRhYmxlKSAtIDEgICMgMC1vcmlnaW4gdGVzdCBudW1iZXIgZnJvbSByZXN1bHQgdGFibGUKICAgICAgICAgICAgdGVzdGVyICs9ICdcbicuam9pbihbCiAgICAgICAgICAgICAgICAnZmlncyA9IF9tcGwucHlwbG90LmdldF9maWdudW1zKCknLAogICAgICAgICAgICAgICAgJ2ZvciBmaWcgaW4gZmlnczonLAogICAgICAgICAgICAgICAgJyAgICBfbXBsLnB5cGxvdC5maWd1cmUoZmlnKScsCiAgICAgICAgICAgICAgICAnICAgIHJvdyA9IHt9Jy5mb3JtYXQodGVzdF9udW0pLAogICAgICAgICAgICAgICAgJyAgICBjb2x1bW4gPSAie30iJy5mb3JtYXQoY29sdW1uKSwKICAgICAgICAgICAgICAgICcgICAgX21wbC5weXBsb3Quc2F2ZWZpZygiX2ltYWdle30ue30ue30ucG5nIi5mb3JtYXQoZmlnLCBjb2x1bW4sIHJvdyksIGJib3hfaW5jaGVzPSJ0aWdodCInICsgJ3t9KScuZm9ybWF0KGV4dHJhKSwKICAgICAgICAgICAgICAgICcgICAgX21wbC5weXBsb3QuY2xvc2UoZmlnKScKICAgICAgICAgICAgXSkgKyAnXG4nCiAgICAgICAgcmV0dXJuIHRlc3RlcgoKICAgIGRlZiBzaW5nbGVfcHJvZ3JhbV9idWlsZF9wb3NzaWJsZShzZWxmKToKICAgICAgICAiIiJXZSBhdm9pZCBhbGwgdGhlIGNvbXBsaWNhdGlvbiBvZiB0cnlpbmcgdG8gcnVuIGFsbCB0ZXN0cyBpbgogICAgICAgICAgIGEgc2luZ2xlIHN1YnByb2Nlc3MgcnVuIGJ5IHVzaW5nIGV4ZWMgdG8gcnVuIGVhY2ggdGVzdCBzaW5nbHkuCiAgICAgICAgIiIiCiAgICAgICAgcmV0dXJuIEZhbHNlCgogICAgZGVmIGFkanVzdF9lcnJvcl9saW5lX251bXMoc2VsZiwgZXJyb3IpOgogICAgICAgICIiIlN1YnRyYWN0IHRoZSBwcmVsdWRlIGxlbmd0aCBvZiBhbGwgbGluZSBudW1iZXJzIGluIHRoZSBnaXZlbiBlcnJvciBtZXNzYWdlCiAgICAgICAgIiIiCiAgICAgICAgZXJyb3JfcGF0dGVybnMgPSBbCiAgICAgICAgICAgICAgICAocicoLio8ZnN0cmluZz4uKiBcKHN5bnRheC1lcnJvclwpLiopJywgW10pLAogICAgICAgICAgICAgICAgKHInKC4qRmlsZSAiLioiLCBsaW5lICspKFxkKykoLCBpbiAuKiknLCBbMl0pLAogICAgICAgICAgICAgICAgKHInKC4qOiAqKShcZCspKCwgKlxkKzouKlwoLipsaW5lICspKFxkKykoXCkuKiknLCBbMiwgNF0pLAogICAgICAgICAgICAgICAgKHInKC4qOiAqKShcZCspKCwgKlxkKzouKlwoLipcKS4qKScsIFsyXSksCiAgICAgICAgICAgICAgICAocicoLio6KShcZCspKDpcZCs6IFtBLVpdXGQrOiAuKmxpbmUgKShcZCspKC4qKScsIFsyLCA0XSksCiAgICAgICAgICAgICAgICAocicoLio6KShcZCspKDpcZCs6IFtBLVpdXGQrOiAuKiknLCBbMl0pLAogICAgICAgICAgICAgICAgKHInKC4qOikoXGQrKSg6IFthLXpBLVpdKldhcm5pbmcuKiknLCBbMl0pLAogICAgICAgIF0KICAgICAgICBvdXRwdXRfbGluZXMgPSBbXQogICAgICAgIGZvciBsaW5lIGluIGVycm9yLnNwbGl0bGluZXMoKToKICAgICAgICAgICAgZm9yIHBhdHRlcm4sIGxpbmVfZ3JvdXBfbnVtcyBpbiBlcnJvcl9wYXR0ZXJuczoKICAgICAgICAgICAgICAgIG1hdGNoID0gcmUubWF0Y2gocGF0dGVybiwgbGluZSkKICAgICAgICAgICAgICAgIGlmIG1hdGNoOgogICAgICAgICAgICAgICAgICAgIGxpbmUgPSAnJwogICAgICAgICAgICAgICAgICAgIGZvciBpLCBncm91cCBpbiBlbnVtZXJhdGUobWF0Y2guZ3JvdXBzKCksIDEpOgogICAgICAgICAgICAgICAgICAgICAgICBpZiBpIGluIGxpbmVfZ3JvdXBfbnVtczoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVudW0gPSBpbnQobWF0Y2guZ3JvdXAoaSkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZCA9IGxpbmVudW0gLSBzZWxmLnByZWx1ZGVfbGVuZ3RoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lICs9IHN0cihhZGp1c3RlZCkKICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgKz0gZ3JvdXAKICAgICAgICAgICAgICAgICAgICBicmVhawoKICAgICAgICAgICAgb3V0cHV0X2xpbmVzLmFwcGVuZChsaW5lKQogICAgICAgIHJldHVybiAnXG4nLmpvaW4ob3V0cHV0X2xpbmVzKQoKICAgIGRlZiBzaW1wbGlmeV9lcnJvcihzZWxmLCBlcnJvcik6CiAgICAgICAgIiIiUmV0dXJuIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIGEgcHlsaW50IGVycm9yIHdpdGggTGluZSA8bj4gaW5zZXJ0ZWQgaW4KICAgICAgICAgICBsaWV1IG9mIF9fc291cmNlLnB5OjxuPjxwPjogWG5ubm4KICAgICAgICAiIiIKICAgICAgICBwYXR0ZXJuID0gcidfP18/c291cmNlLnB5OihcZCspOiAqXGQrOiAqW0EtWl1cZCs6ICguKiknCiAgICAgICAgbWF0Y2ggPSByZS5tYXRjaChwYXR0ZXJuLCBlcnJvcikKICAgICAgICBpZiBtYXRjaDoKICAgICAgICAgICAgcmV0dXJuIGYiTGluZSB7bWF0Y2guZ3JvdXAoMSl9OiB7bWF0Y2guZ3JvdXAoMil9IgogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHJldHVybiBlcnJvcgoKICAgIGRlZiBtYWluX2hhY2tzKHNlbGYpOgogICAgICAgICIiIk1vZGlmeSB0aGUgY29kZSB0byBiZSB0ZXN0ZWQgaWYgcGFyYW1zIHN0cmlwbWFpbiBvciBzdHJpcG1haW5pZnByZXNlbnQnCiAgICAgICAgICAgYXJlIHNwZWNpZmllZC4gUmV0dXJucyBhIGxpc3Qgb2YgZXJyb3JzIGVuY291bnRlcmVkIHdoaWxlIHNvIGRvaW5nLgogICAgICAgICIiIgogICAgICAgIGVycm9ycyA9IFtdCiAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ3N0cmlwbWFpbiddIG9yIHNlbGYucGFyYW1zWydzdHJpcG1haW5pZnByZXNlbnQnXToKICAgICAgICAgICAgbWFpbl9jYWxscyA9IHNlbGYuc3R5bGVfY2hlY2tlci5maW5kX2Z1bmN0aW9uX2NhbGxzKCdtYWluJykKICAgICAgICAgICAgaWYgc2VsZi5wYXJhbXNbJ3N0cmlwbWFpbiddIGFuZCBtYWluX2NhbGxzID09IFtdOgogICAgICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgiTm8gY2FsbCB0byBtYWluKCkgZm91bmQiKQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgc3R1ZGVudF9saW5lcyA9IHNlbGYuc3R1ZGVudF9hbnN3ZXIuc3BsaXQoJ1xuJykKICAgICAgICAgICAgICAgIGZvciAobGluZSwgZGVwdGgpIGluIG1haW5fY2FsbHM6CiAgICAgICAgICAgICAgICAgICAgaWYgZGVwdGggPT0gMDoKICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsID0gc3R1ZGVudF9saW5lc1tsaW5lXQogICAgICAgICAgICAgICAgICAgICAgICBpZiBub3QgcmUubWF0Y2gocicgKm1haW5cKFwpJywgbWFpbl9jYWxsKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5hcHBlbmQoZiJJbGxlZ2FsIGNhbGwgdG8gbWFpbigpLlxuIiArCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIm1haW4gc2hvdWxkIG5vdCB0YWtlIGFueSBwYXJhbWV0ZXJzIGFuZCBzaG91bGQgbm90IHJldHVybiBhbnl0aGluZy4iKQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R1ZGVudF9saW5lc1tsaW5lXSA9IG1haW5fY2FsbC5yZXBsYWNlKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAibWFpbiIsICJwYXNzICAgIyBEaXNhYmxlZCBjYWxsIHRvIG1haW4iKQogICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgIHN0dWRlbnRfbGluZXNbbGluZV0gKz0gIiAgIyBXZSd2ZSBsZXQgeW91IGNhbGwgbWFpbiBoZXJlLiIKICAgICAgICAgICAgICAgIHNlbGYucGFyYW1zWydTVFVERU5UX0FOU1dFUiddID0gc2VsZi5zdHVkZW50X2Fuc3dlciA9ICdcbicuam9pbihzdHVkZW50X2xpbmVzKSArICdcbicKCiAgICAgICAgcmV0dXJuIGVycm9ycwo=</file>
<file name="__resulttable.py" path="/" encoding="base64">IiIiQ29kZSBmb3IgYnVpbGRpbmcgYW5kIG1hbmFnaW5nIHRoZSByZXN1bHQgdGFibGUgZm9yIHRoZSB0ZXN0cy4KICAgVGhlIHJlc3VsdCB0YWJsZSBpdHNlbGYgKHRoZSAndGFibGUnIGZpZWxkIG9mIGFuIG9iamVjdCBvZiB0aGlzIGNsYXNzKQogICAgaXMgYSBsaXN0IG9mIGxpc3RzIG9mIHN0cmluZ3MuIFRoZSBmaXJzdCByb3cgaXMgdGhlIGhlYWRlciByb3cuCiAgIENvbHVtbnMgYXJlICJUZXN0IiwgIklucHV0IiAob3B0aW9uYWwpLCAiRXhwZWN0ZWQiLCAiR290IiwgImlzY29ycmVjdCIsICJpc2hpZGRlbiIKIiIiCmltcG9ydCBodG1sCmltcG9ydCByZQppbXBvcnQgYmFzZTY0CmZyb20gY29sbGVjdGlvbnMgaW1wb3J0IGRlZmF1bHRkaWN0CmZyb20gdXJsbGliLnBhcnNlIGltcG9ydCBxdW90ZQoKTUFYX1NUUklOR19MRU5HVEggPSA0MDAwICAjIDRrIGlzIGRlZmF1bHQgbWF4aW11bSBzdHJpbmcgbGVuZ3RoCgoKY2xhc3MgUmVzdWx0VGFibGU6CiAgICBkZWYgX19pbml0X18oc2VsZiwgcGFyYW1zKToKICAgICAgICBzZWxmLnBhcmFtcyA9IHBhcmFtcwogICAgICAgIHNlbGYubWFyayA9IDAKICAgICAgICBzZWxmLm1heF9tYXJrID0gMAogICAgICAgIHNlbGYudGFibGUgPSBOb25lCiAgICAgICAgc2VsZi5mYWlsZWRfaGlkZGVuID0gRmFsc2UKICAgICAgICBzZWxmLmFib3J0ZWQgPSBGYWxzZQogICAgICAgIHNlbGYuaGFzX3N0ZGlucyA9IEZhbHNlCiAgICAgICAgc2VsZi5oYXNfdGVzdHMgPSBGYWxzZQogICAgICAgIHNlbGYuaGFzX2V4dHJhID0gRmFsc2UKICAgICAgICBzZWxmLmhhc19leHBlY3RlZCA9IEZhbHNlCiAgICAgICAgc2VsZi5oYXNfZ290ID0gRmFsc2UKICAgICAgICBzZWxmLmhpZGluZyA9IEZhbHNlCiAgICAgICAgc2VsZi5udW1fZmFpbGVkX3Rlc3RzID0gMAogICAgICAgIHNlbGYubnVtX2ZhaWxlZF9oaWRkZW5fdGVzdHMgPSAwCiAgICAgICAgc2VsZi5taXNzaW5nX3Rlc3RzID0gMAogICAgICAgIHNlbGYuZ2xvYmFsX2Vycm9yID0gJycKICAgICAgICBzZWxmLmNvbHVtbl9mb3JtYXRzID0ge30gICMgTWFwIGZyb20gcmF3IGNvbHVtbiBuYW1lIHRvIGZvcm1hdAogICAgICAgIHNlbGYuY29sdW1uX2Zvcm1hdHNfYnlfaGRyID0ge30gICMgTWFwIGZyb20gaGVhZGVyIG5hbWUgdG8gZm9ybWF0CiAgICAgICAgc2VsZi5pbWFnZXMgPSBkZWZhdWx0ZGljdChsaXN0KQogICAgICAgIGRlZmF1bHRfcGFyYW1zID0gewogICAgICAgICAgICAnc3RkaW5mcm9tZXh0cmEnOiBGYWxzZSwKICAgICAgICAgICAgJ3N0cmljdHdoaXRlc3BhY2UnOiBUcnVlLAogICAgICAgICAgICAnZmxvYXR0b2xlcmFuY2UnOiBOb25lLAogICAgICAgICAgICAncmVzdWx0Y29sdW1ucyc6IFtbJ1Rlc3QnLCAndGVzdGNvZGUnXSwgWydJbnB1dCcsICdzdGRpbiddLCBbJ0V4cGVjdGVkJywgJ2V4cGVjdGVkJ10sIFsnR290JywgJ2dvdCddXSwKICAgICAgICAgICAgJ0FMTF9PUl9OT1RISU5HJzogVHJ1ZQogICAgICAgIH0KICAgICAgICBmb3IgcGFyYW0sIHZhbHVlIGluIGRlZmF1bHRfcGFyYW1zLml0ZW1zKCk6CiAgICAgICAgICAgIGlmIHBhcmFtIG5vdCBpbiBwYXJhbXM6CiAgICAgICAgICAgICAgICBzZWxmLnBhcmFtc1twYXJhbV0gPSB2YWx1ZQoKICAgICAgICBzZWxmLmlzX2ZpbGVfcXVlc3Rpb24gPSBzZWxmLnBhcmFtc1snZXh0cmEnXSA9PSAnZmlsZXMnCgoKICAgIGRlZiBzZXRfaGVhZGVyKHNlbGYsIHRlc3RjYXNlcyk6CiAgICAgICAgIiIiR2l2ZW4gdGhlIHNldCBvZiB0ZXN0Y2FzZXMsIHNldCB0aGUgaGVhZGVyIGFzIHRoZSBmaXJzdCByb3cgb2YgdGhlIHJlc3VsdCB0YWJsZQogICAgICAgICAgIGFuZCBzZXQgZmxhZ3MgdG8gaW5kaWNhdGUgcHJlc2VuY2Ugb3IgYWJzZW5jZQogICAgICAgICAgIG9mIHZhcmlvdXMgdGFibGUgY29sdW1ucy4KICAgICAgICAiIiIKICAgICAgICBoZWFkZXIgPSBbJ2lzY29ycmVjdCddCiAgICAgICAgcmVxdWlyZWRfY29sdW1ucyA9IHt9CiAgICAgICAgZm9yIGhkciwgZmllbGQsICpmb3JtYXQgaW4gc2VsZi5wYXJhbXNbJ3Jlc3VsdGNvbHVtbnMnXToKICAgICAgICAgICAgcmVxdWlyZWRfY29sdW1uc1tmaWVsZF0gPSBoZHIKICAgICAgICAgICAgaWYgZmllbGQgPT0gJ2V4dHJhJyBhbmQgc2VsZi5pc19maWxlX3F1ZXN0aW9uOgogICAgICAgICAgICAgICAgZm9ybWF0ID0gJyVoJyAgIyBTZWUgZm9ybWF0X2V4dHJhIGZ1bmN0aW9uLgogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0WzBdIGlmIGZvcm1hdCBlbHNlICclcycKICAgICAgICAgICAgc2VsZi5jb2x1bW5fZm9ybWF0c1tmaWVsZF0gPSBmb3JtYXQKICAgICAgICAgICAgc2VsZi5jb2x1bW5fZm9ybWF0c19ieV9oZHJbaGRyXSA9IGZvcm1hdAoKICAgICAgICBpZiAndGVzdGNvZGUnIGluIHJlcXVpcmVkX2NvbHVtbnMgYW5kIGFueSh0ZXN0LnRlc3Rjb2RlLnN0cmlwKCkgIT0gJycgZm9yIHRlc3QgaW4gdGVzdGNhc2VzKToKICAgICAgICAgICAgaGVhZGVyLmFwcGVuZChyZXF1aXJlZF9jb2x1bW5zWyd0ZXN0Y29kZSddKQogICAgICAgICAgICBzZWxmLmhhc190ZXN0cyA9IFRydWUKCiAgICAgICAgICAgICMgKioqIFdIQVQgV0FTIFRISVMgQUJPVVQ/Pz8gKioqCiAgICAgICAgICAgICMgSWYgdGhlIHRlc3QgY29kZSBzaG91bGQgYmUgcmVuZGVyZWQgaW4gaHRtbCB0aGVuIHNldCB0aGF0IGFzIGNvbHVtbiBmb3JtYXQuCiAgICAgICAgICAgICNpZiBhbnkoZ2V0YXR0cih0ZXN0LCAndGVzdF9jb2RlX2h0bWwnLCBOb25lKSBmb3IgdGVzdCBpbiB0ZXN0Y2FzZXMpOgogICAgICAgICAgICAjICAgIHNlbGYuY29sdW1uX2Zvcm1hdHMuYXBwZW5kKCclaCcpCiAgICAgICAgICAgICNlbHNlOgogICAgICAgICAgICAjICAgIHNlbGYuY29sdW1uX2Zvcm1hdHMuYXBwZW5kKCclcycpCgogICAgICAgICMgSWYgdGhpcyBpcyBhIHdyaXRlLWEtZnVuY3Rpb24gZmlsZSBxdWVzdGlvbiwgdGhlIHN0ZGluIGZpZWxkIGlzIGhpZGRlbiByZWdhcmRsZXNzLgogICAgICAgICMgVE9ETzogYXJlIHRoZXJlIGV4Y2VwdGlvbnMgdG8gdGhpcz8KICAgICAgICBoaWRlX3N0ZGluID0gc2VsZi5pc19maWxlX3F1ZXN0aW9uIGFuZCBzZWxmLnBhcmFtc1snaXNmdW5jdGlvbiddCiAgICAgICAgaWYgbm90IGhpZGVfc3RkaW46CiAgICAgICAgICAgIHN0ZGlucyA9IFt0ZXN0LmV4dHJhIGlmIHNlbGYucGFyYW1zWydzdGRpbmZyb21leHRyYSddIGVsc2UgdGVzdC5zdGRpbiBmb3IgdGVzdCBpbiB0ZXN0Y2FzZXNdCiAgICAgICAgICAgIGlmICdzdGRpbicgaW4gcmVxdWlyZWRfY29sdW1ucyBhbmQgYW55KHN0ZGluLnJzdHJpcCgpICE9ICcnIGZvciBzdGRpbiBpbiBzdGRpbnMpOgogICAgICAgICAgICAgICAgaGVhZGVyLmFwcGVuZChyZXF1aXJlZF9jb2x1bW5zWydzdGRpbiddKQogICAgICAgICAgICAgICAgc2VsZi5oYXNfc3RkaW5zID0gVHJ1ZQoKICAgICAgICBpZiAnZXh0cmEnIGluIHJlcXVpcmVkX2NvbHVtbnM6CiAgICAgICAgICAgIGhlYWRlci5hcHBlbmQocmVxdWlyZWRfY29sdW1uc1snZXh0cmEnXSkKICAgICAgICAgICAgc2VsZi5oYXNfZXh0cmEgPSBUcnVlCgogICAgICAgIGlmICdleHBlY3RlZCcgaW4gcmVxdWlyZWRfY29sdW1uczoKICAgICAgICAgICAgaGVhZGVyLmFwcGVuZChyZXF1aXJlZF9jb2x1bW5zWydleHBlY3RlZCddKQogICAgICAgICAgICBzZWxmLmhhc19leHBlY3RlZCA9IFRydWUKCiAgICAgICAgIyAqKiogQ09OU0lERVIgVVNFIE9GIEdPVCBJTiBGSUxFUyBxdWVzdGlvbnMgKGFuZCBvdGhlcnMpLiBDYW4gY29udGFpbiBlcnJvciBtZXNzYWdlcy4gU2hvdWxkIGFsd2F5cyBpbmNsdWRlPz8KICAgICAgICBpZiAnZ290JyBpbiByZXF1aXJlZF9jb2x1bW5zOgogICAgICAgICAgICBoZWFkZXIuYXBwZW5kKHJlcXVpcmVkX2NvbHVtbnNbJ2dvdCddKQogICAgICAgICAgICBzZWxmLmhhc19nb3QgPSBUcnVlCgogICAgICAgIGhlYWRlciArPSBbJ2lzY29ycmVjdCcsICdpc2hpZGRlbiddCiAgICAgICAgc2VsZi50YWJsZSA9IFtoZWFkZXJdCgogICAgZGVmIGltYWdlX2NvbHVtbl9udW1zKHNlbGYpOgogICAgICAgICIiIkEgbGlzdCBvZiB0aGUgbnVtYmVycyBvZiBjb2x1bW5zIGNvbnRhaW5pbmcgaW1hZ2VzIiIiCiAgICAgICAgcmV0dXJuIHNvcnRlZChzZXQoW2tleVswXSBmb3Iga2V5IGluIHNlbGYuaW1hZ2VzLmtleXMoKV0pKQoKICAgIGRlZiBnZXRfY29sdW1uX2Zvcm1hdHMoc2VsZik6CiAgICAgICAgIiIiIEFuIG9yZGVyZWQgbGlzdCBvZiB0aGUgY29sdW1uIGZvcm1hdHMuIENvbHVtbnMgY29udGFpbmluZyBpbWFnZXMgYXJlIGZvcmNlZCBpbnRvICVoIGZvcm1hdC4KICAgICAgICAgICAgRG9uJ3QgaGF2ZSBmb3JtYXRzIGZvciBpc2NvcnJlY3QgYW5kIGlzaGlkZGVuIGNvbHVtbnMuCiAgICAgICAgIiIiCiAgICAgICAgaW1hZ2VfY29sdW1ucyA9IHNlbGYuaW1hZ2VfY29sdW1uX251bXMoKQogICAgICAgIGZvcm1hdHMgPSBbXQogICAgICAgIGZvciBpLCBjb2x1bW5faGRyIGluIGVudW1lcmF0ZShzZWxmLnRhYmxlWzBdKToKICAgICAgICAgICAgaWYgaSBpbiBpbWFnZV9jb2x1bW5zOgogICAgICAgICAgICAgICAgZm9ybWF0cy5hcHBlbmQoJyVoJykKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGZvcm1hdHMuYXBwZW5kKHNlbGYuY29sdW1uX2Zvcm1hdHNfYnlfaGRyLmdldChjb2x1bW5faGRyLCAnJXMnKSkKICAgICAgICByZXR1cm4gZm9ybWF0c1sxOi0yXQoKICAgIGRlZiBnZXRfdGFibGUoc2VsZik6CiAgICAgICAgIiIiUmV0dXJuIHRoZSBjdXJyZW50IHJlc3VsdCB0YWJsZSwgd2l0aCBpbWFnZXMgYWRkZWQgdG8gYXBwcm9wcmlhdGUgY2VsbHMuCiAgICAgICAgICAgQ29sdW1ucyB0aGF0IGNvbnRhaW4gaW1hZ2VzIGFueXdoZXJlIGFyZSBjb252ZXJ0ZWQgdG8gJWggZm9ybWF0IGFuZCBleGlzdGluZyBjb250ZW50IGluIHRoYXQgY29sdW1uCiAgICAgICAgICAgaXMgaHRtbC1lc2NhcGVkLCBuZXdsaW5lcyByZXBsYWNlZCB3aXRoIDxicj4gYW5kIHdyYXBwZWQgaW4gYSBkaXYuCiAgICAgICAgICAgIiIiCiAgICAgICAgcmVzdWx0X3RhYmxlID0gW3Jvd1s6XSBmb3Igcm93IGluIHNlbGYudGFibGVdICAjIENsb25lIHRoZSByZXN1bHQgdGFibGUKCiAgICAgICAgIyBIdG1saXNlIGFsbCBjb2x1bW5zIGNvbnRhaW5pbmcgaW1hZ2VzCiAgICAgICAgZm9yIGNvbF9udW0gaW4gc2VsZi5pbWFnZV9jb2x1bW5fbnVtcygpOgogICAgICAgICAgICBmb3Igcm93X251bSBpbiByYW5nZSgxLCBsZW4ocmVzdWx0X3RhYmxlKSk6CiAgICAgICAgICAgICAgICByZXN1bHRfdGFibGVbcm93X251bV1bY29sX251bV0gPSBzZWxmLmh0bWxpc2UocmVzdWx0X3RhYmxlW3Jvd19udW1dW2NvbF9udW1dKQoKICAgICAgICAjIEFwcGVuZCBpbWFnZXMKICAgICAgICBmb3IgKChjb2wscm93KSwgaW1hZ2VfbGlzdCkgaW4gc2VsZi5pbWFnZXMuaXRlbXMoKToKICAgICAgICAgICAgZm9yIGltYWdlIGluIGltYWdlX2xpc3Q6CiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0X3RhYmxlW3Jvd11bY29sXSArPSAiPGJyPiIgKyBpbWFnZQogICAgICAgICAgICAgICAgZXhjZXB0IEluZGV4RXJyb3I6CiAgICAgICAgICAgICAgICAgICAgcGFzcyAgIyBUZXN0aW5nIG11c3QgaGF2ZSBhYm9ydGVkIHNvIGRpc2NhcmQgaW1hZ2UKCiAgICAgICAgcmV0dXJuIHJlc3VsdF90YWJsZQoKICAgIGRlZiByZXNldChzZWxmKToKICAgICAgICBpZiBsZW4oc2VsZi50YWJsZSkgPiAxOgogICAgICAgICAgICBkZWwgc2VsZi50YWJsZVsxOl0KICAgICAgICBzZWxmLmdsb2JhbF9lcnJvciA9ICcnCiAgICAgICAgc2VsZi5udW1fZmFpbGVkX3Rlc3RzID0gc2VsZi5tYXJrID0gMAogICAgICAgIHNlbGYuZmFpbGVkX2hpZGRlbiA9IHNlbGYuaGlkaW5nID0gc2VsZi5hYm9ydGVkID0gRmFsc2UKCiAgICBkZWYgdGVzdHNfbWlzc2VkKHNlbGYsIG51bSk6CiAgICAgICAgIiIiUmVjb3JkIHRoZSBmYWN0IHRoYXQgd2UncmUgbWlzc2luZyBzb21lIHRlc3QgcmVzdWx0cyAodGltZW91dD8pIiIiCiAgICAgICAgc2VsZi5taXNzaW5nX3Rlc3RzID0gbnVtCgogICAgZGVmIHJlY29yZF9nbG9iYWxfZXJyb3Ioc2VsZiwgZXJyb3JfbWVzc2FnZSk6CiAgICAgICAgIiIiUmVjb3JkIHNvbWUgc29ydCBvZiBnbG9iYWwgZmFpbHVyZSIiIgogICAgICAgIHNlbGYuZ2xvYmFsX2Vycm9yID0gZXJyb3JfbWVzc2FnZQoKICAgIGRlZiBmb3JtYXRfZXh0cmFfZm9yX2ZpbGVzKHNlbGYsIGV4dHJhLCBmaWxlbmFtZSk6CiAgICAgICAgIiIiRm9ybWF0IHRoZSBleHRyYSBmaWVsZCAod2hpY2ggc2hvdWxkIGJlIHRoZSBjb250ZW50cyBvZiBhIGZpbGUpLiBJZgogICAgICAgICAgIHRoZSBsb25nZXN0IGxpbmUgZXhjZWVkcyBmaWxlZG93bmxvYWR3aWR0aCBvciB0aGUgbnVtYmVyIG9mIGxpbmVzCiAgICAgICAgICAgZXhjZWVkcyBmaWxlZG93bmxvYWRsaW5lcyB0aGUgZmlsZSBpcyBjb252ZXJ0ZWQgaW50byBhIGRhdGEgVVJJLgogICAgICAgICAgIE90aGVyd2lzZSBpdCdzIHJldHVybmVkIGFzIGlzLgogICAgICAgICIiIgogICAgICAgIGxpbmVzID0gZXh0cmEuc3BsaXRsaW5lcygpCiAgICAgICAgdG9vX3dpZGUgPSBsZW4obGluZXMpID4gMCBhbmQgKG1heChsZW4obGluZSkgZm9yIGxpbmUgaW4gbGluZXMpID4gc2VsZi5wYXJhbXNbJ2ZpbGVkb3dubG9hZHdpZHRoJ10pCiAgICAgICAgdG9vX2hpZ2ggPSBsZW4obGluZXMpID4gc2VsZi5wYXJhbXNbJ2ZpbGVkb3dubG9hZGxpbmVzJ10KICAgICAgICBpZiB0b29fd2lkZSBvciB0b29faGlnaDoKICAgICAgICAgICAgcXVvdGVkID0gcXVvdGUoZXh0cmEpCiAgICAgICAgICAgIGxpbmsgPSBmJzxhIGhyZWY9ImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PXV0Zi04LHtxdW90ZWR9IiBkb3dubG9hZD17ZmlsZW5hbWV9PjxzcGFuIHN0eWxlPSJjb2xvcjpibHVlO2ZvbnQtd2VpZ2h0OmJvbGQ7dGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7Ij5Eb3dubG9hZDwvc3Bhbj48L2E+JwogICAgICAgICAgICByZXR1cm4gbGluawogICAgICAgIHJldHVybiAnPHByZT4nICsgZXh0cmEgKyAnPC9wcmU+JwoKICAgIGRlZiBhZGRfcm93KHNlbGYsIHRlc3RjYXNlLCByZXN1bHQsIGVycm9yPScnKToKICAgICAgICAiIiJBZGQgYSByZXN1bHQgcm93IHRvIHRoZSB0YWJsZSBmb3IgdGhlIGdpdmVuIHRlc3QgYW5kIHJlc3VsdCIiIgogICAgICAgIGlzX2NvcnJlY3QgPSBzZWxmLmNoZWNrX2NvcnJlY3RuZXNzKHJlc3VsdCArIGVycm9yLCB0ZXN0Y2FzZS5leHBlY3RlZCkKICAgICAgICByb3cgPSBbaXNfY29ycmVjdF0KICAgICAgICBpZiBzZWxmLmhhc190ZXN0czoKICAgICAgICAgICAgaWYgZ2V0YXR0cih0ZXN0Y2FzZSwgJ3Rlc3RfY29kZV9odG1sJywgTm9uZSk6CiAgICAgICAgICAgICAgICByb3cuYXBwZW5kKHRlc3RjYXNlLnRlc3RfY29kZV9odG1sKQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgcm93LmFwcGVuZCh0ZXN0Y2FzZS50ZXN0Y29kZSkKCiAgICAgICAgaWYgc2VsZi5oYXNfc3RkaW5zOgogICAgICAgICAgICByb3cuYXBwZW5kKHRlc3RjYXNlLmV4dHJhIGlmIHNlbGYucGFyYW1zWydzdGRpbmZyb21leHRyYSddIGVsc2UgdGVzdGNhc2Uuc3RkaW4pCgogICAgICAgIGlmIHNlbGYuaGFzX2V4dHJhOgogICAgICAgICAgICBpZiBzZWxmLnBhcmFtc1snZXh0cmEnXSA9PSAnZmlsZXMnOgogICAgICAgICAgICAgICAgZmlsZW5hbWUgPSB0ZXN0Y2FzZS5zdGRpbi5zcGxpdGxpbmVzKClbMF0KICAgICAgICAgICAgICAgIHJvdy5hcHBlbmQoc2VsZi5mb3JtYXRfZXh0cmFfZm9yX2ZpbGVzKHRlc3RjYXNlLmV4dHJhLCBmaWxlbmFtZSkpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICByb3cuYXBwZW5kKHRlc3RjYXNlLmV4dHJhKQoKICAgICAgICBpZiBzZWxmLmhhc19leHBlY3RlZDoKICAgICAgICAgICAgcm93LmFwcGVuZCh0ZXN0Y2FzZS5leHBlY3RlZC5yc3RyaXAoKSkKCiAgICAgICAgbWF4X2xlbiA9IHNlbGYucGFyYW1zLmdldCgnbWF4c3RyaW5nbGVuZ3RoJywgTUFYX1NUUklOR19MRU5HVEgpCiAgICAgICAgcmVzdWx0ID0gc2FuaXRpc2UocmVzdWx0LnJzdHJpcCgnXG4nKSwgbWF4X2xlbikKCiAgICAgICAgaWYgZXJyb3I6CiAgICAgICAgICAgIGVycm9yX21lc3NhZ2UgPSAnKioqIFJVTiBUSU1FIEVSUk9SKFMpICoqKlxuJyArIHNhbml0aXNlKGVycm9yLCBtYXhfbGVuKQogICAgICAgICAgICBpZiByZXN1bHQ6CiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgKyAnXG4nICsgZXJyb3JfbWVzc2FnZQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgcmVzdWx0ID0gZXJyb3JfbWVzc2FnZQoKICAgICAgICBpZiBzZWxmLmhhc19nb3Qgb3IgZXJyb3I6CiAgICAgICAgICAgIHJvdy5hcHBlbmQocmVzdWx0KQoKICAgICAgICBkaXNwbGF5ID0gdGVzdGNhc2UuZGlzcGxheS51cHBlcigpCiAgICAgICAgc2VsZi5tYXhfbWFyayArPSB0ZXN0Y2FzZS5tYXJrCiAgICAgICAgaWYgaXNfY29ycmVjdDoKICAgICAgICAgICAgc2VsZi5tYXJrICs9IHRlc3RjYXNlLm1hcmsKICAgICAgICBlbHNlOgogICAgICAgICAgICBzZWxmLm51bV9mYWlsZWRfdGVzdHMgKz0gMQogICAgICAgICAgICBpZiBkaXNwbGF5ID09ICdISURFJzoKICAgICAgICAgICAgICAgIHNlbGYubnVtX2ZhaWxlZF9oaWRkZW5fdGVzdHMgKz0gMQogICAgICAgIHJvdy5hcHBlbmQoaXNfY29ycmVjdCkKCiAgICAgICAgaXNfaGlkZGVuID0gKAogICAgICAgICAgICBzZWxmLmhpZGluZyBvcgogICAgICAgICAgICBkaXNwbGF5ID09ICdISURFJyBvcgogICAgICAgICAgICAoZGlzcGxheSA9PSAnSElERV9JRl9TVUNDRUVEJyBhbmQgaXNfY29ycmVjdCkgb3IKICAgICAgICAgICAgKGRpc3BsYXkgPT0gJ0hJREVfSUZfRkFJTCcgYW5kIG5vdCBpc19jb3JyZWN0KQogICAgICAgICkKICAgICAgICByb3cuYXBwZW5kKGlzX2hpZGRlbikKICAgICAgICBpZiBub3QgaXNfY29ycmVjdCBhbmQgaXNfaGlkZGVuOgogICAgICAgICAgICBzZWxmLmZhaWxlZF9oaWRkZW4gPSBUcnVlCiAgICAgICAgaWYgbm90IGlzX2NvcnJlY3QgYW5kIHRlc3RjYXNlLmhpZGVyZXN0aWZmYWlsOgogICAgICAgICAgICBzZWxmLmhpZGluZyA9IFRydWUKICAgICAgICBzZWxmLnRhYmxlLmFwcGVuZChyb3cpCiAgICAgICAgaWYgZXJyb3I6CiAgICAgICAgICAgIHNlbGYuYWJvcnRlZCA9IFRydWUKCiAgICBkZWYgZ2V0X21hcmsoc2VsZik6CiAgICAgICAgaWYgc2VsZi5udW1fZmFpbGVkX3Rlc3RzID09IDA6CiAgICAgICAgICAgIHJldHVybiBzZWxmLm1hcmsKICAgICAgICAjIEZhaWxlZCBvbmUgb3IgbW9yZSB0ZXN0cwogICAgICAgIGVsaWYgKHNlbGYubnVtX2ZhaWxlZF90ZXN0cyA9PSBzZWxmLm51bV9mYWlsZWRfaGlkZGVuX3Rlc3RzKSBhbmQgc2VsZi5wYXJhbXNbJ2ZhaWxoaWRkZW5vbmx5ZnJhY3QnXSA+IDA6CiAgICAgICAgICAgIHJldHVybiBzZWxmLm1heF9tYXJrICogc2VsZi5wYXJhbXNbJ2ZhaWxoaWRkZW5vbmx5ZnJhY3QnXQogICAgICAgIGVsaWYgbm90IHNlbGYucGFyYW1zWydBTExfT1JfTk9USElORyddOgogICAgICAgICAgICByZXR1cm4gc2VsZi5tYXJrCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmV0dXJuIDAKCgogICAgQHN0YXRpY21ldGhvZAogICAgZGVmIGh0bWxpc2Uocyk6CiAgICAgICAgIiIiQ29udmVydCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIGh0bWwgYnkgZXNjYXBpbmcgJzwnIGFuZCAnPicuCiAgICAgICAgICAgV3JhcCB0aGUgd2hvbGUgbG90IGluIGEgZGl2IHRhZyBzbyB0aGUgZGlmZiBjaGVja2VyIHByb2Nlc3NlcyB0aGUgd2hvbGUgdGFibGUgY2VsbCwKICAgICAgICAgICBhbmQgd2l0aGluIHRoYXQgYSBwcmUgdGFnIGZvciBjb3JyZWN0IGxheWxvdXQuCiAgICAgICAgIiIiCiAgICAgICAgcmV0dXJuICc8ZGl2PjxwcmUgY2xhc3M9InRhYmxlY2VsbCI+JyArIGh0bWwuZXNjYXBlKHMpICsgJzwvcHJlPjwvZGl2PicKCiAgICBkZWYgYWRkX2ltYWdlKHNlbGYsIGltYWdlX2h0bWwsIGNvbHVtbl9uYW1lLCByb3dfbnVtKToKICAgICAgICAiIiJTdG9yZSB0aGUgZ2l2ZW4gaHRtbF9pbWFnZSBmb3IgbGF0ZXIgaW5jbHVzaW9uIGluIHRoZSBjZWxsIGF0IHRoZSBnaXZlbiByb3cgYW5kIGdpdmVuIGNvbHVtbi4KICAgICAgICAgICBjb2x1bW5fbmFtZSBpcyB0aGUgbmFtZSB1c2VkIGZvciB0aGUgY29sdW1uIGluIHRoZSBmaXJzdCAoaGVhZGVyKSByb3cuCiAgICAgICAgICAgSXQgc2hvdWxkIGJlIGVpdGhlciBFeHBlY3RlZCBvciBHb3QgKGFsbCB3ZSBjYW4gaGFuZGxlIGluIHRoaXMgY29kZSkuCiAgICAgICAgICAgcm93X251bSBpcyB0aGUgcm93IG51bWJlciAoMCBvcmlnaW4sIG5vdCBpbmNsdWRpbmcgdGhlIGhlYWRlciByb3cpLgogICAgICAgICIiIgogICAgICAgIHRyeToKICAgICAgICAgICAgY29sdW1uX251bSA9IHNlbGYudGFibGVbMF0uaW5kZXgoY29sdW1uX25hbWUpCiAgICAgICAgICAgIHNlbGYuaW1hZ2VzW2NvbHVtbl9udW0sIHJvd19udW0gKyAxXS5hcHBlbmQoaW1hZ2VfaHRtbCkKICAgICAgICBleGNlcHQgKEluZGV4RXJyb3IsIFZhbHVlRXJyb3IpOgogICAgICAgICAgICByYWlzZSBFeGNlcHRpb24oZiJDYW4ndCBpbnNlcnQgJ3tjb2x1bW5fbmFtZX0nIGltYWdlIGludG8gcmVzdWx0IHRhYmxlIGFzIHRoZSBjb2x1bW4gZG9lcyBub3QgZXhpc3QuIikKCiAgICBkZWYgZXF1YWxfc3RyaW5ncyhzZWxmLCBzMSwgczIpOgogICAgICAgICIiIiBDb21wYXJlIHRoZSB0d28gc3RyaW5ncyBzMSBhbmQgczIgKGV4cGVjdGVkIGFuZCBnb3QgcmVzcGVjdGl2ZWx5KQogICAgICAgICAgICBmb3IgZXF1YWxpdHksIHdpdGggcmVnYXJkIHRvIHRoZSB0ZW1wbGF0ZSBwYXJhbWV0ZXJzCiAgICAgICAgICAgIHN0cmljdHdoaXRlc3BhY2UgYW5kIGZsb2F0dG9sZXJhbmNlLgogICAgICAgICIiIgogICAgICAgIHMxID0gczEucnN0cmlwKCkKICAgICAgICBzMiA9IHMyLnJzdHJpcCgpCiAgICAgICAgaWYgbm90IHNlbGYucGFyYW1zWydzdHJpY3R3aGl0ZXNwYWNlJ106CiAgICAgICAgICAgICMgQ29sbGFwc2Ugd2hpdGUgc3BhY2UgaWYgc3RyaWN0IHdoaXRlc3BhY2UgaXMgbm90IGVuZm9yY2VkCiAgICAgICAgICAgIHMxID0gcmUuc3ViKHInXHMrJywgJyAnLCBzMSkKICAgICAgICAgICAgczIgPSByZS5zdWIocidccysnLCAnICcsIHMyKQogICAgICAgIGlmIHNlbGYucGFyYW1zWydmbG9hdHRvbGVyYW5jZSddIGlzIE5vbmU6CiAgICAgICAgICAgIHJldHVybiBzMSA9PSBzMgogICAgICAgIGVsc2U6CiAgICAgICAgICAgICMgTWF0Y2hpbmcgd2l0aCBhIGZsb2F0aW5nIHBvaW50IHRvbGVyYW5jZS4KICAgICAgICAgICAgIyBVc2UgZmxvYXQgcGF0dGVybiBmcm9tIE1hcmt1cyBTY2htYXNzbWFubiBhdAogICAgICAgICAgICAjIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNjQzMDA5L3JlZ3VsYXItZXhwcmVzc2lvbi1mb3ItZmxvYXRpbmctcG9pbnQtbnVtYmVycwogICAgICAgICAgICAjIGV4Y2VwdCB3ZSBkb24ndCBtYXRjaCBpbmYgb3IgbmFuIHdoaWNoIGNhbiBiZSBlbWJlZGRlZCBpbiB0ZXh0IHN0cmluZ3MuCiAgICAgICAgICAgIHRvbCA9IGZsb2F0KHNlbGYucGFyYW1zWydmbG9hdHRvbGVyYW5jZSddKQogICAgICAgICAgICBmbG9hdF9wYXQgPSByJyhbLStdPyg/Oig/Oig/OlswLTldK1suXT9bMC05XSp8Wy5dWzAtOV0rKSg/OltlZF1bLStdP1swLTldKyk/KSkpJwogICAgICAgICAgICBzMV9iaXRzID0gcmUuc3BsaXQoZmxvYXRfcGF0LCBzMSkKICAgICAgICAgICAgczJfYml0cyA9IHJlLnNwbGl0KGZsb2F0X3BhdCwgczIpCiAgICAgICAgICAgIGlmIGxlbihzMV9iaXRzKSAhPSBsZW4oczJfYml0cyk6CiAgICAgICAgICAgICAgICByZXR1cm4gRmFsc2UKICAgICAgICAgICAgbWF0Y2ggPSBUcnVlCiAgICAgICAgICAgIGZvciBiaXQxLCBiaXQyIGluIHppcChzMV9iaXRzLCBzMl9iaXRzKToKICAgICAgICAgICAgICAgIGJpdDEgPSBiaXQxLnN0cmlwKCkKICAgICAgICAgICAgICAgIGJpdDIgPSBiaXQyLnN0cmlwKCkKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICBmMSA9IGZsb2F0KGJpdDEpCiAgICAgICAgICAgICAgICAgICAgZjIgPSBmbG9hdChiaXQyKQogICAgICAgICAgICAgICAgICAgIGlmIGFicyhmMSAtIGYyKSA+IHRvbCAqIDEuMDAxOiAjIEFsbG93IHRvbGVyYW5jZSBvbiB0aGUgZmxvYXQgdG9sZXJhbmNlIQogICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IEZhbHNlCiAgICAgICAgICAgICAgICBleGNlcHQgVmFsdWVFcnJvcjoKICAgICAgICAgICAgICAgICAgICBpZiBiaXQxICE9IGJpdDI6CiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gRmFsc2UKICAgICAgICAgICAgcmV0dXJuIG1hdGNoCgogICAgZGVmIGNoZWNrX2NvcnJlY3RuZXNzKHNlbGYsIGV4cGVjdGVkLCBnb3QpOgogICAgICAgICIiIlRydWUgaWZmIGV4cGVjdGVkIG1hdGNoZXMgZ290IHdpdGggcmVsYXhlZCB3aGl0ZSBzcGFjZSByZXF1aXJlbWVudHMuCiAgICAgICAgICAgQWRkaXRpb25hbGx5LCBpZiB0aGUgdGVtcGxhdGUgcGFyYW1ldGVyIGZsb2F0dG9sZXJhbmNlIGlzIHNldCBhbmQgaXMKICAgICAgICAgICBub24temVybywgdGhlIHR3byBzdHJpbmdzIHdpbGwgYmUgc3BsaXQgYnkgYSBmbG9hdGluZy1wb2ludCBsaXRlcmFsCiAgICAgICAgICAgcGF0dGVybiBhbmQgdGhlIGZsb2F0aW5nLXBvaW50IGJpdHMgd2lsbCBiZSBtYXRjaGVkIHRvIHdpdGhpbiB0aGUKICAgICAgICAgICBnaXZlbiBhYnNvbHV0ZSB0b2xlcmFuY2UuCiAgICAgICAgIiIiCiAgICAgICAgZXhwZWN0ZWRfbGluZXMgPSBleHBlY3RlZC5yc3RyaXAoKS5zcGxpdGxpbmVzKCkKICAgICAgICBnb3RfbGluZXMgPSBnb3QucnN0cmlwKCkuc3BsaXRsaW5lcygpCiAgICAgICAgaWYgbGVuKGdvdF9saW5lcykgIT0gbGVuKGV4cGVjdGVkX2xpbmVzKToKICAgICAgICAgICAgcmV0dXJuIEZhbHNlCiAgICAgICAgZWxzZToKICAgICAgICAgICAgZm9yIGV4cCwgZ290IGluIHppcChleHBlY3RlZF9saW5lcywgZ290X2xpbmVzKToKICAgICAgICAgICAgICAgIGlmIG5vdCBzZWxmLmVxdWFsX3N0cmluZ3MoZXhwLCBnb3QpOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWxzZQogICAgICAgIHJldHVybiBUcnVlCgoKZGVmIHNhbml0aXNlKHMsIG1heF9sZW49TUFYX1NUUklOR19MRU5HVEgpOgogICAgIiIiUmVwbGFjZSBub24tcHJpbnRpbmcgY2hhcnMgd2l0aCBlc2NhcGUgc2VxdWVuY2VzLCByaWdodC1zdHJpcC4KICAgICAgIExpbWl0IHMgdG8gbWF4X2xlbiBieSBzbmlwcGluZyBvdXQgYml0cyBpbiB0aGUgbWlkZGxlLgogICAgIiIiCiAgICByZXN1bHQgPSAnJwogICAgaWYgbGVuKHMpID4gbWF4X2xlbjoKICAgICAgICBzID0gc1swOiBtYXhfbGVuIC8vIDJdICsgIlxuKioqIDxzbmlwPiAqKipcbiIgKyBzWy1tYXhfbGVuIC8vIDI6XQogICAgbGluZXMgPSBzLnJzdHJpcCgpLnNwbGl0bGluZXMoKQogICAgZm9yIGxpbmUgaW4gbGluZXM6CiAgICAgICAgZm9yIGMgaW4gbGluZS5yc3RyaXAoKSArICdcbic6CiAgICAgICAgICAgIGlmIGMgPCAnICcgYW5kIGMgIT0gJ1xuJzoKICAgICAgICAgICAgICAgIGlmIGMgPT0gJ1x0JzoKICAgICAgICAgICAgICAgICAgICBjID0gcidcdCcKICAgICAgICAgICAgICAgIGVsaWYgYyA9PSAnXHInOgogICAgICAgICAgICAgICAgICAgIGMgPSByJ1xyJwogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBjID0gcidcezowM299Jy5mb3JtYXQob3JkKGMpKQogICAgICAgICAgICByZXN1bHQgKz0gYwogICAgcmV0dXJuIHJlc3VsdC5yc3RyaXAoKQo=</file>
<file name="__tester.py" path="/" encoding="base64">IiIiVGhlIGdlbmVyaWMgKG11bHRpLWxhbmd1YWdlKSBtYWluIHRlc3RpbmcgY2xhc3MgdGhhdCBkb2VzIGFsbCB0aGUgd29yayAtIHRyaWFsIGNvbXBpbGUsIHN0eWxlIGNoZWNrcywKICAgcnVuIGFuZCBncmFkZS4KIiIiCmZyb20gX19yZXN1bHR0YWJsZSBpbXBvcnQgUmVzdWx0VGFibGUKaW1wb3J0IGh0bWwKaW1wb3J0IG9zCmltcG9ydCByZQppbXBvcnQgX19sYW5ndWFnZXRhc2sgYXMgbGFuZ3VhZ2V0YXNrCmltcG9ydCBiYXNlNjQKCgojIFZhbHVlcyBvZiBRVUVTVElPTi5wcmVjaGVjayBmaWVsZApQUkVDSEVDS19ESVNBQkxFRCA9IDAKUFJFQ0hFQ0tfRU1QVFkgPSAxClBSRUNIRUNLX0VYQU1QTEVTID0gMgpQUkVDSEVDS19TRUxFQ1RFRCA9IDMKUFJFQ0hFQ0tfQUxMID0gNAoKIyBWYWx1ZXMgb2YgdGVzdHR5cGUKVFlQRV9OT1JNQUwgPSAwClRZUEVfUFJFQ0hFQ0tPTkxZID0gMQpUWVBFX0JPVEggPSAyCgojIEdsb2JhbCBtZXNzYWdlIGZvciB3aGVuIGEgdGVzdC1zdWl0ZSB0aW1lb3V0IG9jY3VycwpUSU1FT1VUX01FU1NBR0UgPSAiIiJBIHRpbWVvdXQgb2NjdXJyZWQgd2hlbiBydW5uaW5nIHRoZSB3aG9sZSB0ZXN0IHN1aXRlIGFzIGEgc2luZ2xlIHByb2dyYW0uClRoaXMgaXMgdXN1YWxseSBkdWUgdG8gYW4gZW5kbGVzcyBsb29wIGluIHlvdXIgY29kZSBidXQgY2FuIGFsc28gYXJpc2UgaWYgeW91ciBjb2RlIGlzIHZlcnkgaW5lZmZpY2llbnQKYW5kIHRoZSBhY2N1bXVsYXRlZCB0aW1lIG92ZXIgYWxsIHRlc3RzIGlzIGV4Y2Vzc2l2ZS4gUGxlYXNlIGFzayBhIHR1dG9yIG9yIHlvdXIgbGVjdHVyZXIgaWYgeW91IG5lZWQgaGVscAp3aXRoIG1ha2luZyB5b3VyIHByb2dyYW0gbW9yZSBlZmZpY2llbnQuIiIiCgoKZGVmIGdldF9qcGVnX2I2NChmaWxlbmFtZSk6CiAgICAiIiJSZXR1cm4gdGhlIGNvbnRlbnRzIG9mIHRoZSBnaXZlbiBmaWxlIChhc3N1bWVkIHRvIGJlIGpwZWcpIGFzIGEgYmFzZTY0CiAgICAgICBlbmNvZGVkIHN0cmluZyBpbiB1dGYtOC4KICAgICIiIgogICAgd2l0aCBvcGVuKGZpbGVuYW1lLCAnYnInKSBhcyBmaW46CiAgICAgICAgY29udGVudHMgPSBmaW4ucmVhZCgpCgogICAgcmV0dXJuIGJhc2U2NC5iNjRlbmNvZGUoY29udGVudHMpLmRlY29kZSgndXRmOCcpCgoKY2xhc3MgVGVzdGVyOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHBhcmFtcywgdGVzdGNhc2VzKToKICAgICAgICAiIiJJbml0aWFsaXNlIHRoZSBpbnN0YW5jZSwgZ2l2ZW4gdGhlIHRlc3Qgb2YgdGVtcGxhdGUgYW5kIGdsb2JhbCBwYXJhbWV0ZXJzIHBsdXMKICAgICAgICAgICBhbGwgdGhlIHRlc3RjYXNlcy4gUGFyYW1ldGVycyByZXF1aXJlZCBieSB0aGlzIGJhc2UgY2xhc3MgYW5kIGFsbCBzdWJjbGFzc2VzIGFyZToKICAgICAgICAgICAgICAgJ1NUVURFTlRfQU5TV0VSJzogY29kZSBzdWJtaXR0ZWQgYnkgdGhlIHN0dWRlbnQKICAgICAgICAgICAgICAgJ1NFUEFSQVRPUic6IHRoZSBzdHJpbmcgdG8gYmUgdXNlZCB0byBzZXBhcmF0ZSB0ZXN0cyBpbiB0aGUgb3V0cHV0CiAgICAgICAgICAgICAgICdBTExfT1JfTk9USElORzogdHJ1ZSBpZiBncmFkaW5nIGlzIGFsbC1vci1ub3RoaW5nCiAgICAgICAgICAgICAgICdzdGRpbmZyb21leHRyYSc6IHRydWUgaWYgdGhlIHRlc3QtY2FzZSAnZXh0cmEnIGZpZWxkIGlzIHRvIGJlIHVzZWQgZm9yCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YW5kYXJkIGlucHV0IHJhdGhlciB0aGFuIHRoZSB1c3VhbCBzdGRpbiBmaWVsZAogICAgICAgICAgICAgICAncnVudGVzdHNzaW5nbHknOiB0cnVlIHRvIGZvcmNlIGEgc2VwYXJhdGUgcnVuIGZvciBlYWNoIHRlc3QgY2FzZQogICAgICAgICAgICAgICAnc3RkaW5mcm9tZXh0cmEnOiB0cnVlIGlmIHRoZSBleHRyYSBmaWVsZCBpcyB1c2VkIGZvciBzdGFuZGFyZCBpbnB1dCAobGVnYWN5IHVzZSBvbmx5KQogICAgICAgICAgICAgICAndGVzdGlzYmFzaCc6IHRydWUgaWYgdGVzdHMgYXJlIGJhc2ggY29tbWFuZCBsaW5lKHMpIHJhdGhlciB0aGFuIHRoZSBkZWZhdWx0IGRpcmVjdCBleGVjdXRpb24KICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgY29tcGlsZWQgcHJvZ3JhbS4gVGhpcyBjYW4gYmUgdXNlZCB0byBzdXBwbHkgY29tbWFuZCBsaW5lIGFyZ3VtZW50cy4KCiAgICAgICAgIiIiCiAgICAgICAgc2VsZi5zdHVkZW50X2Fuc3dlciA9IHNlbGYuY2xlYW4ocGFyYW1zWydTVFVERU5UX0FOU1dFUiddKQogICAgICAgIHNlbGYuc2VwYXJhdG9yID0gcGFyYW1zWydTRVBBUkFUT1InXQogICAgICAgIHNlbGYuYWxsX29yX25vdGhpbmcgPSBwYXJhbXNbJ0FMTF9PUl9OT1RISU5HJ10KICAgICAgICBzZWxmLnBhcmFtcyA9IHBhcmFtcwogICAgICAgIHNlbGYudGVzdGNhc2VzID0gc2VsZi5maWx0ZXJfdGVzdHModGVzdGNhc2VzKQogICAgICAgIHNlbGYucmVzdWx0X3RhYmxlID0gUmVzdWx0VGFibGUocGFyYW1zKQogICAgICAgIHNlbGYucmVzdWx0X3RhYmxlLnNldF9oZWFkZXIoc2VsZi50ZXN0Y2FzZXMpCgogICAgICAgICMgSXQgaXMgYXNzdW1lZCB0aGF0IGluIGdlbmVyYWwgc3ViY2xhc3NlcyB3aWxsIHByZWZpeCBzdHVkZW50IGNvZGUgYnkgYSBwcmVsdWRlIGFuZAogICAgICAgICMgcG9zdGZpeCBpdCBieSBhIHBvc3RsdWRlLgogICAgICAgIHNlbGYucHJlbHVkZSA9ICcnCiAgICAgICAgc2VsZi5wcmVsdWRlX2xlbmd0aCA9IDAKICAgICAgICBzZWxmLnBvc3RsdWRlID0gJycKCiAgICAgICAgc2VsZi50YXNrID0gTm9uZSAgIyBTVUJDTEFTUyBNVVNUIERFRklORSBUSElTCgogICAgZGVmIGZpbHRlcl90ZXN0cyhzZWxmLCB0ZXN0Y2FzZXMpOgogICAgICAgICIiIlJldHVybiB0aGUgcmVsZXZhbnQgc3Vic2V0IG9mIHRoZSBxdWVzdGlvbidzIHRlc3RjYXNlcy4KICAgICAgICAgICBUaGlzIHdpbGwgYmUgYWxsIHRlc3RjYXNlcyBub3QgbWFya2VkIHByZWNoZWNrLW9ubHkgaWYgaXQncyBub3QgYSBwcmVjaGVjayBvciBhbGwgdGVzdGNhc2VzIGlmIGl0IGlzIGEKICAgICAgICAgICBwcmVjaGVjayBhbmQgdGhlIHF1ZXN0aW9uIHByZWNoZWNrIGlzIHNldCB0byAiQWxsIiwgb3IgdGhlIGFwcHJvcHJpYXRlIHN1YnNldCBpbiBhbGwgb3RoZXIgY2FzZXMuCiAgICAgICAgIiIiCiAgICAgICAgaWYgbm90IHNlbGYucGFyYW1zWydJU19QUkVDSEVDSyddOgogICAgICAgICAgICByZXR1cm4gW3Rlc3QgZm9yIHRlc3QgaW4gdGVzdGNhc2VzIGlmIHRlc3QudGVzdHR5cGUgIT0gVFlQRV9QUkVDSEVDS09OTFldCiAgICAgICAgZWxpZiBzZWxmLnBhcmFtc1snUVVFU1RJT05fUFJFQ0hFQ0snXSA9PSBQUkVDSEVDS19BTEw6CiAgICAgICAgICAgIHJldHVybiB0ZXN0Y2FzZXMKICAgICAgICBlbGlmIHNlbGYucGFyYW1zWydRVUVTVElPTl9QUkVDSEVDSyddID09IFBSRUNIRUNLX0VNUFRZOgogICAgICAgICAgICByZXR1cm4gW10KICAgICAgICBlbGlmIHNlbGYucGFyYW1zWydRVUVTVElPTl9QUkVDSEVDSyddID09IFBSRUNIRUNLX0VYQU1QTEVTOgogICAgICAgICAgICByZXR1cm4gW3Rlc3QgZm9yIHRlc3QgaW4gdGVzdGNhc2VzIGlmIHRlc3QudXNlYXNleGFtcGxlXQogICAgICAgIGVsaWYgc2VsZi5wYXJhbXNbJ1FVRVNUSU9OX1BSRUNIRUNLJ10gPT0gUFJFQ0hFQ0tfU0VMRUNURUQ6CiAgICAgICAgICAgIHJldHVybiBbdGVzdCBmb3IgdGVzdCBpbiB0ZXN0Y2FzZXMgaWYgdGVzdC50ZXN0dHlwZSBpbiBbVFlQRV9QUkVDSEVDS09OTFksIFRZUEVfQk9USF1dCgogICAgZGVmIHN0eWxlX2Vycm9ycyhzZWxmKToKICAgICAgICAiIiJSZXR1cm4gYSBsaXN0IG9mIGFsbCB0aGUgc3R5bGUgZXJyb3JzLiBJbXBsZW1lbnRhdGlvbiBpcyBsYW5ndWFnZSBkZXBlbmRlbnQuCiAgICAgICAgICAgRGVmYXVsdCBpcyBubyBzdHlsZSBjaGVja2luZy4KICAgICAgICAiIiIKICAgICAgICByZXR1cm4gW10KCiAgICBkZWYgc2luZ2xlX3Byb2dyYW1fYnVpbGRfcG9zc2libGUoc2VsZik6CiAgICAgICAgIiIiUmV0dXJuIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbiBwZXJtaXRzIGEgc2luZ2xlIHByb2dyYW0gdG8gYmUKICAgICAgICAgICBidWlsdCBhbmQgdHJpZWQgY29udGFpbmluZyBhbGwgdGVzdHMuIEl0IHNob3VsZCBiZSB0cnVlIGZvciB3cml0ZS1hLXByb2dyYW0gcXVlc3Rpb25zIGFuZAogICAgICAgICAgIGNvbmRpdGlvbmFsbHkgdHJ1ZSBmb3Igb3RoZXIgdHlwZXMgb2YgcXVlc3Rpb25zIHRoYXQgYWxsb3cgYSAiY29tYmluYXRvciIgYXBwcm9hY2gsCiAgICAgICAgICAgZGVwZW5kZW50IG9uIHRoZSBwcmVzZW5jZSBvZiBzdGRpbnMgaW4gdGVzdHMgYW5kIG90aGVyIHN1Y2ggY29uZGl0aW9ucy4KICAgICAgICAiIiIKICAgICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKCJUZXN0ZXIgbXVzdCBoYXZlIGEgc2luZ2xlX3Byb2dyYW1fYnVpbGRfcG9zc2libGUgbWV0aG9kIikKCiAgICBkZWYgYWRqdXN0X2Vycm9yX2xpbmVfbnVtcyhzZWxmLCBlcnJvcik6CiAgICAgICAgIiIiR2l2ZW4gYSBydW50aW1lIGVycm9yIG1lc3NhZ2UsIGFkanVzdCBpdCBhcyBtYXkgYmUgcmVxdWlyZWQgYnkgdGhlCiAgICAgICAgICAgbGFuZ3VhZ2UsIGUuZy4gYWRqdXN0aW5nIGxpbmUgbnVtYmVycwogICAgICAgICIiIgogICAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoIlRlc3RlciBtdXN0IGhhdmUgYW4gYWRqdXN0X2Vycm9yX2xpbmVfbnVtcyBtZXRob2QiKQoKICAgIGRlZiBzaW5nbGVfcnVuX3Bvc3NpYmxlKHNlbGYpOgogICAgICAgICIiIlJldHVybiB0cnVlIGlmIGEgc2luZ2xlIHByb2dyYW0gaGFzIGJlZW4gYnVpbHQgYW5kIGl0IGlzIHBvc3NpYmxlIHRvIHVzZSB0aGF0IGluIGEgc2luZ2xlIHJ1bgogICAgICAgICAgIHdpdGggYWxsIHRlc3RzLgogICAgICAgICIiIgogICAgICAgIHJldHVybiAoc2VsZi50YXNrLmV4ZWN1dGFibGVfYnVpbHQKICAgICAgICAgICAgICAgIGFuZCBub3Qgc2VsZi5wYXJhbXNbJ3J1bnRlc3Rzc2luZ2x5J10KICAgICAgICAgICAgICAgIGFuZCBub3Qgc2VsZi5yZXN1bHRfdGFibGUuaGFzX3N0ZGlucwogICAgICAgICAgICAgICAgYW5kIG5vdCBzZWxmLnBhcmFtc1sndGVzdGlzYmFzaCddKQoKICAgIGRlZiBtYWtlX3Rlc3RfcG9zdGx1ZGUoc2VsZiwgdGVzdGNhc2VzKToKICAgICAgICAiIiJSZXR1cm4gdGhlIHBvc3RsdWRlIHRlc3RpbmcgY29kZSBjb250YWluaW5nIGFsbCB0aGUgdGVzdGNvZGUgZnJvbQogICAgICAgICAgIHRoZSBnaXZlbiBsaXN0IG9mIHRlc3RjYXNlcyAod2hpY2ggbWF5IGJlIHRoZSBmdWxsIHNldCBvciBhIHNpbmdsZXRvbiBsaXN0KS4KICAgICAgICAgICBBIHNlcGFyYXRvciBtdXN0IGJlIHByaW50ZWQgYmV0d2VlbiB0ZXN0Y2FzZSBvdXRwdXRzLiIiIgogICAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoIlRlc3RlciBtdXN0IGhhdmUgYSBtYWtlX3Rlc3RfcG9zdGx1ZGUgbWV0aG9kIikKCiAgICBkZWYgdHJpYWxfY29tcGlsZShzZWxmKToKICAgICAgICAiIiJUaGlzIGZ1bmN0aW9uIGlzIHRoZSBmaXJzdCBjaGVjayBvbiB0aGUgc3ludGFjdGljIGNvcnJlY3RuZXNzIG9mIHRoZSBzdWJtaXR0ZWQgY29kZS4KICAgICAgICAgICBJdCBpcyBjYWxsZWQgYmVmb3JlIGFueSBzdHlsZSBjaGVja3MgYXJlIGRvbmUuIEZvciBjb21waWxlZCBsYW5ndWFnZXMgaXQgc2hvdWxkIGdlbmVyYWxseQogICAgICAgICAgIGNhbGwgdGhlIHN0YW5kYXJkIGxhbmd1YWdlIGNvbXBpbGVyIG9uIHRoZSBzdHVkZW50IHN1Ym1pdHRlZCBjb2RlIHdpdGggYW55IHJlcXVpcmVkIHByZWx1ZGUKICAgICAgICAgICBhZGRlZCBhbmQsIGlmIHBvc3NpYmxlLCBhbGwgdGVzdHMgaW5jbHVkZWQuIENvbXBpbGVFcnJvciBzaG91bGQgYmUgcmFpc2VkIGlmIHRoZSBjb21waWxlIGZhaWxzLAogICAgICAgICAgIHdoaWNoIHdpbGwgYWJvcnQgYWxsIGZ1cnRoZXIgdGVzdGluZy4KICAgICAgICAgICBJZiBwb3NzaWJsZSBhIGNvbXBsZXRlIHJlYWR5LXRvLXJ1biBleGVjdXRhYmxlIHNob3VsZCBiZSBidWlsdCBhcyB3ZWxsOyBpZiB0aGlzIHN1Y2NlZWRzLCB0aGUKICAgICAgICAgICBMYW5ndWFnZVRhc2tzICdleGVjdXRhYmxlX2J1aWx0JyBhdHRyaWJ1dGUgc2hvdWxkIGJlIHNldC4gVGhpcyBzaG91bGQgYmUgcG9zc2libGUgZm9yIHdyaXRlLWEtcHJvZ3JhbQogICAgICAgICAgIHF1ZXN0aW9ucyBvciBmb3Igd3JpdGUtYS1mdW5jdGlvbiBxdWVzdGlvbnMgd2hlbiB0aGVyZSBpcyBubyBzdGRpbiBkYXRhIGluIGFueSBvZiB0aGUgdGVzdHMuCgogICAgICAgICAgIEludGVycHJldGVkIGxhbmd1YWdlcyBzaG91bGQgcGVyZm9ybSB3aGF0IHN5bnRheCBjaGVja3MgYXJlIHBvc3NpYmxlIHVzaW5nIHRoZSBzdGFuZGFyZCBsYW5ndWFnZSB0b29scy4KICAgICAgICAgICBJZiB0aG9zZSBjaGVja3Mgc3VjY2VlZGVkLCB0aGV5IHNob3VsZCBhbHNvIGF0dGVtcHQgdG8gY29uc3RydWN0IGEgc291cmNlIHByb2dyYW0gdGhhdCBpbmNvcnBvcmF0ZXMgYWxsCiAgICAgICAgICAgdGhlIGRpZmZlcmVudCB0ZXN0cyAodGhlIG9sZCAiY29tYmluYXRvciIgYXBwcm9hY2gpIGFuZCBlbnN1cmUgdGhlIHRhc2sncyAnZXhlY3V0YWJsZV9idWlsdCcgYXR0cmlidXRlCiAgICAgICAgICAgaXMgVHJ1ZS4KCiAgICAgICAgICAgVGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvbiBpcyBzdWZmaWNpZW50IGZvciBzdGFuZGFyZCBjb21waWxlZCBsYW5ndWFnZXMgbGlrZSBDLCBDKyssIEphdmEuIEl0CiAgICAgICAgICAgbWF5IG5lZWQgb3ZlcnJpZGluZyBmb3Igb3RoZXIgbGFuZ3VhZ2VzLgogICAgICAgICIiIgogICAgICAgIGlmIHNlbGYuc2luZ2xlX3Byb2dyYW1fYnVpbGRfcG9zc2libGUoKToKICAgICAgICAgICAgc2VsZi5zZXR1cF9mb3JfdGVzdF9ydW5zKHNlbGYudGVzdGNhc2VzKQogICAgICAgICAgICBtYWtlX2V4ZWN1dGFibGUgPSBUcnVlCiAgICAgICAgZWxzZToKICAgICAgICAgICAgc2VsZi5wb3N0bHVkZSA9ICcnCiAgICAgICAgICAgIHNlbGYudGFzay5zZXRfY29kZShzZWxmLnByZWx1ZGUgKyBzZWxmLnN0dWRlbnRfYW5zd2VyLCBzZWxmLnByZWx1ZGVfbGVuZ3RoKQogICAgICAgICAgICBtYWtlX2V4ZWN1dGFibGUgPSBGYWxzZQoKICAgICAgICBzZWxmLnRhc2suY29tcGlsZShtYWtlX2V4ZWN1dGFibGUpICAjIENvdWxkIHJhaXNlIENvbXBpbGVFcnJvcgoKICAgIGRlZiBzZXR1cF9mb3JfdGVzdF9ydW5zKHNlbGYsIHRlc3RzKToKICAgICAgICAiIiJTZXQgdGhlIGNvZGUgYW5kIHByZWx1ZGUgbGVuZ3RoIGFzIGFwcHJvcHJpYXRlIGZvciBhIHJ1biB3aXRoIGFsbCB0aGUgZ2l2ZW4gdGVzdHMuIE1heSBiZSBjYWxsZWQgd2l0aAogICAgICAgICAgIGp1c3QgYSBzaW5nbGV0b24gbGlzdCBmb3IgdGVzdHMgaWYgc2luZ2xlX3Byb2dyYW1fYnVpbGRfcG9zc2libGUgaGFzIHJldHVybmVkIGZhbHNlIG9yIGlmIHRlc3Rpbmcgd2l0aAogICAgICAgICAgIG11bHRpcGxlIHRlc3RzIGhhcyBnaXZlbiBleGNlcHRpb25zLgogICAgICAgICAgIFRoaXMgaW1wbGVtZW50YXRpb24gbWF5IG5lZWQgdG8gYmUgb3ZlcnJpZGRlbiwgZS5nLiBpZiB0aGUgc3R1ZGVudCBjb2RlIHNob3VsZCBmb2xsb3cgdGhlIHRlc3QgY29kZSwgYXMKICAgICAgICAgICBzYXkgaW4gTWF0bGFiIHNjcmlwdHMuCiAgICAgICAgIiIiCiAgICAgICAgc2VsZi5wb3N0bHVkZSA9IHNlbGYubWFrZV90ZXN0X3Bvc3RsdWRlKHRlc3RzKQogICAgICAgIHNlbGYudGFzay5zZXRfY29kZShzZWxmLnByZWx1ZGUgKyBzZWxmLnN0dWRlbnRfYW5zd2VyICsgc2VsZi5wb3N0bHVkZSwgc2VsZi5wcmVsdWRlX2xlbmd0aCkKCiAgICBkZWYgcnVuX2FsbF90ZXN0cyhzZWxmKToKICAgICAgICAiIiJSdW4gYWxsIHRoZSB0ZXN0cywgbGVhdmluZyBzZWxmLlJlc3VsdFRhYmxlIG9iamVjdCBjb250YWluaW5nIGFsbCB0ZXN0IHJlc3VsdHMuCiAgICAgICAgICAgQ2FuIHJhaXNlIENvbXBpbGVFcnJvciBvciBSdW5FcnJvciBpZiB0aGluZ3MgYnJlYWsuCiAgICAgICAgICAgSWYgYW55IHJ1bnRpbWUgZXJyb3JzIG9jY3VyIG9uIHRoZSBmdWxsIHRlc3QsIGRyb3AgYmFjayB0byBydW5uaW5nIHRlc3RzIHNpbmdseS4KICAgICAgICAiIiIKICAgICAgICBkb25lID0gRmFsc2UKICAgICAgICBpZiBzZWxmLnNpbmdsZV9ydW5fcG9zc2libGUoKToKICAgICAgICAgICAgIyBXZSBoYXZlIGFuIGV4ZWN1dGFibGUgcmVhZHkgdG8gZ28sIHdpdGggbm8gc3RkaW5zIG9yIG90aGVyIHNob3cgc3RvcHBlcnMKICAgICAgICAgICAgb3V0cHV0LCBlcnJvciA9IHNlbGYudGFzay5ydW5fY29kZSgpCiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yc3RyaXAoKSArICdcbicKICAgICAgICAgICAgZXJyb3IgPSBlcnJvci5zdHJpcCgpICsgJ1xuJwoKICAgICAgICAgICAgIyBHZW5lcmF0ZSBhIHJlc3VsdCB0YWJsZSB1c2luZyBhbGwgYXZhaWxhYmxlIHRlc3QgZGF0YS4KICAgICAgICAgICAgcmVzdWx0cyA9IG91dHB1dC5zcGxpdChzZWxmLnNlcGFyYXRvciArICdcbicpCiAgICAgICAgICAgIGVycm9ycyA9IGVycm9yLnNwbGl0KHNlbGYuc2VwYXJhdG9yICsgJ1xuJykKICAgICAgICAgICAgaWYgbGVuKHJlc3VsdHMpID09IGxlbihlcnJvcnMpOgogICAgICAgICAgICAgICAgbWVyZ2VkX3Jlc3VsdHMgPSBbXQogICAgICAgICAgICAgICAgZm9yIHJlc3VsdCwgZXJyb3IgaW4gemlwKHJlc3VsdHMsIGVycm9ycyk6CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJzdHJpcCgpICsgJ1xuJwogICAgICAgICAgICAgICAgICAgIGlmIGVycm9yLnN0cmlwKCk6CiAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdGVkX2Vycm9yID0gc2VsZi5hZGp1c3RfZXJyb3JfbGluZV9udW1zKGVycm9yLnJzdHJpcCgpKQogICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xuKioqIFJVTiBFUlJPUiAqKipcbicgKyBhZGp1c3RlZF9lcnJvcgogICAgICAgICAgICAgICAgICAgIG1lcmdlZF9yZXN1bHRzLmFwcGVuZChyZXN1bHQpCgogICAgICAgICAgICAgICAgbWlzc2VkX3Rlc3RzID0gbGVuKHNlbGYudGVzdGNhc2VzKSAtIGxlbihtZXJnZWRfcmVzdWx0cykKCiAgICAgICAgICAgICAgICBmb3IgdGVzdCwgb3V0cHV0IGluIHppcChzZWxmLnRlc3RjYXNlcywgbWVyZ2VkX3Jlc3VsdHMpOgogICAgICAgICAgICAgICAgICAgIHNlbGYucmVzdWx0X3RhYmxlLmFkZF9yb3codGVzdCwgb3V0cHV0KQoKICAgICAgICAgICAgICAgIHNlbGYucmVzdWx0X3RhYmxlLnRlc3RzX21pc3NlZChtaXNzZWRfdGVzdHMpCiAgICAgICAgICAgICAgICBpZiBzZWxmLnRhc2sudGltZWRfb3V0OgogICAgICAgICAgICAgICAgICAgIHNlbGYucmVzdWx0X3RhYmxlLnJlY29yZF9nbG9iYWxfZXJyb3IoVElNRU9VVF9NRVNTQUdFKQogICAgICAgICAgICAgICAgZG9uZSA9IFRydWUKCiAgICAgICAgICAgIGlmIG5vdCBkb25lOgogICAgICAgICAgICAgICAgIyBTb21ldGhpbmcgYnJva2UuIFdlIHdpbGwgbmVlZCB0byBydW4gZWFjaCB0ZXN0IGNhc2Ugc2VwYXJhdGVseQogICAgICAgICAgICAgICAgc2VsZi50YXNrLmV4ZWN1dGFibGVfYnVpbHQgPSBGYWxzZQogICAgICAgICAgICAgICAgc2VsZi5yZXN1bHRfdGFibGUucmVzZXQoKQoKICAgICAgICBpZiBub3QgZG9uZToKICAgICAgICAgICAgIyBJZiBhIHNpbmdsZSBydW4gaXNuJ3QgYXBwcm9wcmlhdGUsIGRvIGEgc2VwYXJhdGUgcnVuIGZvciBlYWNoIHRlc3QgY2FzZS4KICAgICAgICAgICAgYnVpbGRfZWFjaF90ZXN0ID0gbm90IHNlbGYudGFzay5leGVjdXRhYmxlX2J1aWx0CiAgICAgICAgICAgIGZvciBpX3Rlc3QsIHRlc3QgaW4gZW51bWVyYXRlKHNlbGYudGVzdGNhc2VzKToKICAgICAgICAgICAgICAgIGlmIGJ1aWxkX2VhY2hfdGVzdDoKICAgICAgICAgICAgICAgICAgICBzZWxmLnNldHVwX2Zvcl90ZXN0X3J1bnMoW3Rlc3RdKQogICAgICAgICAgICAgICAgICAgIHNlbGYudGFzay5jb21waWxlKFRydWUpCiAgICAgICAgICAgICAgICBzdGFuZGFyZF9pbnB1dCA9IHRlc3QuZXh0cmEgaWYgc2VsZi5wYXJhbXNbJ3N0ZGluZnJvbWV4dHJhJ10gZWxzZSB0ZXN0LnN0ZGluCiAgICAgICAgICAgICAgICBpZiBzZWxmLnBhcmFtc1sndGVzdGlzYmFzaCddOgogICAgICAgICAgICAgICAgICAgIG91dHB1dCwgZXJyb3IgPSBzZWxmLnRhc2sucnVuX2NvZGUoc3RhbmRhcmRfaW5wdXQsIHRlc3QudGVzdGNvZGUpCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIG91dHB1dCwgZXJyb3IgPSBzZWxmLnRhc2sucnVuX2NvZGUoc3RhbmRhcmRfaW5wdXQpCiAgICAgICAgICAgICAgICBhZGp1c3RlZF9lcnJvciA9IHNlbGYuYWRqdXN0X2Vycm9yX2xpbmVfbnVtcyhlcnJvci5yc3RyaXAoKSkKICAgICAgICAgICAgICAgIHNlbGYucmVzdWx0X3RhYmxlLmFkZF9yb3codGVzdCwgb3V0cHV0LCBhZGp1c3RlZF9lcnJvcikKICAgICAgICAgICAgICAgIGlmIGVycm9yIGFuZCBzZWxmLnBhcmFtc1snYWJvcnRvbmVycm9yJ106CiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXN1bHRfdGFibGUudGVzdHNfbWlzc2VkKGxlbihzZWxmLnRlc3RjYXNlcykgLSBpX3Rlc3QgLSAxKQogICAgICAgICAgICAgICAgICAgIGJyZWFrCgogICAgZGVmIGNvbXBpbGVfYW5kX3J1bihzZWxmKToKICAgICAgICAiIiJQaGFzZSBvbmUgb2YgdGhlIHRlc3Qgb3BlcmF0aW9uOiBkbyBhIHRyaWFsIGNvbXBpbGUgYW5kIHRoZW4sIGlmIGFsbCBpcyB3ZWxsIGFuZCBpdCdzIG5vdCBhIHByZWNoZWNrLAogICAgICAgICAgIGNvbnRpbnVlIG9uIHRvIHJ1biBhbGwgdGVzdHMuCiAgICAgICAgICAgUmV0dXJuIGEgdHVwbGUgbWFyaywgZXJyb3JzIHdoZXJlIG1hcmsgaXMgYSBmcmFjdGlvbiBpbiAwIC0gMSBhbmQgZXJyb3JzIGlzIGEgbGlzdCBvZiBhbGwgdGhlIGVycm9ycy4KICAgICAgICAgICBzZWxmLnRlc3RfcmVzdWx0cyBjb250YWlucyBhbGwgdGhlIHRlc3QgZGV0YWlscy4KICAgICAgICAiIiIKICAgICAgICBtYXJrID0gMAogICAgICAgIGVycm9ycyA9IFtdCgogICAgICAgICMgRG8gYSB0cmlhbCBjb21waWxlLCB0aGVuIGEgc3R5bGUgY2hlY2suIElmIGFsbCBpcyB3ZWxsLCBydW4gdGhlIGNvZGUKICAgICAgICB0cnk6CiAgICAgICAgICAgIHNlbGYudHJpYWxfY29tcGlsZSgpCgogICAgICAgICAgICBpZiBub3Qgc2VsZi5wYXJhbXNbJ25vc3R5bGVjaGVja3MnXToKICAgICAgICAgICAgICAgIGVycm9ycyA9IHNlbGYuc3R5bGVfZXJyb3JzKCkKICAgICAgICAgICAgaWYgbm90IGVycm9yczoKICAgICAgICAgICAgICAgIGlmIHNlbGYucGFyYW1zWydJU19QUkVDSEVDSyddIGFuZCBzZWxmLnBhcmFtc1snUVVFU1RJT05fUFJFQ0hFQ0snXSA8PSAxOgogICAgICAgICAgICAgICAgICAgIG1hcmsgPSAxCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIHNlbGYucnVuX2FsbF90ZXN0cygpCiAgICAgICAgICAgICAgICAgICAgbWF4X21hcmsgPSBzdW0odGVzdC5tYXJrIGZvciB0ZXN0IGluIHNlbGYudGVzdGNhc2VzKQogICAgICAgICAgICAgICAgICAgIG1hcmsgPSBzZWxmLnJlc3VsdF90YWJsZS5nZXRfbWFyaygpIC8gbWF4X21hcmsgICMgRnJhY3Rpb25hbCBtYXJrIDAgLSAxCiAgICAgICAgZXhjZXB0IGxhbmd1YWdldGFzay5Db21waWxlRXJyb3IgYXMgZXJyOgogICAgICAgICAgICBhZGp1c3RlZF9lcnJvciA9IHNlbGYuYWRqdXN0X2Vycm9yX2xpbmVfbnVtcyhzdHIoZXJyKS5yc3RyaXAoKSkKICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgiQ09NUElMRSBFUlJPUlxuIiArIGFkanVzdGVkX2Vycm9yKQogICAgICAgIGV4Y2VwdCBsYW5ndWFnZXRhc2suUnVuRXJyb3IgYXMgZXJyOgogICAgICAgICAgICBhZGp1c3RlZF9lcnJvciA9IHNlbGYuYWRqdXN0X2Vycm9yX2xpbmVfbnVtcyhzdHIoZXJyKS5yc3RyaXAoKSkKICAgICAgICAgICAgZXJyb3JzLmFwcGVuZCgnUlVOIEVSUk9SXG4nICsgYWRqdXN0ZWRfZXJyb3IpCiAgICAgICAgcmV0dXJuIG1hcmssIGVycm9ycwoKICAgIGRlZiBwcmVydW5faG9vayhzZWxmKToKICAgICAgICAiIiJBIGhvb2sgZm9yIHN1YmNsYXNzZXMgdG8gZG8gaW5pdGlhbCBzZXR1cCBvciBjb2RlIGhhY2tzIGV0YwogICAgICAgICAgIFJldHVybnMgYSBsaXN0IG9mIGVycm9ycywgdG8gd2hpY2ggb3RoZXIgZXJyb3JzIGFyZSBhcHBlbmRlZAogICAgICAgICIiIgogICAgICAgIHJldHVybiBbXQoKICAgIGRlZiBnZXRfYWxsX2ltYWdlc19odG1sKHNlbGYpOgogICAgICAgIHIiIiJTZWFyY2ggdGhlIGN1cnJlbnQgZGlyZWN0b3J5IGZvciBpbWFnZXMgbmFtZWQgX2ltYWdlLiooRXhwZWN0ZWR8R290KShcZCspLnBuZy4KICAgICAgICAgICBGb3IgZWFjaCBzdWNoIGZpbGUgY29uc3RydWN0IGFuIGh0bWwgaW1nIGVsZW1lbnQgd2l0aCB0aGUgZGF0YSBlbmNvZGVkCiAgICAgICAgICAgaW4gYSBkYXRhdXJsLgogICAgICAgICAgIElmIHdlJ3JlIHJ1bm5pbmcgdGhlIHNhbXBsZSBhbnN3ZXIsIGFsd2F5cyByZXR1cm4gW10gLSBpbWFnZXMgd2lsbCBiZQogICAgICAgICAgIHBpY2tlZCB1cCB3aGVuIHdlIHJ1biB0aGUgYWN0dWFsIGFuc3dlci4KICAgICAgICAgICBSZXR1cm5zIGEgbGlzdCBvZiB0dXBsZXMgKGltZ19lbGVtZW50cywgY29sdW1uX25hbWUsIHJvd19udW1iZXIpIHdoZXJlCiAgICAgICAgICAgY29sdW1uX25hbWUgaXMgZWl0aGVyICdFeHBlY3RlZCcgb3IgJ0dvdCcsIGRlZmluaW5nIGluIHdoaWNoIHJlc3VsdCB0YWJsZQogICAgICAgICAgIGNvbHVtbiB0aGUgaW1hZ2UgYmVsb25ncyBhbmQgcm93IG51bWJlciBpcyB0aGUgcm93ICgwLW9yaWdpbiwgZXhjbHVkaW5nCiAgICAgICAgICAgdGhlIGhlYWRlciByb3cpLgogICAgICAgICIiIgogICAgICAgIGltYWdlcyA9IFtdCiAgICAgICAgaWYgc2VsZi5wYXJhbXMuZ2V0KCdydW5uaW5nX3NhbXBsZV9hbnN3ZXInLCBGYWxzZSk6CiAgICAgICAgICAgIHJldHVybiBbXQogICAgICAgIGlmIHNlbGYucGFyYW1zWydpbWFnZXdpZHRoJ10gaXMgbm90IE5vbmU6CiAgICAgICAgICAgIHdpZHRoX3NwZWMgPSAiIHdpZHRoPXt9Ii5mb3JtYXQoc2VsZi5wYXJhbXNbJ2ltYWdld2lkdGgnXSkKICAgICAgICBlbHNlOgogICAgICAgICAgICB3aWR0aF9zcGVjID0gIiIKICAgICAgICBmaWxlcyA9IHNvcnRlZChvcy5saXN0ZGlyKCcuJykpCiAgICAgICAgZm9yIGZpbGVuYW1lIGluIGZpbGVzOgogICAgICAgICAgICBtYXRjaCA9IHJlLm1hdGNoKHInX2ltYWdlW14uXSpcLihFeHBlY3RlZHxHb3QpXC4oXGQrKS5wbmcnLCBmaWxlbmFtZSkKICAgICAgICAgICAgaWYgbWF0Y2g6CiAgICAgICAgICAgICAgICBpbWFnZV9kYXRhID0gZ2V0X2pwZWdfYjY0KGZpbGVuYW1lKQogICAgICAgICAgICAgICAgaW1nX3RlbXBsYXRlID0gJzxpbWd7fSBzdHlsZT0ibWFyZ2luOjNweDtib3JkZXI6MXB4IHNvbGlkIGJsYWNrIiBzcmM9ImRhdGE6aW1hZ2UvanBlZztiYXNlNjQse30iPicKICAgICAgICAgICAgICAgIGltZ19odG1sID0gaW1nX3RlbXBsYXRlLmZvcm1hdCh3aWR0aF9zcGVjLCBpbWFnZV9kYXRhKQogICAgICAgICAgICAgICAgY29sdW1uID0gbWF0Y2guZ3JvdXAoMSkgICAjIE5hbWUgb2YgY29sdW1uCiAgICAgICAgICAgICAgICByb3cgPSBpbnQobWF0Y2guZ3JvdXAoMikpICMgMC1vcmlnaW4gcm93IG51bWJlcgogICAgICAgICAgICAgICAgaW1hZ2VzLmFwcGVuZCgoaW1nX2h0bWwsIGNvbHVtbiwgcm93KSkKICAgICAgICByZXR1cm4gaW1hZ2VzCgogICAgZGVmIHRlc3RfY29kZShzZWxmKToKICAgICAgICAiIiJUaGUgIm1haW4gcHJvZ3JhbSIgZm9yIHRlc3RpbmcuIFJldHVybnMgdGhlIHRlc3Qgb3V0Y29tZSwgcmVhZHkgdG8gYmUgcHJpbnRlZCBieSBqc29uLmR1bXBzIiIiCiAgICAgICAgZXJyb3JzID0gc2VsZi5wcmVydW5faG9vaygpCiAgICAgICAgaWYgZXJyb3JzOgogICAgICAgICAgICBtYXJrID0gMAogICAgICAgIGVsc2U6CiAgICAgICAgICAgIG1hcmssIGVycm9ycyA9IHNlbGYuY29tcGlsZV9hbmRfcnVuKCkKCiAgICAgICAgb3V0Y29tZSA9IHsiZnJhY3Rpb24iOiBtYXJrfQoKICAgICAgICBlcnJvcl90ZXh0ID0gJ1xuJy5qb2luKGVycm9ycykKICAgICAgICAjIFRPRE8gLSBjaGVjayBpZiBlcnJvciBsaW5lIG51bWJlcnMgYXJlIHN0aWxsIGJlaW5nIGNvcnJlY3RlZCBpbiBDIGFuZCBtYXRsYWIKICAgICAgICBpZiBzZWxmLnBhcmFtc1snSVNfUFJFQ0hFQ0snXToKICAgICAgICAgICAgaWYgbWFyayA9PSAxOgogICAgICAgICAgICAgICAgcHJvbG9ndWUgPSAiPHAgY2xhc3M9J3ByZWNoZWNrcmVzdWx0Jz5QYXNzZWQg8J+ZgjwvcD4iCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBwcm9sb2d1ZSA9ICI8cCBjbGFzcz0ncHJlY2hlY2tyZXN1bHQnPkZhaWxlZCwgYXMgZm9sbG93cy48L3A+IgogICAgICAgIGVsaWYgZXJyb3JzOgogICAgICAgICAgICBwcm9sb2d1ZSA9ICI8ZGl2IGNsYXNzPSdjb2RlcnVubmVyLXRlc3QtcmVzdWx0cyBiYWQnPjxoMz5QcmUtcnVuIGNoZWNrcyBmYWlsZWQ8L2gzPlxuIgogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHByb2xvZ3VlID0gIiIKCiAgICAgICAgaWYgcHJvbG9ndWU6CiAgICAgICAgICAgIG91dGNvbWVbJ3Byb2xvZ3VlaHRtbCddID0gcHJvbG9ndWUgKyBzZWxmLmh0bWxpemUoZXJyb3JfdGV4dCkKCiAgICAgICAgZXBpbG9ndWUgPSAnJwogICAgICAgIGltYWdlcyA9IHNlbGYuZ2V0X2FsbF9pbWFnZXNfaHRtbCgpCiAgICAgICAgaWYgaW1hZ2VzOgogICAgICAgICAgICBmb3IgKGltYWdlLCBjb2x1bW4sIHJvdykgaW4gaW1hZ2VzOgogICAgICAgICAgICAgICAgc2VsZi5yZXN1bHRfdGFibGUuYWRkX2ltYWdlKGltYWdlLCBjb2x1bW4sIHJvdykKICAgICAgICBvdXRjb21lWydjb2x1bW5mb3JtYXRzJ10gPSBzZWxmLnJlc3VsdF90YWJsZS5nZXRfY29sdW1uX2Zvcm1hdHMoKQoKICAgICAgICBpZiBsZW4oc2VsZi5yZXN1bHRfdGFibGUudGFibGUpID4gMToKICAgICAgICAgICAgb3V0Y29tZVsndGVzdHJlc3VsdHMnXSA9IHNlbGYucmVzdWx0X3RhYmxlLmdldF90YWJsZSgpCiAgICAgICAgICAgIG91dGNvbWVbJ3Nob3dkaWZmZXJlbmNlcyddID0gVHJ1ZQoKICAgICAgICBpZiBzZWxmLnJlc3VsdF90YWJsZS5nbG9iYWxfZXJyb3I6CiAgICAgICAgICAgIGVwaWxvZ3VlICs9ICI8ZGl2IGNsYXNzPSdjb2RlcnVubmVyLXRlc3QtcmVzdWx0cyBiYWQnPjxoND5SdW4gRXJyb3I8L2g0PjxwcmU+e308L3ByZT48L2Rpdj4iLmZvcm1hdCgKICAgICAgICAgICAgICAgIHNlbGYuaHRtbGl6ZShzZWxmLnJlc3VsdF90YWJsZS5nbG9iYWxfZXJyb3IpKQoKICAgICAgICBpZiBzZWxmLnJlc3VsdF90YWJsZS5hYm9ydGVkOgogICAgICAgICAgICBlcGlsb2d1ZSA9IG91dGNvbWUuZ2V0KCdlcGlsb2d1ZWh0bWwnLCAnJykgKyAoCiAgICAgICAgICAgICAgICAiPGRpdiBjbGFzcz0nY29kZXJ1bm5lci10ZXN0LXJlc3VsdHMgYmFkJz5UZXN0aW5nIHdhcyBhYm9ydGVkIGR1ZSB0byBydW50aW1lIGVycm9ycy48L2Rpdj4iKQoKICAgICAgICBpZiBzZWxmLnJlc3VsdF90YWJsZS5taXNzaW5nX3Rlc3RzICE9IDA6CiAgICAgICAgICAgIHRlbXBsYXRlID0gIjxkaXYgY2xhc3M9J2NvZGVydW5uZXItdGVzdC1yZXN1bHRzIGJhZCc+e30gdGVzdHMgbm90IHJ1biBkdWUgdG8gcHJldmlvdXMgZXJyb3JzLjwvZGl2PiIKICAgICAgICAgICAgZXBpbG9ndWUgKz0gdGVtcGxhdGUuZm9ybWF0KHNlbGYucmVzdWx0X3RhYmxlLm1pc3NpbmdfdGVzdHMpCgogICAgICAgIGlmIHNlbGYucmVzdWx0X3RhYmxlLmZhaWxlZF9oaWRkZW46CiAgICAgICAgICAgIGVwaWxvZ3VlICs9ICI8ZGl2IGNsYXNzPSdjb2RlcnVubmVyLXRlc3QtcmVzdWx0cyBiYWQnPk9uZSBvciBtb3JlIGhpZGRlbiB0ZXN0cyBmYWlsZWQuPC9kaXY+IgoKICAgICAgICBpZiBlcGlsb2d1ZToKICAgICAgICAgICAgb3V0Y29tZVsnZXBpbG9ndWVodG1sJ10gPSBlcGlsb2d1ZQogICAgICAgIHJldHVybiBvdXRjb21lCgogICAgQHN0YXRpY21ldGhvZAogICAgZGVmIGNsZWFuKGNvZGUpOgogICAgICAgICIiIlJldHVybiB0aGUgZ2l2ZW4gY29kZSB3aXRoIHRyYWlsaW5nIHdoaXRlIHNwYWNlIHN0cmlwcGVkIGZyb20gZWFjaCBsaW5lIiIiCiAgICAgICAgcmV0dXJuICdcbicuam9pbihbbGluZS5yc3RyaXAoKSBmb3IgbGluZSBpbiBjb2RlLnNwbGl0KCdcbicpXSkgKyAnXG4nCgogICAgQHN0YXRpY21ldGhvZAogICAgZGVmIGh0bWxpemUobWVzc2FnZSk6CiAgICAgICAgIiIiQW4gaHRtbCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBlcnJvciBtZXNzYWdlIiIiCiAgICAgICAgcmV0dXJuICc8cHJlPicgKyBodG1sLmVzY2FwZShtZXNzYWdlKSArICc8L3ByZT4nIGlmIG1lc3NhZ2UgZWxzZSAnJwo=</file>
<file name="__watchdog.py" path="/" encoding="base64">IyEvdXNyL2Jpbi9weXRob24KIyBmaWxlOiB3YXRjaGRvZy5weQojIGxpY2Vuc2U6IE1JVCBMaWNlbnNlCiMgRnJvbSBodHRwczovL2R6b25lLmNvbS9hcnRpY2xlcy9zaW1wbGUtcHl0aG9uLXdhdGNoZG9nLXRpbWVyCgppbXBvcnQgc2lnbmFsCgpjbGFzcyBXYXRjaGRvZyhFeGNlcHRpb24pOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHRpbWUpOgogICAgICAgICIiIlNldCB1cCBhIHRpbWVyIGFsYXJtIHRvIGdvIG9mZiBpbiAndGltZScgc2Vjcy4iIiIKICAgICAgICBzZWxmLnRpbWUgPSB0aW1lCgogICAgZGVmIF9fZW50ZXJfXyhzZWxmKToKICAgICAgICAiIiJDYWxsZWQgb24gZW50ZXJpbmcgYSAnd2l0aCcgYmxvY2siIiIKICAgICAgICBzaWduYWwuc2lnbmFsKHNpZ25hbC5TSUdBTFJNLCBzZWxmLmhhbmRsZXIpCiAgICAgICAgc2lnbmFsLmFsYXJtKHNlbGYudGltZSkKCiAgICBkZWYgX19leGl0X18oc2VsZiwgdHlwZSwgdmFsdWUsIHRyYWNlYmFjayk6CiAgICAgICAgIiIiRXhpdGluZyB0aGUgd2l0aCBibG9jay4gQ2FuY2VsIHRoZSB3YXRjaGRvZyIiIgogICAgICAgIHNpZ25hbC5hbGFybSgwKQoKICAgIGRlZiBoYW5kbGVyKHNlbGYsIHNpZ251bSwgZnJhbWUpOgogICAgICAgICIiIkFsYXJtIHdlbnQgb2ZmLiBSYWlzZSBXYXRjaGRvZyBleGNlcHRpb24iIiIKICAgICAgICByYWlzZSBzZWxmCgogICAgZGVmIF9fc3RyX18oc2VsZik6CiAgICAgICAgcmV0dXJuICJXYXRjaGRvZyB0aW1lciBleHBpcmVkIGFmdGVyIHt9IHNlY3MiLmZvcm1hdChzZWxmLnRpbWUpCg==</file>
    </testcases>
  </question>

</quiz>